This file is a merged representation of a subset of the codebase, containing specifically included files and files not matching ignore patterns, combined into a single document by Repomix.
The content has been processed where line numbers have been added.

<file_summary>
This section contains a summary of this file.

<purpose>
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.
</purpose>

<file_format>
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Repository files (if enabled)
5. Multiple file entries, each consisting of:
  - File path as an attribute
  - Full contents of the file
</file_format>

<usage_guidelines>
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.
- Pay special attention to the Repository Description. These contain important context and guidelines specific to this project.
</usage_guidelines>

<notes>
- Some files may have been excluded based on .gitignore rules and Repomix's configuration
- Binary files are not included in this packed representation. Please refer to the Repository Structure section for a complete list of file paths, including binary files
- Only files matching these patterns are included: **/*.go, **/cmd/**/*.go, **/cmd/**, holepunch-go/cmd/**, **/main.go, **/go.mod, **/go.sum, **/go.work, **/go.work.sum, **/*.py, **/*.md, **/*.mod, **/*.sum, **/*.yaml, **/*.yml, **/*.json, **/*.html, **/*.sh, **/Dockerfile*
- Files matching these patterns are excluded: .venv/**, venv/**, __pycache__/**, *.pyc, bin/**, *.log, *.tmp, .DS_Store, repomix-output.xml, .git/**, node_modules/**
- Files matching patterns in .gitignore are excluded
- Files matching default ignore patterns are excluded
- Line numbers have been added to the beginning of each line
- Files are sorted by Git change count (files with more changes are at the bottom)
</notes>

</file_summary>

<user_provided_header>
Holepunch P2P UDP Communication System - Go Implementation
</user_provided_header>

<directory_structure>
.claude/
  settings.local.json
holepunch-go/
  cmd/
    rendezvous/
      main.go
    worker/
      main.go
  deployments/
    Dockerfile.rendezvous
    Dockerfile.worker
  pkg/
    models/
      models.go
    p2p/
      protocol.go
    stun/
      stun.go
    websocket/
      client.go
  web/
    rendezvous/
      admin/
        admin-chat.html
        admin.html
    worker/
      index.html
  go.mod
  rebuild_and_deploy.sh
rendezvous_service_code/
  __init__.py
  admin_websocket.py
  admin-chat.html
  admin.html
  api_endpoints.py
  broadcast.py
  Dockerfile.rendezvous
  main_original_backup.py
  main.py
  models.py
  pairing.py
  README.md
  worker_websocket.py
Dockerfile.worker
index.html
main.py
rebuild_and_deploy.sh
repomix.config.json
</directory_structure>

<files>
This section contains the contents of the repository's files.

<file path=".claude/settings.local.json">
 1: {
 2:   "permissions": {
 3:     "allow": [
 4:       "Bash(gcloud logging read:*)",
 5:       "Bash(gcloud run services list:*)",
 6:       "Bash(grep:*)",
 7:       "Bash(gcloud run services logs read:*)",
 8:       "Bash(gcloud run logs read:*)",
 9:       "Bash(gcloud run services describe:*)",
10:       "Bash(gcloud run revisions list:*)",
11:       "Bash(python3:*)",
12:       "Bash(curl:*)",
13:       "WebFetch(domain:websockets.readthedocs.io)",
14:       "Bash(/opt/homebrew/lib/node_modules/@anthropic-ai/claude-code/vendor/ripgrep/arm64-darwin/rg -n \"v1/service|v1/announcement\" main.py)",
15:       "WebFetch(domain:github.com)",
16:       "Bash(mkdir:*)",
17:       "mcp__ide__getDiagnostics",
18:       "Bash(chmod:*)",
19:       "Bash(go mod init:*)",
20:       "Bash(true)",
21:       "Bash(go mod:*)",
22:       "Bash(source:*)",
23:       "Bash(docker buildx build:*)",
24:       "Bash(find:*)",
25:       "Bash(go build:*)",
26:       "Bash(docker build:*)",
27:       "Bash(docker push:*)",
28:       "Bash(gcloud run deploy:*)"
29:     ],
30:     "deny": []
31:   },
32:   "enableAllProjectMcpServers": false
33: }
</file>

<file path="holepunch-go/cmd/rendezvous/main.go">
  1: package main
  2: 
  3: import (
  4: 	"fmt"
  5: 	"log"
  6: 	"net"
  7: 	"net/http"
  8: 	"os"
  9: 	"strconv"
 10: 	"time"
 11: 
 12: 	"github.com/gorilla/websocket"
 13: 	"github.com/labstack/echo/v4"
 14: 	"github.com/labstack/echo/v4/middleware"
 15: 
 16: 	"github.com/elisilver/holepunch/pkg/models"
 17: )
 18: 
 19: var (
 20: 	state    *models.ServiceState
 21: 	upgrader = websocket.Upgrader{
 22: 		CheckOrigin:       func(r *http.Request) bool { return true },
 23: 		EnableCompression: true,
 24: 	}
 25: )
 26: 
 27: func main() {
 28: 	state = models.NewServiceState()
 29: 
 30: 	port := getEnvInt("PORT", 8080)
 31: 
 32: 	e := echo.New()
 33: 	e.Use(middleware.Logger())
 34: 	e.Use(middleware.Recover())
 35: 	e.Use(middleware.CORS())
 36: 
 37: 	// Static files
 38: 	e.Static("/", "./web/rendezvous")
 39: 	e.File("/admin", "./web/rendezvous/admin/admin.html")
 40: 	e.File("/admin-chat", "./web/rendezvous/admin/admin-chat.html")
 41: 
 42: 	// WebSocket endpoints
 43: 	e.GET("/ws/register/:worker_id", handleWorkerWebSocket)
 44: 	e.GET("/ws/admin", handleAdminWebSocket)
 45: 	e.GET("/ws/chat/:admin_session_id/:worker_id", handleAdminChatWebSocket)
 46: 
 47: 	// API endpoints
 48: 	e.GET("/api/workers", getWorkers)
 49: 	e.POST("/api/connect", connectWorkers)
 50: 
 51: 
 52: 	log.Printf("Rendezvous service starting on port %d", port)
 53: 	if err := e.Start(fmt.Sprintf(":%d", port)); err != nil {
 54: 		log.Fatalf("Failed to start server: %v", err)
 55: 	}
 56: }
 57: 
 58: func handleWorkerWebSocket(c echo.Context) error {
 59: 	log.Printf("WebSocket upgrade request from %s for worker %s", c.Request().RemoteAddr, c.Param("worker_id"))
 60: 
 61: 	ws, err := upgrader.Upgrade(c.Response(), c.Request(), nil)
 62: 	if err != nil {
 63: 		log.Printf("WebSocket upgrade failed: %v", err)
 64: 		return err
 65: 	}
 66: 	defer ws.Close()
 67: 
 68: 	workerID := c.Param("worker_id")
 69: 	clientIP := c.RealIP()
 70: 	
 71: 	// Extract client port from RemoteAddr
 72: 	clientAddr := c.Request().RemoteAddr
 73: 	var clientPort int
 74: 	if _, portStr, err := net.SplitHostPort(clientAddr); err == nil {
 75: 		clientPort, _ = strconv.Atoi(portStr)
 76: 	}
 77: 	
 78: 	log.Printf("Worker %s connected from %s:%d", workerID, clientIP, clientPort)
 79: 
 80: 	// Check for duplicate worker and handle it
 81: 	state.Mu.Lock()
 82: 	if oldWorker, exists := state.ConnectedWorkers[workerID]; exists {
 83: 		log.Printf("Worker %s re-connecting, closing old connection", workerID)
 84: 		if oldWorker.Websocket != nil {
 85: 			oldWorker.Websocket.WriteMessage(websocket.CloseMessage,
 86: 				websocket.FormatCloseMessage(websocket.CloseServiceRestart, "New connection from same worker ID"))
 87: 			oldWorker.Websocket.Close()
 88: 		}
 89: 		// Remove from pairing list if present
 90: 		newPairingList := []string{}
 91: 		for _, id := range state.WorkersReadyForPairing {
 92: 			if id != workerID {
 93: 				newPairingList = append(newPairingList, id)
 94: 			}
 95: 		}
 96: 		state.WorkersReadyForPairing = newPairingList
 97: 	}
 98: 	
 99: 	// Initialize worker info
100: 	state.ConnectedWorkers[workerID] = &models.WorkerInfo{
101: 		ID:                    workerID,
102: 		WebsocketObservedIP:   clientIP,
103: 		WebsocketObservedPort: clientPort,
104: 		ConnectedAt:           time.Now(),
105: 		LastPingAt:            time.Now(),
106: 		Websocket:             ws,
107: 	}
108: 	state.Mu.Unlock()
109: 
110: 	log.Printf("Worker %s registered", workerID)
111: 	broadcastWorkerUpdate()
112: 	broadcastWorkerConnected(workerID, clientIP)
113: 
114: 	// Read and process the first message, then loop for subsequent messages
115: 	var firstMsg models.WebSocketMessage
116: 	if err := ws.ReadJSON(&firstMsg); err != nil {
117: 		log.Printf("Failed to read first message from worker %s: %v", workerID, err)
118: 		removeWorker(workerID)
119: 		return nil // End handler for this worker
120: 	}
121: 	// Process the first message immediately
122: 	handleWorkerMessage(workerID, &firstMsg)
123: 
124: 	// Handle subsequent messages in a loop
125: 	// N.B.: The original `go func() { ... handleWorkerMessage ...}` loop is removed
126: 	// as messages will now be processed sequentially in the main handler goroutine after the first.
127: 	// This also simplifies reasoning about when removeWorker is called relative to message handling.
128: 
129: 	// Keep pong handler to handle pings from worker
130: 	ws.SetReadDeadline(time.Now().Add(35 * time.Second)) // Set initial read deadline
131: 	ws.SetPongHandler(func(string) error {
132: 		ws.SetReadDeadline(time.Now().Add(35 * time.Second)) // Reset read deadline on pong
133: 		state.Mu.Lock()
134: 		if worker, ok := state.ConnectedWorkers[workerID]; ok {
135: 			worker.LastPingAt = time.Now()
136: 		}
137: 		state.Mu.Unlock()
138: 		return nil
139: 	})
140: 
141: 	// Main message reading loop
142: 	for {
143: 		var msg models.WebSocketMessage
144: 		if err := ws.ReadJSON(&msg); err != nil {
145: 			if websocket.IsUnexpectedCloseError(err, websocket.CloseGoingAway, websocket.CloseAbnormalClosure) {
146: 				log.Printf("Worker %s read error: %v", workerID, err)
147: 			} else {
148: 				log.Printf("Worker %s disconnected (read deadline or other error): %v", workerID, err)
149: 			}
150: 			removeWorker(workerID)
151: 			return nil
152: 		}
153: 		ws.SetReadDeadline(time.Now().Add(35 * time.Second)) // Reset read deadline after successful message read
154: 		handleWorkerMessage(workerID, &msg)
155: 	}
156: }
157: 
158: func handleWorkerMessage(workerID string, msg *models.WebSocketMessage) {
159: 	switch msg.Type {
160: 	case "update_udp_endpoint":
161: 		publicIP, ipOk := msg.Payload["udp_ip"].(string)
162: 
163: 		// Simplified UDP port parsing to match Python's behavior
164: 		var publicPort int
165: 		portVal, portOk := msg.Payload["udp_port"]
166: 		if !portOk {
167: 			log.Printf("Worker %s: udp_port missing in endpoint update", workerID)
168: 			return
169: 		}
170: 		switch v := portVal.(type) {
171: 		case float64:
172: 			publicPort = int(v)
173: 		case int:
174: 			publicPort = v
175: 		default:
176: 			log.Printf("Worker %s: invalid udp_port type: %T", workerID, v)
177: 			return
178: 		}
179: 
180: 		if !ipOk || publicIP == "" {
181: 			log.Printf("Worker %s sent invalid UDP endpoint update", workerID)
182: 			return
183: 		}
184: 
185: 		state.Mu.Lock()
186: 		if worker, ok := state.ConnectedWorkers[workerID]; ok {
187: 			worker.StunReportedUDPIP = publicIP
188: 			worker.StunReportedUDPPort = publicPort
189: 
190: 			// Add to pairing list if not already there
191: 			found := false
192: 			for _, id := range state.WorkersReadyForPairing {
193: 				if id == workerID {
194: 					found = true
195: 					break
196: 				}
197: 			}
198: 			if !found {
199: 				state.WorkersReadyForPairing = append(state.WorkersReadyForPairing, workerID)
200: 			}
201: 		}
202: 		state.Mu.Unlock()
203: 
204: 		// Send acknowledgment
205: 		response := models.WebSocketMessage{
206: 			Type: "udp_endpoint_ack",
207: 			Payload: map[string]interface{}{
208: 				"status": "received",
209: 			},
210: 		}
211: 
212: 		state.Mu.RLock()
213: 		if worker, ok := state.ConnectedWorkers[workerID]; ok {
214: 			worker.Websocket.WriteJSON(response)
215: 		}
216: 		state.Mu.RUnlock()
217: 
218: 		log.Printf("Worker %s UDP endpoint updated: %s:%d", workerID, publicIP, publicPort)
219: 		broadcastWorkerUpdate()
220: 		broadcastWorkerUDPUpdated(workerID, publicIP, publicPort)
221: 
222: 		// Attempt to pair workers
223: 		attemptToPairWorkers(workerID)
224: 
225: 	case "echo_request":
226: 		data := msg.Payload["data"]
227: 		response := models.WebSocketMessage{
228: 			Type: "echo_response",
229: 			Payload: map[string]interface{}{
230: 				"data": data,
231: 			},
232: 		}
233: 
234: 		state.Mu.RLock()
235: 		if worker, ok := state.ConnectedWorkers[workerID]; ok {
236: 			worker.Websocket.WriteJSON(response)
237: 		}
238: 		state.Mu.RUnlock()
239: 
240: 	case "chat_response":
241: 		adminSessionID := msg.Payload["admin_session_id"].(string)
242: 		content := msg.Payload["content"].(string)
243: 
244: 		state.Mu.RLock()
245: 		if sessions, ok := state.ChatSessions[adminSessionID]; ok {
246: 			if adminWS, ok := sessions[workerID]; ok {
247: 				adminWS.WriteJSON(map[string]interface{}{
248: 					"type": "chat_message",
249: 					"from": "worker",
250: 					"payload": map[string]interface{}{
251: 						"worker_id": workerID,
252: 						"content":   content,
253: 						"timestamp": time.Now().Format(time.RFC3339),
254: 					},
255: 				})
256: 			}
257: 		}
258: 		state.Mu.RUnlock()
259: 	}
260: }
261: 
262: func handleAdminWebSocket(c echo.Context) error {
263: 	ws, err := upgrader.Upgrade(c.Response(), c.Request(), nil)
264: 	if err != nil {
265: 		return err
266: 	}
267: 	defer ws.Close()
268: 
269: 	state.Mu.Lock()
270: 	state.AdminWebsocketClients = append(state.AdminWebsocketClients, ws)
271: 	state.Mu.Unlock()
272: 
273: 	// Send initial connection message like Python
274: 	ws.WriteJSON(map[string]interface{}{
275: 		"type":    "connected",
276: 		"message": "Connected to admin WebSocket",
277: 	})
278: 
279: 	// Send initial state
280: 	workers, _ := getWorkersInfo()
281: 	ws.WriteJSON(map[string]interface{}{
282: 		"type":    "workers_update",
283: 		"payload": workers,
284: 	})
285: 
286: 	// Keep connection alive and handle text-based ping
287: 	for {
288: 		messageType, p, err := ws.ReadMessage()
289: 		if err != nil {
290: 			removeAdminClient(ws)
291: 			return nil
292: 		}
293: 		// Handle text-based ping from admin UI
294: 		if messageType == websocket.TextMessage && string(p) == "ping" {
295: 			// Send JSON pong response like Python does
296: 			if err := ws.WriteJSON(map[string]interface{}{"type": "pong"}); err != nil {
297: 				log.Printf("Admin pong failed: %v", err)
298: 				removeAdminClient(ws)
299: 				return nil
300: 			}
301: 		}
302: 	}
303: }
304: 
305: func handleAdminChatWebSocket(c echo.Context) error {
306: 	workerID := c.Param("worker_id")
307: 	adminSessionID := c.Param("admin_session_id")
308: 
309: 	ws, err := upgrader.Upgrade(c.Response(), c.Request(), nil)
310: 	if err != nil {
311: 		return err
312: 	}
313: 	defer ws.Close()
314: 
315: 	state.Mu.Lock()
316: 	if state.ChatSessions[adminSessionID] == nil {
317: 		state.ChatSessions[adminSessionID] = make(map[string]*websocket.Conn)
318: 	}
319: 	state.ChatSessions[adminSessionID][workerID] = ws
320: 	state.Mu.Unlock()
321: 
322: 	// Send initial connection confirmation
323: 	if err := ws.WriteJSON(map[string]interface{}{
324: 		"type":      "chat_connected",
325: 		"worker_id": workerID,
326: 		"message":   fmt.Sprintf("Connected to worker %s for chat", workerID),
327: 	}); err != nil {
328: 		log.Printf("Failed to send chat_connected to admin %s for worker %s: %v", adminSessionID, workerID, err)
329: 		return err
330: 	}
331: 
332: 	// Handle messages from admin
333: 	for {
334: 		var msg map[string]interface{}
335: 		if err := ws.ReadJSON(&msg); err != nil {
336: 			state.Mu.Lock()
337: 			delete(state.ChatSessions[adminSessionID], workerID)
338: 			state.Mu.Unlock()
339: 			return nil
340: 		}
341: 
342: 		if msg["type"] == "chat_message" {
343: 			content := msg["content"].(string)
344: 
345: 			state.Mu.RLock()
346: 			if worker, ok := state.ConnectedWorkers[workerID]; ok {
347: 				worker.Websocket.WriteJSON(models.WebSocketMessage{
348: 					Type: "admin_chat_message",
349: 					Payload: map[string]interface{}{
350: 						"admin_session_id": adminSessionID,
351: 						"content":          content,
352: 					},
353: 				})
354: 			}
355: 			state.Mu.RUnlock()
356: 
357: 			// Echo the message back to admin
358: 			if err := ws.WriteJSON(map[string]interface{}{
359: 				"type":      "chat_message",
360: 				"from":      "admin",
361: 				"content":   content,
362: 				"timestamp": time.Now().Format(time.RFC3339Nano),
363: 			}); err != nil {
364: 				log.Printf("Failed to echo chat message to admin %s for worker %s: %v", adminSessionID, workerID, err)
365: 			}
366: 		}
367: 	}
368: }
369: 
370: func getWorkers(c echo.Context) error {
371: 	workersList, counts := getWorkersInfo()
372: 	return c.JSON(200, map[string]interface{}{
373: 		"workers":         workersList,
374: 		"total_count":     counts["total"],
375: 		"connected_count": counts["connected"],
376: 		"ready_count":     counts["ready"],
377: 	})
378: }
379: 
380: func connectWorkers(c echo.Context) error {
381: 	var req struct {
382: 		WorkerAID string `json:"worker_a_id"`
383: 		WorkerBID string `json:"worker_b_id"`
384: 	}
385: 
386: 	if err := c.Bind(&req); err != nil {
387: 		return c.JSON(400, map[string]string{"error": "Invalid request"})
388: 	}
389: 
390: 	if err := pairWorkers(req.WorkerAID, req.WorkerBID); err != nil {
391: 		return c.JSON(400, map[string]string{"error": err.Error()})
392: 	}
393: 
394: 	return c.JSON(200, map[string]string{"status": "success", "message": "Workers connected"})
395: }
396: 
397: func pairWorkers(workerID1, workerID2 string) error {
398: 	state.Mu.RLock()
399: 	worker1, ok1 := state.ConnectedWorkers[workerID1]
400: 	worker2, ok2 := state.ConnectedWorkers[workerID2]
401: 	state.Mu.RUnlock()
402: 
403: 	if !ok1 || !ok2 {
404: 		return fmt.Errorf("one or both workers not found")
405: 	}
406: 
407: 	if worker1.StunReportedUDPIP == "" || worker2.StunReportedUDPIP == "" {
408: 		return fmt.Errorf("UDP endpoints not ready")
409: 	}
410: 
411: 	// Send connection offers to both workers
412: 	offer1 := models.WebSocketMessage{
413: 		Type: "p2p_connection_offer",
414: 		Payload: map[string]interface{}{
415: 			"peer_worker_id": workerID2,
416: 			"peer_udp_ip":    worker2.StunReportedUDPIP,
417: 			"peer_udp_port":  worker2.StunReportedUDPPort,
418: 		},
419: 	}
420: 
421: 	offer2 := models.WebSocketMessage{
422: 		Type: "p2p_connection_offer",
423: 		Payload: map[string]interface{}{
424: 			"peer_worker_id": workerID1,
425: 			"peer_udp_ip":    worker1.StunReportedUDPIP,
426: 			"peer_udp_port":  worker1.StunReportedUDPPort,
427: 		},
428: 	}
429: 
430: 	if err := worker1.Websocket.WriteJSON(offer1); err != nil {
431: 		return fmt.Errorf("failed to send offer to worker1: %w", err)
432: 	}
433: 
434: 	if err := worker2.Websocket.WriteJSON(offer2); err != nil {
435: 		return fmt.Errorf("failed to send offer to worker2: %w", err)
436: 	}
437: 
438: 	log.Printf("Paired workers %s and %s", workerID1, workerID2)
439: 	broadcastConnectionInitiated(workerID1, workerID2)
440: 	return nil
441: }
442: 
443: func removeWorker(workerID string) {
444: 	state.Mu.Lock()
445: 	delete(state.ConnectedWorkers, workerID)
446: 
447: 	// Remove from pairing list
448: 	newList := make([]string, 0)
449: 	for _, id := range state.WorkersReadyForPairing {
450: 		if id != workerID {
451: 			newList = append(newList, id)
452: 		}
453: 	}
454: 	state.WorkersReadyForPairing = newList
455: 	state.Mu.Unlock()
456: 
457: 	broadcastWorkerUpdate()
458: 	broadcastWorkerDisconnected(workerID)
459: }
460: 
461: func removeAdminClient(ws *websocket.Conn) {
462: 	state.Mu.Lock()
463: 	newList := make([]*websocket.Conn, 0)
464: 	for _, client := range state.AdminWebsocketClients {
465: 		if client != ws {
466: 			newList = append(newList, client)
467: 		}
468: 	}
469: 	state.AdminWebsocketClients = newList
470: 	state.Mu.Unlock()
471: }
472: 
473: func attemptToPairWorkers(newWorkerID string) {
474: 	state.Mu.Lock()
475: 	defer state.Mu.Unlock()
476: 
477: 	// Build extra_candidates: all connected workers with UDP info not in ready list
478: 	extraCandidates := []string{}
479: 	for id, worker := range state.ConnectedWorkers {
480: 		if id == newWorkerID {
481: 			continue // Skip the new worker itself
482: 		}
483: 		if worker.Websocket != nil && worker.StunReportedUDPIP != "" && worker.StunReportedUDPPort > 0 {
484: 			// Check if not already in WorkersReadyForPairing
485: 			inReadyList := false
486: 			for _, readyID := range state.WorkersReadyForPairing {
487: 				if readyID == id {
488: 					inReadyList = true
489: 					break
490: 				}
491: 			}
492: 			if !inReadyList {
493: 				extraCandidates = append(extraCandidates, id)
494: 			}
495: 		}
496: 	}
497: 
498: 	// Combine WorkersReadyForPairing with extraCandidates for candidate pool
499: 	candidatePool := make([]string, len(state.WorkersReadyForPairing))
500: 	copy(candidatePool, state.WorkersReadyForPairing)
501: 	candidatePool = append(candidatePool, extraCandidates...)
502: 
503: 	// Check if we have at least 2 candidates for pairing
504: 	if len(candidatePool) < 2 {
505: 		log.Printf("Not enough workers available for pairing (%d total candidates). Waiting for more.", len(candidatePool))
506: 		return
507: 	}
508: 
509: 	// Find two workers to pair from the candidate pool
510: 	var worker1ID, worker2ID string
511: 	for _, id := range candidatePool {
512: 		if worker1ID == "" {
513: 			worker1ID = id
514: 		} else if worker2ID == "" {
515: 			worker2ID = id
516: 			break
517: 		}
518: 	}
519: 
520: 	// Validate both workers
521: 	worker1, ok1 := state.ConnectedWorkers[worker1ID]
522: 	worker2, ok2 := state.ConnectedWorkers[worker2ID]
523: 
524: 	if !ok1 || !ok2 || worker1.StunReportedUDPIP == "" || worker2.StunReportedUDPIP == "" {
525: 		log.Printf("Workers not ready for pairing (missing data)")
526: 		return
527: 	}
528: 
529: 	// Remove from ready list (if they were in it)
530: 	newReadyList := []string{}
531: 	for _, id := range state.WorkersReadyForPairing {
532: 		if id != worker1ID && id != worker2ID {
533: 			newReadyList = append(newReadyList, id)
534: 		}
535: 	}
536: 	state.WorkersReadyForPairing = newReadyList
537: 
538: 	log.Printf("Pairing workers %s and %s", worker1ID, worker2ID)
539: 
540: 	// Send connection offers
541: 	offer1 := models.WebSocketMessage{
542: 		Type: "p2p_connection_offer",
543: 		Payload: map[string]interface{}{
544: 			"peer_worker_id": worker2ID,
545: 			"peer_udp_ip":    worker2.StunReportedUDPIP,
546: 			"peer_udp_port":  worker2.StunReportedUDPPort,
547: 		},
548: 	}
549: 
550: 	offer2 := models.WebSocketMessage{
551: 		Type: "p2p_connection_offer",
552: 		Payload: map[string]interface{}{
553: 			"peer_worker_id": worker1ID,
554: 			"peer_udp_ip":    worker1.StunReportedUDPIP,
555: 			"peer_udp_port":  worker1.StunReportedUDPPort,
556: 		},
557: 	}
558: 
559: 	if err := worker1.Websocket.WriteJSON(offer1); err != nil {
560: 		log.Printf("Failed to send offer to worker %s: %v", worker1ID, err)
561: 	}
562: 
563: 	if err := worker2.Websocket.WriteJSON(offer2); err != nil {
564: 		log.Printf("Failed to send offer to worker %s: %v", worker2ID, err)
565: 	}
566: 	
567: 	// Broadcast pairing event
568: 	broadcastConnectionInitiated(worker1ID, worker2ID)
569: }
570: 
571: func broadcastWorkerUpdate() {
572: 	workers, counts := getWorkersInfo()
573: 	
574: 	// Create payload structure that matches the UI expectation
575: 	payload := map[string]interface{}{
576: 		"workers":         workers,
577: 		"total_count":     counts["total"],
578: 		"connected_count": counts["connected"],
579: 		"ready_count":     counts["ready"],
580: 	}
581: 	
582: 	msg := map[string]interface{}{
583: 		"type":    "workers_update",
584: 		"payload": payload,
585: 	}
586: 
587: 	state.Mu.RLock()
588: 	clients := state.AdminWebsocketClients
589: 	state.Mu.RUnlock()
590: 
591: 	for _, client := range clients {
592: 		client.WriteJSON(msg)
593: 	}
594: }
595: 
596: func broadcastToAdmins(message map[string]interface{}) {
597: 	state.Mu.RLock()
598: 	clients := make([]*websocket.Conn, len(state.AdminWebsocketClients))
599: 	copy(clients, state.AdminWebsocketClients)
600: 	state.Mu.RUnlock()
601: 
602: 	for _, client := range clients {
603: 		if err := client.WriteJSON(message); err != nil {
604: 			log.Printf("Failed to broadcast to admin client: %v", err)
605: 		}
606: 	}
607: }
608: 
609: func broadcastWorkerConnected(workerID string, websocketIP string) {
610: 	state.Mu.RLock()
611: 	totalWorkers := len(state.ConnectedWorkers)
612: 	state.Mu.RUnlock()
613: 
614: 	broadcastToAdmins(map[string]interface{}{
615: 		"type": "worker_connected",
616: 		"worker_id": workerID,
617: 		"websocket_ip": websocketIP,
618: 		"total_workers": totalWorkers,
619: 	})
620: }
621: 
622: func broadcastWorkerDisconnected(workerID string) {
623: 	state.Mu.RLock()
624: 	totalWorkers := len(state.ConnectedWorkers)
625: 	state.Mu.RUnlock()
626: 
627: 	broadcastToAdmins(map[string]interface{}{
628: 		"type": "worker_disconnected",
629: 		"worker_id": workerID,
630: 		"total_workers": totalWorkers,
631: 	})
632: }
633: 
634: func broadcastWorkerUDPUpdated(workerID string, udpIP string, udpPort int) {
635: 	broadcastToAdmins(map[string]interface{}{
636: 		"type": "worker_udp_updated",
637: 		"worker_id": workerID,
638: 		"udp_ip": udpIP,
639: 		"udp_port": udpPort,
640: 	})
641: }
642: 
643: func broadcastConnectionInitiated(workerAID, workerBID string) {
644: 	broadcastToAdmins(map[string]interface{}{
645: 		"type": "connection_initiated",
646: 		"worker_a_id": workerAID,
647: 		"worker_b_id": workerBID,
648: 		"timestamp": time.Now().Format(time.RFC3339),
649: 	})
650: }
651: 
652: func getWorkersInfo() ([]map[string]interface{}, map[string]int) {
653: 	state.Mu.RLock()
654: 	defer state.Mu.RUnlock()
655: 
656: 	workers := make([]map[string]interface{}, 0)
657: 	readyCount := 0
658: 	
659: 	for id, worker := range state.ConnectedWorkers {
660: 		// Check if worker is in ready for pairing list
661: 		isReady := false
662: 		for _, readyID := range state.WorkersReadyForPairing {
663: 			if readyID == id {
664: 				isReady = true
665: 				readyCount++
666: 				break
667: 			}
668: 		}
669: 		
670: 		workers = append(workers, map[string]interface{}{
671: 			"worker_id":           id,
672: 			"websocket_connected": worker.Websocket != nil,
673: 			"has_udp_endpoint":    worker.StunReportedUDPIP != "" && worker.StunReportedUDPPort > 0,
674: 			"ready_for_pairing":   isReady,
675: 			"websocket_ip":        worker.WebsocketObservedIP,
676: 			"websocket_port":      worker.WebsocketObservedPort,
677: 			"public_ip":           worker.HTTPReportedPublicIP,  // Added for Python admin UI compatibility
678: 			"udp_ip":              worker.StunReportedUDPIP,    // Python compatibility (without 'stun_' prefix)
679: 			"udp_port":            worker.StunReportedUDPPort,  // Python compatibility (without 'stun_' prefix)
680: 			"stun_udp_ip":         worker.StunReportedUDPIP,
681: 			"stun_udp_port":       worker.StunReportedUDPPort,
682: 		})
683: 	}
684: 	
685: 	counts := map[string]int{
686: 		"total":     len(workers),
687: 		"connected": len(workers),
688: 		"ready":     readyCount,
689: 	}
690: 	
691: 	return workers, counts
692: }
693: 
694: func getEnvInt(key string, defaultValue int) int {
695: 	if v := os.Getenv(key); v != "" {
696: 		if i, err := strconv.Atoi(v); err == nil {
697: 			return i
698: 		}
699: 	}
700: 	return defaultValue
701: }
</file>

<file path="holepunch-go/cmd/worker/main.go">
  1: package main
  2: 
  3: import (
  4: 	"encoding/base64"
  5: 	"fmt"
  6: 	"log"
  7: 	"net"
  8: 	"net/http"
  9: 	"os"
 10: 	"os/signal"
 11: 	"strconv"
 12: 	"strings"
 13: 	"syscall"
 14: 	"time"
 15: 
 16: 	"github.com/google/uuid"
 17: 	"github.com/gorilla/websocket"
 18: 	"github.com/labstack/echo/v4"
 19: 	"github.com/labstack/echo/v4/middleware"
 20: 
 21: 	"github.com/elisilver/holepunch/pkg/models"
 22: 	"github.com/elisilver/holepunch/pkg/p2p"
 23: 	"github.com/elisilver/holepunch/pkg/stun"
 24: 	ws "github.com/elisilver/holepunch/pkg/websocket"
 25: )
 26: 
 27: var (
 28: 	state    *models.WorkerState
 29: 	wsClient *ws.Client
 30: 	p2pProto *p2p.P2PProtocol
 31: 	udpConn  *net.UDPConn
 32: 	upgrader = websocket.Upgrader{
 33: 		CheckOrigin: func(r *http.Request) bool { return true },
 34: 	}
 35: )
 36: 
 37: func setupUDPListener(port int) (*net.UDPConn, error) {
 38: 	// Use the specified port (matching Python's behavior)
 39: 	listenAddr := fmt.Sprintf("0.0.0.0:%d", port)
 40: 	
 41: 	udpAddr, err := net.ResolveUDPAddr("udp4", listenAddr)
 42: 	if err != nil {
 43: 		return nil, fmt.Errorf("resolve UDP addr: %w", err)
 44: 	}
 45: 	conn, err := net.ListenUDP("udp4", udpAddr)
 46: 	if err != nil {
 47: 		return nil, fmt.Errorf("listen UDP: %w", err)
 48: 	}
 49: 
 50: 	// Set buffer sizes for better performance
 51: 	if err := conn.SetReadBuffer(1024 * 1024); err != nil { // 1MB
 52: 		log.Printf("Warning: failed to set read buffer: %v", err)
 53: 	}
 54: 	if err := conn.SetWriteBuffer(1024 * 1024); err != nil { // 1MB
 55: 		log.Printf("Warning: failed to set write buffer: %v", err)
 56: 	}
 57: 
 58: 	actualAddr := conn.LocalAddr().(*net.UDPAddr)
 59: 	log.Printf("UDP listener started on %s (actual port %d, requested port %d)", actualAddr.String(), actualAddr.Port, port)
 60: 	return conn, nil
 61: }
 62: 
 63: func main() {
 64: 	workerID := uuid.New().String()
 65: 	state = models.NewWorkerState(workerID)
 66: 
 67: 	log.Printf("Worker starting with ID: %s", workerID)
 68: 
 69: 	rendezvousURL := os.Getenv("RENDEZVOUS_SERVICE_URL")
 70: 	if rendezvousURL == "" {
 71: 		log.Fatal("RENDEZVOUS_SERVICE_URL environment variable is required")
 72: 	}
 73: 
 74: 	port := getEnvInt("PORT", 8080)
 75: 	udpPort := getEnvInt("INTERNAL_UDP_PORT", 8081)
 76: 
 77: 	// Setup HTTP server first to ensure Cloud Run health checks pass
 78: 	e := echo.New()
 79: 	e.Use(middleware.Logger())
 80: 	e.Use(middleware.Recover())
 81: 	e.Use(middleware.CORS())
 82: 
 83: 	e.Static("/", "web/worker")
 84: 	e.GET("/ui_ws", handleUIWebSocket)
 85: 	e.GET("/health", func(c echo.Context) error {
 86: 		return c.String(http.StatusOK, "OK")
 87: 	})
 88: 
 89: 	// Start HTTP server in goroutine
 90: 	go func() {
 91: 		log.Printf("Worker UI starting on port %d", port)
 92: 		if err := e.Start(fmt.Sprintf(":%d", port)); err != nil && err != http.ErrServerClosed {
 93: 			log.Fatalf("Failed to start HTTP server: %v", err)
 94: 		}
 95: 	}()
 96: 
 97: 	// Give the HTTP server a moment to start
 98: 	time.Sleep(100 * time.Millisecond)
 99: 
100: 	// Now setup UDP and STUN discovery after HTTP server is running
101: 	go func() {
102: 		log.Printf("Starting STUN discovery phase first...")
103: 
104: 		stunHost := getEnvStr("STUN_HOST", "stun.l.google.com")
105: 		stunPort := getEnvInt("STUN_PORT", 19302)
106: 		// STUN discovery will attempt to bind locally to udpPort (INTERNAL_UDP_PORT)
107: 		localStunBindAddr := fmt.Sprintf(":%d", udpPort)
108: 
109: 		type stunDiscoveryOp struct {
110: 			result *stun.STUNResult
111: 			err    error
112: 		}
113: 		stunResultChan := make(chan stunDiscoveryOp, 1)
114: 
115: 		go func() {
116: 			log.Printf("Attempting STUN discovery: STUN client will bind locally to %s, targeting STUN server %s:%d", localStunBindAddr, stunHost, stunPort)
117: 			// stun.DiscoverWithRetry internally creates a listener on localStunBindAddr,
118: 			// performs STUN, and then its listener is closed (due to defer pConn.Close() in DiscoverPublicEndpointWithTimeout).
119: 			sRes, sErr := stun.DiscoverWithRetry(localStunBindAddr, stunHost, stunPort, 3) // Max 3 retries
120: 			stunResultChan <- stunDiscoveryOp{result: sRes, err: sErr}
121: 		}()
122: 
123: 		// Wait for STUN discovery to complete or timeout
124: 		select {
125: 		case res := <-stunResultChan:
126: 			if res.err != nil {
127: 				log.Printf("STUN discovery failed: %v", res.err)
128: 				log.Printf("Continuing without STUN endpoint information.")
129: 				// state.OurStunDiscoveredUDPIP and OurStunDiscoveredUDPPort will remain empty/zero
130: 			} else {
131: 				log.Printf("STUN discovery successful. Public UDP endpoint: %s:%d", res.result.PublicIP, res.result.PublicPort)
132: 				state.Mu.Lock()
133: 				state.OurStunDiscoveredUDPIP = res.result.PublicIP
134: 				state.OurStunDiscoveredUDPPort = res.result.PublicPort
135: 				state.Mu.Unlock()
136: 			}
137: 		case <-time.After(30 * time.Second): // Overall timeout for STUN discovery
138: 			log.Printf("STUN discovery timed out after 30 seconds.")
139: 			log.Printf("Continuing without STUN endpoint information.")
140: 		}
141: 
142: 		// STUN discovery phase is now complete, and the temporary listener used by it is closed.
143: 		// Now, set up the main P2P UDP listener on the same udpPort.
144: 		log.Printf("STUN phase finished. Setting up main P2P UDP listener on port %d...", udpPort)
145: 		var errSetupListener error
146: 		udpConn, errSetupListener = setupUDPListener(udpPort) // This should now succeed
147: 		if errSetupListener != nil {
148: 			log.Printf("CRITICAL: Failed to setup main P2P UDP listener on port %d: %v", udpPort, errSetupListener)
149: 			// Worker might still connect to rendezvous but P2P will likely fail.
150: 			// Depending on requirements, you might want to os.Exit(1) or handle this state.
151: 		} else {
152: 			mainListenerAddr := udpConn.LocalAddr().(*net.UDPAddr)
153: 			log.Printf("Main P2P UDP listener established on %s (requested port %d)", mainListenerAddr.String(), udpPort)
154: 			
155: 			p2pProto = p2p.NewP2PProtocol(udpConn, state)
156: 			go p2pProto.Start() // Start the P2P read loop
157: 		}
158: 
159: 		// Connect to rendezvous service after STUN discovery and UDP setup
160: 		connectToRendezvous(workerID, rendezvousURL)
161: 	}()
162: 
163: 	// Handle shutdown
164: 	sigChan := make(chan os.Signal, 1)
165: 	signal.Notify(sigChan, syscall.SIGINT, syscall.SIGTERM)
166: 	<-sigChan
167: 	log.Println("Shutting down...")
168: 	if wsClient != nil {
169: 		wsClient.Close()
170: 	}
171: 	if udpConn != nil {
172: 		udpConn.Close()
173: 	}
174: 	e.Close()
175: }
176: 
177: func connectToRendezvous(workerID, rendezvousURL string) {
178: 	retryCount := 0
179: 	maxRetries := 60 // Try for up to 5 minutes
180: 
181: 	for retryCount < maxRetries {
182: 		log.Printf("Worker %s: Attempting to connect to rendezvous service (attempt %d/%d)...", workerID, retryCount+1, maxRetries)
183: 		wsClient = ws.NewClient(rendezvousURL + "/ws/register/" + workerID)
184: 		setupWebSocketHandlers()
185: 
186: 		if err := wsClient.Connect(); err != nil {
187: 			retryCount++
188: 			log.Printf("Worker %s: Failed to connect to rendezvous service: %v", workerID, err)
189: 			log.Printf("Worker %s: Will retry in 5 seconds... (attempt %d/%d)", workerID, retryCount, maxRetries)
190: 			time.Sleep(5 * time.Second)
191: 			continue
192: 		}
193: 
194: 		log.Printf("Worker %s: Connected to rendezvous service successfully", workerID)
195: 
196: 		// Send initial STUN endpoint if available
197: 		state.Mu.RLock()
198: 		stunIP := state.OurStunDiscoveredUDPIP
199: 		stunPort := state.OurStunDiscoveredUDPPort
200: 		state.Mu.RUnlock()
201: 
202: 		if stunIP != "" && stunPort > 0 {
203: 			log.Printf("Worker %s: Sending initial STUN endpoint %s:%d to rendezvous", workerID, stunIP, stunPort)
204: 			wsClient.SendMessage("update_udp_endpoint", map[string]interface{}{
205: 				"udp_ip":   stunIP,
206: 				"udp_port": stunPort,
207: 			})
208: 		}
209: 
210: 		// Connection established, exit retry loop
211: 		break
212: 	}
213: 
214: 	if retryCount >= maxRetries {
215: 		log.Printf("Worker %s: Failed to connect to rendezvous service after %d attempts. Continuing anyway...", workerID, maxRetries)
216: 	}
217: }
218: 
219: func setupWebSocketHandlers() {
220: 	wsClient.RegisterHandler("p2p_connection_offer", handleP2PConnectionOffer)
221: 	wsClient.RegisterHandler("udp_endpoint_ack", handleUDPEndpointAck)
222: 	wsClient.RegisterHandler("admin_chat_message", handleAdminChatMessage)
223: 	wsClient.RegisterHandler("echo_response", handleEchoResponse)
224: }
225: 
226: func handleP2PConnectionOffer(payload map[string]interface{}) error {
227: 	peerID := payload["peer_worker_id"].(string)
228: 	peerIP := payload["peer_udp_ip"].(string)
229: 	peerPort := int(payload["peer_udp_port"].(float64))
230: 
231: 	log.Printf("Received P2P connection offer from %s at %s:%d", peerID, peerIP, peerPort)
232: 
233: 	peerAddr, err := net.ResolveUDPAddr("udp4", fmt.Sprintf("%s:%d", peerIP, peerPort))
234: 	if err != nil {
235: 		return fmt.Errorf("failed to resolve peer address: %w", err)
236: 	}
237: 	log.Printf("Worker '%s': Resolved peer address for P2P connection to: %s", state.WorkerID, peerAddr.String())
238: 
239: 	state.Mu.Lock()
240: 	state.CurrentP2PPeerID = peerID
241: 	state.CurrentP2PPeerAddr = peerAddr
242: 	state.Mu.Unlock()
243: 
244: 	// Send hole-punching packets
245: 	go func() {
246: 		// Check if UDP is ready
247: 		if udpConn == nil {
248: 			log.Printf("Worker '%s': Received P2P connection offer but UDP not yet initialized", state.WorkerID)
249: 			return
250: 		}
251: 
252: 		log.Printf("Worker '%s': Starting hole-punch sequence to %s (3 pings @ 500ms interval)", state.WorkerID, peerAddr.String())
253: 		numPings := 3
254: 		pingInterval := 500 * time.Millisecond
255: 
256: 		for i := 0; i < numPings; i++ {
257: 			message_content := fmt.Sprintf("P2P_HOLE_PUNCH_PING_FROM_%s_NUM_%d", state.WorkerID, i+1)
258: 			n, err := udpConn.WriteToUDP([]byte(message_content), peerAddr)
259: 			if err != nil {
260: 				log.Printf("Worker '%s': Error sending UDP Hole Punch PING %d: %v", state.WorkerID, i+1, err)
261: 			} else {
262: 				log.Printf("Worker '%s': Sent UDP Hole Punch PING %d to %s (%d bytes)", state.WorkerID, i+1, peerAddr.String(), n)
263: 			}
264: 			if i < numPings-1 { // Don't sleep after the last ping
265: 				time.Sleep(pingInterval)
266: 			}
267: 		}
268: 
269: 		// Start keep-alive and pairing test only if p2pProto is initialized
270: 		if p2pProto != nil {
271: 			p2pProto.StartKeepAlive(peerAddr)
272: 			p2pProto.InitiatePairingTest(peerID, peerAddr)
273: 		} else {
274: 			log.Printf("Worker '%s': P2P protocol not yet initialized, skipping keep-alive and pairing test", state.WorkerID)
275: 		}
276: 	}()
277: 
278: 	// Notify UI
279: 	state.Mu.RLock()
280: 	clients := state.UIWebsocketClients
281: 	state.Mu.RUnlock()
282: 
283: 	uiMsg := map[string]interface{}{
284: 		"type": "p2p_connection_established",
285: 		"payload": map[string]interface{}{
286: 			"peer_id":   peerID,
287: 			"peer_addr": peerAddr.String(),
288: 		},
289: 	}
290: 
291: 	for _, client := range clients {
292: 		client.WriteJSON(uiMsg)
293: 	}
294: 
295: 	return nil
296: }
297: 
298: func handleUDPEndpointAck(payload map[string]interface{}) error {
299: 	log.Println("UDP endpoint acknowledged by rendezvous service")
300: 	return nil
301: }
302: 
303: func handleAdminChatMessage(payload map[string]interface{}) error {
304: 	content := payload["content"].(string)
305: 	adminSessionID := payload["admin_session_id"].(string)
306: 
307: 	log.Printf("Admin chat from %s: %s", adminSessionID, content)
308: 
309: 	// Forward to UI
310: 	state.Mu.RLock()
311: 	clients := state.UIWebsocketClients
312: 	state.Mu.RUnlock()
313: 
314: 	uiMsg := map[string]interface{}{
315: 		"type": "admin_chat_received",
316: 		"payload": map[string]interface{}{
317: 			"admin_session_id": adminSessionID,
318: 			"content":          content,
319: 		},
320: 	}
321: 
322: 	for _, client := range clients {
323: 		client.WriteJSON(uiMsg)
324: 	}
325: 
326: 	// Send auto-reply back to rendezvous
327: 	go func() {
328: 		responsePayload := map[string]interface{}{
329: 			"admin_session_id": adminSessionID,
330: 			"content":          fmt.Sprintf("Worker %s received: %s", state.WorkerID[:8], content),
331: 		}
332: 		if wsClient != nil {
333: 			err := wsClient.SendMessage("chat_response", responsePayload)
334: 			if err != nil {
335: 				log.Printf("Failed to send chat_response to rendezvous: %v", err)
336: 			}
337: 		} else {
338: 			log.Printf("Cannot send chat_response - not connected to rendezvous")
339: 		}
340: 	}()
341: 
342: 	return nil
343: }
344: 
345: func handleEchoResponse(payload map[string]interface{}) error {
346: 	log.Printf("Echo response: %v", payload)
347: 	return nil
348: }
349: 
350: func handleUIWebSocket(c echo.Context) error {
351: 	ws, err := upgrader.Upgrade(c.Response(), c.Request(), nil)
352: 	if err != nil {
353: 		return err
354: 	}
355: 	defer ws.Close()
356: 
357: 	state.Mu.Lock()
358: 	state.UIWebsocketClients = append(state.UIWebsocketClients, ws)
359: 	state.Mu.Unlock()
360: 
361: 	// Send initial state
362: 	ws.WriteJSON(map[string]interface{}{
363: 		"type": "init_info",
364: 		"payload": map[string]interface{}{
365: 			"worker_id":   state.WorkerID,
366: 			"p2p_peer_id": state.CurrentP2PPeerID,
367: 		},
368: 	})
369: 
370: 	// Read messages from UI
371: 	for {
372: 		var msg map[string]interface{}
373: 		if err := ws.ReadJSON(&msg); err != nil {
374: 			break
375: 		}
376: 
377: 		switch msg["type"] {
378: 		case "send_p2p_message":
379: 			payload, ok := msg["payload"].(map[string]interface{})
380: 			if !ok {
381: 				log.Println("Invalid send_p2p_message payload")
382: 				break
383: 			}
384: 			content, ok := payload["content"].(string)
385: 			if !ok {
386: 				log.Println("Invalid content in send_p2p_message")
387: 				break
388: 			}
389: 
390: 			state.Mu.RLock()
391: 			peerAddr := state.CurrentP2PPeerAddr
392: 			state.Mu.RUnlock()
393: 
394: 			if peerAddr == nil {
395: 				log.Println("UI tried to send P2P message, but no peer connected")
396: 				ws.WriteJSON(map[string]interface{}{
397: 					"type":    "error",
398: 					"message": "No P2P connection",
399: 				})
400: 				break
401: 			}
402: 			if p2pProto == nil {
403: 				log.Println("UI tried to send P2P message, but P2P protocol not initialized")
404: 				ws.WriteJSON(map[string]interface{}{
405: 					"type":    "error",
406: 					"message": "P2P protocol not ready",
407: 				})
408: 				break
409: 			}
410: 			err := p2pProto.SendMessage("chat_message", map[string]interface{}{"content": content}, peerAddr)
411: 			if err != nil {
412: 				log.Printf("Error sending P2P message via UI command: %v", err)
413: 				ws.WriteJSON(map[string]interface{}{
414: 					"type":    "error",
415: 					"message": fmt.Sprintf("Failed to send: %v", err),
416: 				})
417: 			}
418: 		case "start_benchmark_send":
419: 			payload, ok := msg["payload"].(map[string]interface{})
420: 			if !ok {
421: 				log.Println("Invalid start_benchmark_send payload")
422: 				break
423: 			}
424: 
425: 			sizeKbFloat, ok := payload["size_kb"].(float64)
426: 			if !ok {
427: 				log.Println("Invalid size_kb in start_benchmark_send")
428: 				break
429: 			}
430: 			sizeKb := int(sizeKbFloat)
431: 
432: 			reqChunkSize := 1024
433: 			reqNumChunks := sizeKb
434: 
435: 			state.Mu.RLock()
436: 			peerAddrBenchmark := state.CurrentP2PPeerAddr
437: 			state.Mu.RUnlock()
438: 
439: 			if peerAddrBenchmark == nil {
440: 				log.Println("UI tried to start benchmark, but no peer connected")
441: 				ws.WriteJSON(map[string]interface{}{
442: 					"type":    "error",
443: 					"message": "No P2P connection",
444: 				})
445: 				break
446: 			}
447: 
448: 			if p2pProto == nil {
449: 				log.Println("UI tried to start benchmark, but P2P protocol not initialized")
450: 				ws.WriteJSON(map[string]interface{}{
451: 					"type":    "error",
452: 					"message": "P2P protocol not ready",
453: 				})
454: 				break
455: 			}
456: 
457: 			sessionID := uuid.New().String()
458: 			go func() {
459: 				data := make([]byte, reqChunkSize)
460: 				for i := 0; i < reqNumChunks; i++ {
461: 					payloadBase64 := base64.StdEncoding.EncodeToString(data)
462: 					p2pProto.SendMessage("benchmark_chunk", map[string]interface{}{
463: 						"session_id":     sessionID,
464: 						"seq":            i,
465: 						"payload":        payloadBase64,
466: 						"from_worker_id": state.WorkerID,
467: 					}, peerAddrBenchmark)
468: 
469: 				}
470: 				p2pProto.SendMessage("benchmark_end", map[string]interface{}{
471: 					"session_id":     sessionID,
472: 					"total_chunks":   reqNumChunks,
473: 					"from_worker_id": state.WorkerID,
474: 				}, peerAddrBenchmark)
475: 			}()
476: 			ws.WriteJSON(map[string]interface{}{
477: 				"type":    "benchmark_status",
478: 				"message": "Benchmark send initiated by UI command",
479: 			})
480: 		default:
481: 			log.Printf("Unknown UI WebSocket message type: %s", msg["type"])
482: 		}
483: 	}
484: 
485: 	// Remove from clients
486: 	state.Mu.Lock()
487: 	for i, client := range state.UIWebsocketClients {
488: 		if client == ws {
489: 			state.UIWebsocketClients = append(
490: 				state.UIWebsocketClients[:i],
491: 				state.UIWebsocketClients[i+1:]...,
492: 			)
493: 			break
494: 		}
495: 	}
496: 	state.Mu.Unlock()
497: 
498: 	return nil
499: }
500: 
501: func getEnvInt(key string, defaultValue int) int {
502: 	if v := os.Getenv(key); v != "" {
503: 		if i, err := strconv.Atoi(v); err == nil {
504: 			return i
505: 		}
506: 	}
507: 	return defaultValue
508: }
509: 
510: func getEnvStr(key, defaultValue string) string {
511: 	if v := os.Getenv(key); v != "" {
512: 		return strings.TrimSpace(v)
513: 	}
514: 	return defaultValue
515: }
</file>

<file path="holepunch-go/deployments/Dockerfile.rendezvous">
 1: FROM golang:1.24.3-alpine AS builder
 2: 
 3: WORKDIR /app
 4: 
 5: RUN apk update && apk upgrade --no-cache && apk add --no-cache git
 6: 
 7: COPY go.mod go.sum ./
 8: RUN --mount=type=cache,id=gomod,target=/go/pkg/mod go mod download
 9: 
10: COPY . .
11: 
12: RUN --mount=type=cache,id=gobuild,target=/root/.cache/go-build,sharing=locked \
13:     --mount=type=cache,id=gomod,target=/go/pkg/mod,sharing=locked \
14:     CGO_ENABLED=0 GOOS=linux \
15:     go build -buildvcs=false -trimpath -ldflags="-s -w" \
16:     -o /app/rendezvous ./cmd/rendezvous
17: 
18: FROM gcr.io/distroless/static-debian12@sha256:d9f9472a8f4541368192d714a995eb1a99bab1f7071fc8bde261d7eda3b667d8
19: 
20: WORKDIR /app/
21: 
22: COPY --from=builder /app/rendezvous .
23: COPY --from=builder /app/web/rendezvous ./web/rendezvous
24: 
25: EXPOSE 8080
26: 
27: CMD ["./rendezvous"]
</file>

<file path="holepunch-go/deployments/Dockerfile.worker">
 1: # syntax=docker/dockerfile:1.7
 2: FROM golang:1.24.3-alpine AS builder
 3: 
 4: WORKDIR /app
 5: 
 6: RUN apk update && apk upgrade --no-cache && apk add --no-cache git
 7: 
 8: COPY go.mod go.sum ./
 9: RUN --mount=type=cache,target=/root/go/pkg/mod go mod download
10: 
11: COPY . .
12: 
13: RUN --mount=type=cache,id=gobuild,target=/root/.cache/go-build,sharing=locked \
14:     --mount=type=cache,id=gomod,target=/go/pkg/mod,sharing=locked \
15:     CGO_ENABLED=0 GOOS=linux \
16:     go build -buildvcs=false -trimpath -ldflags="-s -w" \
17:     -o /app/worker ./cmd/worker
18: 
19: FROM gcr.io/distroless/static-debian12@sha256:d9f9472a8f4541368192d714a995eb1a99bab1f7071fc8bde261d7eda3b667d8
20: 
21: WORKDIR /app/
22: 
23: COPY --from=builder /app/worker .
24: COPY --from=builder /app/web/worker ./web/worker
25: 
26: EXPOSE 8080 8081/udp
27: 
28: CMD ["./worker"]
</file>

<file path="holepunch-go/pkg/models/models.go">
 1: package models
 2: 
 3: import (
 4: 	"net"
 5: 	"sync"
 6: 	"time"
 7: 
 8: 	"github.com/gorilla/websocket"
 9: )
10: 
11: type WorkerInfo struct {
12: 	ID                    string          `json:"id"`
13: 	WebsocketObservedIP   string          `json:"websocket_observed_ip"`
14: 	WebsocketObservedPort int             `json:"websocket_observed_port"`
15: 	StunReportedUDPIP     string          `json:"stun_reported_udp_ip,omitempty"`
16: 	StunReportedUDPPort   int             `json:"stun_reported_udp_port,omitempty"`
17: 	HTTPReportedPublicIP  string          `json:"http_reported_public_ip,omitempty"`
18: 	ConnectedAt           time.Time       `json:"connected_at"`
19: 	LastPingAt            time.Time       `json:"last_ping_at"`
20: 	Websocket             *websocket.Conn `json:"-"`
21: }
22: 
23: type ServiceState struct {
24: 	ConnectedWorkers       map[string]*WorkerInfo
25: 	WorkersReadyForPairing []string
26: 	AdminWebsocketClients  []*websocket.Conn
27: 	ChatSessions           map[string]map[string]*websocket.Conn
28: 	Mu                     sync.RWMutex
29: }
30: 
31: func NewServiceState() *ServiceState {
32: 	return &ServiceState{
33: 		ConnectedWorkers:       make(map[string]*WorkerInfo),
34: 		WorkersReadyForPairing: make([]string, 0),
35: 		AdminWebsocketClients:  make([]*websocket.Conn, 0),
36: 		ChatSessions:           make(map[string]map[string]*websocket.Conn),
37: 	}
38: }
39: 
40: type WebSocketMessage struct {
41: 	Type    string                 `json:"type"`
42: 	Payload map[string]interface{} `json:"payload,omitempty"`
43: }
44: 
45: type P2PMessage struct {
46: 	Type         string                 `json:"type"`
47: 	FromWorkerID string                 `json:"from_worker_id"`
48: 	Payload      map[string]interface{} `json:"payload,omitempty"`
49: 	Timestamp    time.Time              `json:"timestamp"`
50: }
51: 
52: type WorkerState struct {
53: 	WorkerID                 string
54: 	OurStunDiscoveredUDPIP   string
55: 	OurStunDiscoveredUDPPort int
56: 	CurrentP2PPeerID         string
57: 	CurrentP2PPeerAddr       *net.UDPAddr
58: 	UIWebsocketClients       []*websocket.Conn
59: 	BenchmarkSessions        map[string]*BenchmarkSession
60: 	LastP2PMessageTime       time.Time
61: 	P2PKeepAliveTask         chan struct{}
62: 	Mu                       sync.RWMutex
63: }
64: 
65: type BenchmarkSession struct {
66: 	StartTime      time.Time
67: 	BytesReceived  int64
68: 	ChunksReceived int
69: 	Active         bool
70: }
71: 
72: func NewWorkerState(workerID string) *WorkerState {
73: 	return &WorkerState{
74: 		WorkerID:           workerID,
75: 		UIWebsocketClients: make([]*websocket.Conn, 0),
76: 		BenchmarkSessions:  make(map[string]*BenchmarkSession),
77: 	}
78: }
</file>

<file path="holepunch-go/pkg/websocket/client.go">
  1: package websocket
  2: 
  3: import (
  4: 	"fmt"
  5: 	"log"
  6: 	"net/http"
  7: 	"net/url"
  8: 	"strings"
  9: 	"sync"
 10: 	"time"
 11: 
 12: 	"github.com/gorilla/websocket"
 13: )
 14: 
 15: type Client struct {
 16: 	conn            *websocket.Conn
 17: 	url             string
 18: 	messageHandlers map[string]MessageHandler
 19: 	mu              sync.RWMutex
 20: 	pingInterval    time.Duration
 21: 	pingTimeout     time.Duration
 22: 	done            chan struct{}
 23: 	closeOnce       sync.Once
 24: }
 25: 
 26: type MessageHandler func(payload map[string]interface{}) error
 27: 
 28: type Message struct {
 29: 	Type    string                 `json:"type"`
 30: 	Payload map[string]interface{} `json:"payload,omitempty"`
 31: }
 32: 
 33: func NewClient(serverURL string) *Client {
 34: 	return &Client{
 35: 		url:             serverURL,
 36: 		messageHandlers: make(map[string]MessageHandler),
 37: 		pingInterval:    30 * time.Second,
 38: 		pingTimeout:     60 * time.Second,
 39: 		done:            make(chan struct{}),
 40: 	}
 41: }
 42: 
 43: func (c *Client) RegisterHandler(msgType string, handler MessageHandler) {
 44: 	c.mu.Lock()
 45: 	defer c.mu.Unlock()
 46: 	c.messageHandlers[msgType] = handler
 47: }
 48: 
 49: func (c *Client) Connect() error {
 50: 	log.Printf("WebSocket client attempting to connect to (raw input URL): %s", c.url)
 51: 
 52: 	u, err := url.Parse(c.url)
 53: 	if err != nil {
 54: 		return fmt.Errorf("invalid URL structure for '%s': %w", c.url, err)
 55: 	}
 56: 
 57: 	// Trim potential whitespace around the host.
 58: 	// url.Parse("http:// host.com /path") correctly sets u.Scheme and u.Path,
 59: 	// but u.Host becomes " host.com ". This can make it a malformed URL for the websocket dialer.
 60: 	if u.Host != "" { // Only trim if host was initially parsed
 61: 		u.Host = strings.TrimSpace(u.Host)
 62: 		if u.Host == "" {
 63: 			// If trimming an existing host string made it empty (e.g., c.url was "http:// /path")
 64: 			return fmt.Errorf("host part of URL '%s' became empty after trimming whitespace", c.url)
 65: 		}
 66: 	} else {
 67: 		// Host was empty after initial parsing.
 68: 		// This is an issue if a scheme is present (e.g. "http:///path")
 69: 		// or if no scheme and no host means it's just a path.
 70: 		// If scheme is empty AND host is empty, it might be a relative path, which is not valid for Dial.
 71: 		if u.Scheme != "" {
 72: 			return fmt.Errorf("URL '%s' has a scheme ('%s') but no host component", c.url, u.Scheme)
 73: 		}
 74: 		// If scheme is also empty, url.Parse might have put everything in Path.
 75: 		// Example: "myhost.com/ws/register" -> Scheme="", Host="", Path="myhost.com/ws/register"
 76: 		// This situation will be caught by the "unsupported scheme" error later if not handled,
 77: 		// or it means the URL is fundamentally not an absolute URL suitable for dialing.
 78: 		// For now, we rely on the scheme check below. A schemeless, hostless URL won't form a valid ws:// URL.
 79: 	}
 80: 
 81: 	// Convert http/https to ws/wss
 82: 	originalScheme := u.Scheme // For logging/error messages
 83: 	switch u.Scheme {
 84: 	case "http":
 85: 		u.Scheme = "ws"
 86: 	case "https":
 87: 		u.Scheme = "wss"
 88: 	case "ws", "wss":
 89: 		// Already correct
 90: 	default:
 91: 		// This typically means no scheme was provided (e.g. "myhost.com/path")
 92: 		// or an actual unsupported scheme.
 93: 		return fmt.Errorf("unsupported or missing scheme ('%s') in URL '%s'. A scheme like http, https, ws, or wss is required.", originalScheme, c.url)
 94: 	}
 95: 
 96: 	finalURLString := u.String()
 97: 	// After scheme conversion and host trimming, re-check host, as u.String() might behave unexpectedly if host is truly empty.
 98: 	// For example, if u was originally http:///foo -> ws:///foo. u.Host is still empty.
 99: 	if u.Host == "" {
100: 		return fmt.Errorf("URL '%s' resulted in an empty host for the final WebSocket URL '%s'", c.url, finalURLString)
101: 	}
102: 
103: 	log.Printf("WebSocket client connecting to (processed URL): %s", finalURLString)
104: 
105: 	header := http.Header{}
106: 	header.Add("User-Agent", "HolePunch-Worker/1.0")
107: 
108: 	dialer := websocket.Dialer{
109: 		HandshakeTimeout: 10 * time.Second,
110: 		Proxy:            nil,
111: 		NetDialContext:   nil,
112: 	}
113: 
114: 	conn, _, err := dialer.Dial(u.String(), header)
115: 	if err != nil {
116: 		return fmt.Errorf("failed to connect: %w", err)
117: 	}
118: 
119: 	c.conn = conn
120: 	c.conn.SetReadDeadline(time.Now().Add(c.pingTimeout))
121: 	c.conn.SetPongHandler(func(string) error {
122: 		c.conn.SetReadDeadline(time.Now().Add(c.pingTimeout))
123: 		return nil
124: 	})
125: 
126: 	go c.readLoop()
127: 	go c.pingLoop()
128: 
129: 	return nil
130: }
131: 
132: func (c *Client) Close() error {
133: 	var err error
134: 	c.closeOnce.Do(func() {
135: 		close(c.done)
136: 		if c.conn != nil {
137: 			err = c.conn.Close()
138: 		}
139: 	})
140: 	return err
141: }
142: 
143: func (c *Client) SendMessage(msgType string, payload map[string]interface{}) error {
144: 	msg := Message{
145: 		Type:    msgType,
146: 		Payload: payload,
147: 	}
148: 
149: 	c.mu.Lock()
150: 	defer c.mu.Unlock()
151: 
152: 	if c.conn == nil {
153: 		return fmt.Errorf("not connected")
154: 	}
155: 
156: 	return c.conn.WriteJSON(msg)
157: }
158: 
159: func (c *Client) readLoop() {
160: 	defer c.Close()
161: 
162: 	for {
163: 		var msg Message
164: 		if err := c.conn.ReadJSON(&msg); err != nil {
165: 			if websocket.IsUnexpectedCloseError(err, websocket.CloseGoingAway, websocket.CloseAbnormalClosure) {
166: 				log.Printf("WebSocket read error: %v", err)
167: 			}
168: 			return
169: 		}
170: 
171: 		c.mu.RLock()
172: 		handler, ok := c.messageHandlers[msg.Type]
173: 		c.mu.RUnlock()
174: 
175: 		if ok {
176: 			if err := handler(msg.Payload); err != nil {
177: 				log.Printf("Error handling %s message: %v", msg.Type, err)
178: 			}
179: 		} else {
180: 			log.Printf("No handler for message type: %s", msg.Type)
181: 		}
182: 	}
183: }
184: 
185: func (c *Client) pingLoop() {
186: 	ticker := time.NewTicker(c.pingInterval)
187: 	defer ticker.Stop()
188: 
189: 	for {
190: 		select {
191: 		case <-ticker.C:
192: 			c.mu.Lock()
193: 			if c.conn == nil {
194: 				c.mu.Unlock()
195: 				return
196: 			}
197: 			c.conn.SetWriteDeadline(time.Now().Add(10 * time.Second))
198: 			if err := c.conn.WriteMessage(websocket.PingMessage, nil); err != nil {
199: 				c.mu.Unlock()
200: 				log.Printf("Ping failed: %v", err)
201: 				c.Close()
202: 				return
203: 			}
204: 			c.mu.Unlock()
205: 		case <-c.done:
206: 			return
207: 		}
208: 	}
209: }
</file>

<file path="holepunch-go/web/rendezvous/admin/admin-chat.html">
  1: <!DOCTYPE html>
  2: <html lang="en">
  3: <head>
  4:     <meta charset="UTF-8">
  5:     <meta name="viewport" content="width=device-width, initial-scale=1.0">
  6:     <title>Rendezvous Admin Chat</title>
  7:     <style>
  8:         * {
  9:             margin: 0;
 10:             padding: 0;
 11:             box-sizing: border-box;
 12:         }
 13:         
 14:         body {
 15:             font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, sans-serif;
 16:             background-color: #f5f5f5;
 17:             color: #333;
 18:             line-height: 1.6;
 19:             height: 100vh;
 20:             overflow: hidden;
 21:         }
 22:         
 23:         .main-container {
 24:             display: flex;
 25:             height: 100vh;
 26:         }
 27:         
 28:         .sidebar {
 29:             width: 300px;
 30:             background-color: #2c3e50;
 31:             color: white;
 32:             overflow-y: auto;
 33:             flex-shrink: 0;
 34:         }
 35:         
 36:         .sidebar h2 {
 37:             padding: 1rem;
 38:             background-color: #1a252f;
 39:             font-size: 1.2rem;
 40:             position: sticky;
 41:             top: 0;
 42:             z-index: 10;
 43:         }
 44:         
 45:         .worker-list {
 46:             padding: 0.5rem;
 47:         }
 48:         
 49:         .worker-item {
 50:             padding: 0.75rem;
 51:             margin-bottom: 0.5rem;
 52:             background-color: #34495e;
 53:             border-radius: 4px;
 54:             cursor: pointer;
 55:             transition: background-color 0.2s;
 56:             display: flex;
 57:             justify-content: space-between;
 58:             align-items: center;
 59:         }
 60:         
 61:         .worker-item:hover {
 62:             background-color: #4a5f7a;
 63:         }
 64:         
 65:         .worker-item.active {
 66:             background-color: #3498db;
 67:         }
 68:         
 69:         .worker-item.disconnected {
 70:             opacity: 0.5;
 71:             cursor: not-allowed;
 72:         }
 73:         
 74:         .worker-id {
 75:             font-family: 'Courier New', monospace;
 76:             font-size: 0.875rem;
 77:             overflow: hidden;
 78:             text-overflow: ellipsis;
 79:             white-space: nowrap;
 80:             flex: 1;
 81:         }
 82:         
 83:         .worker-status {
 84:             width: 8px;
 85:             height: 8px;
 86:             border-radius: 50%;
 87:             flex-shrink: 0;
 88:             margin-left: 0.5rem;
 89:         }
 90:         
 91:         .worker-status.connected {
 92:             background-color: #2ecc71;
 93:         }
 94:         
 95:         .worker-status.disconnected {
 96:             background-color: #e74c3c;
 97:         }
 98:         
 99:         .chat-container {
100:             flex: 1;
101:             display: flex;
102:             flex-direction: column;
103:             background-color: white;
104:         }
105:         
106:         .chat-header {
107:             padding: 1rem;
108:             background-color: #ecf0f1;
109:             border-bottom: 1px solid #bdc3c7;
110:             display: flex;
111:             justify-content: space-between;
112:             align-items: center;
113:         }
114:         
115:         .chat-header h3 {
116:             color: #2c3e50;
117:             font-size: 1.1rem;
118:         }
119:         
120:         .connection-status {
121:             padding: 0.25rem 0.75rem;
122:             border-radius: 9999px;
123:             font-size: 0.75rem;
124:             font-weight: 600;
125:         }
126:         
127:         .connection-status.connected {
128:             background-color: #d4edda;
129:             color: #155724;
130:         }
131:         
132:         .connection-status.disconnected {
133:             background-color: #f8d7da;
134:             color: #721c24;
135:         }
136:         
137:         .chat-messages {
138:             flex: 1;
139:             overflow-y: auto;
140:             padding: 1rem;
141:             background-color: #fafafa;
142:         }
143:         
144:         .message {
145:             margin-bottom: 1rem;
146:             display: flex;
147:             align-items: flex-start;
148:         }
149:         
150:         .message.admin {
151:             justify-content: flex-end;
152:         }
153:         
154:         .message.worker {
155:             justify-content: flex-start;
156:         }
157:         
158:         .message-bubble {
159:             max-width: 70%;
160:             padding: 0.75rem 1rem;
161:             border-radius: 8px;
162:             word-wrap: break-word;
163:         }
164:         
165:         .message.admin .message-bubble {
166:             background-color: #3498db;
167:             color: white;
168:             border-bottom-right-radius: 2px;
169:         }
170:         
171:         .message.worker .message-bubble {
172:             background-color: #ecf0f1;
173:             color: #2c3e50;
174:             border-bottom-left-radius: 2px;
175:         }
176:         
177:         .message-time {
178:             font-size: 0.75rem;
179:             color: #7f8c8d;
180:             margin-top: 0.25rem;
181:         }
182:         
183:         .message.admin .message-time {
184:             text-align: right;
185:         }
186:         
187:         .chat-input-container {
188:             padding: 1rem;
189:             border-top: 1px solid #bdc3c7;
190:             background-color: white;
191:         }
192:         
193:         .chat-input-form {
194:             display: flex;
195:             gap: 0.5rem;
196:         }
197:         
198:         .chat-input {
199:             flex: 1;
200:             padding: 0.75rem;
201:             border: 1px solid #bdc3c7;
202:             border-radius: 4px;
203:             font-size: 1rem;
204:             outline: none;
205:             transition: border-color 0.2s;
206:         }
207:         
208:         .chat-input:focus {
209:             border-color: #3498db;
210:         }
211:         
212:         .send-btn {
213:             padding: 0.75rem 1.5rem;
214:             background-color: #3498db;
215:             color: white;
216:             border: none;
217:             border-radius: 4px;
218:             cursor: pointer;
219:             font-size: 1rem;
220:             transition: background-color 0.2s;
221:         }
222:         
223:         .send-btn:hover:not(:disabled) {
224:             background-color: #2980b9;
225:         }
226:         
227:         .send-btn:disabled {
228:             background-color: #bdc3c7;
229:             cursor: not-allowed;
230:         }
231:         
232:         .no-selection {
233:             flex: 1;
234:             display: flex;
235:             align-items: center;
236:             justify-content: center;
237:             color: #7f8c8d;
238:             font-size: 1.2rem;
239:         }
240:         
241:         .error-toast {
242:             position: fixed;
243:             bottom: 2rem;
244:             right: 2rem;
245:             background-color: #e74c3c;
246:             color: white;
247:             padding: 1rem 1.5rem;
248:             border-radius: 4px;
249:             box-shadow: 0 4px 6px rgba(0,0,0,0.1);
250:             display: none;
251:             animation: slideIn 0.3s ease-out;
252:         }
253:         
254:         @keyframes slideIn {
255:             from {
256:                 transform: translateX(100%);
257:             }
258:             to {
259:                 transform: translateX(0);
260:             }
261:         }
262:         
263:         .back-link {
264:             position: fixed;
265:             top: 1rem;
266:             right: 1rem;
267:             background-color: #34495e;
268:             color: white;
269:             padding: 0.5rem 1rem;
270:             border-radius: 4px;
271:             text-decoration: none;
272:             font-size: 0.875rem;
273:             transition: background-color 0.2s;
274:         }
275:         
276:         .back-link:hover {
277:             background-color: #2c3e50;
278:         }
279:     </style>
280: </head>
281: <body>
282:     <a href="/admin" class="back-link">← Back to Admin Dashboard</a>
283:     
284:     <div class="main-container">
285:         <div class="sidebar">
286:             <h2>Available Workers</h2>
287:             <div class="worker-list" id="workerList">
288:                 <!-- Workers will be populated here -->
289:             </div>
290:         </div>
291:         
292:         <div class="chat-container" id="chatContainer">
293:             <div class="no-selection">
294:                 Select a worker to start chatting
295:             </div>
296:         </div>
297:     </div>
298:     
299:     <div class="error-toast" id="errorToast"></div>
300:     
301:     <script>
302:         let selectedWorkerId = null;
303:         let chatWs = null;
304:         let adminSessionId = generateSessionId();
305:         let workers = {};
306:         let messageHistory = {}; // Store messages per worker
307:         
308:         function generateSessionId() {
309:             return 'admin-' + Date.now() + '-' + Math.random().toString(36).substr(2, 9);
310:         }
311:         
312:         async function fetchWorkers() {
313:             try {
314:                 const response = await fetch('/api/workers');
315:                 const data = await response.json();
316:                 workers = {};
317:                 data.forEach(worker => {
318:                     workers[worker.id] = worker;
319:                 });
320:                 updateWorkerList(data);
321:             } catch (error) {
322:                 console.error('Error fetching workers:', error);
323:                 showError('Failed to fetch workers');
324:             }
325:         }
326:         
327:         function updateWorkerList(workersList) {
328:             const workerListEl = document.getElementById('workerList');
329:             workerListEl.innerHTML = '';
330:             
331:             workersList.forEach(worker => {
332:                 const workerEl = document.createElement('div');
333:                 const isConnected = worker.stun_reported_udp_ip ? true : false;
334:                 workerEl.className = `worker-item ${isConnected ? '' : 'disconnected'} ${worker.id === selectedWorkerId ? 'active' : ''}`;
335:                 workerEl.innerHTML = `
336:                     <span class="worker-id">${worker.id}</span>
337:                     <span class="worker-status ${isConnected ? 'connected' : 'disconnected'}"></span>
338:                 `;
339:                 
340:                 if (isConnected) {
341:                     workerEl.onclick = () => selectWorker(worker.id);
342:                 }
343:                 
344:                 workerListEl.appendChild(workerEl);
345:             });
346:         }
347:         
348:         function selectWorker(workerId) {
349:             if (selectedWorkerId === workerId) return;
350:             
351:             // Close existing chat connection
352:             if (chatWs) {
353:                 chatWs.close();
354:                 chatWs = null;
355:             }
356:             
357:             selectedWorkerId = workerId;
358:             
359:             // Update UI
360:             document.querySelectorAll('.worker-item').forEach(el => {
361:                 el.classList.remove('active');
362:             });
363:             event.target.closest('.worker-item').classList.add('active');
364:             
365:             // Show chat interface
366:             showChatInterface(workerId);
367:             
368:             // Connect to chat WebSocket
369:             connectToChat(workerId);
370:         }
371:         
372:         function showChatInterface(workerId) {
373:             const chatContainer = document.getElementById('chatContainer');
374:             chatContainer.innerHTML = `
375:                 <div class="chat-header">
376:                     <h3>Chat with Worker: ${workerId.substring(0, 8)}...</h3>
377:                     <span class="connection-status disconnected" id="chatStatus">Connecting...</span>
378:                 </div>
379:                 <div class="chat-messages" id="chatMessages">
380:                     <!-- Messages will appear here -->
381:                 </div>
382:                 <div class="chat-input-container">
383:                     <form class="chat-input-form" onsubmit="sendMessage(event)">
384:                         <input type="text" class="chat-input" id="chatInput" placeholder="Type a message..." disabled>
385:                         <button type="submit" class="send-btn" id="sendBtn" disabled>Send</button>
386:                     </form>
387:                 </div>
388:             `;
389:             
390:             // Load message history if available
391:             if (messageHistory[workerId]) {
392:                 const messagesEl = document.getElementById('chatMessages');
393:                 messageHistory[workerId].forEach(msg => {
394:                     addMessageToUI(msg.from, msg.content, msg.timestamp);
395:                 });
396:                 messagesEl.scrollTop = messagesEl.scrollHeight;
397:             }
398:         }
399:         
400:         function connectToChat(workerId) {
401:             const protocol = window.location.protocol === 'https:' ? 'wss:' : 'ws:';
402:             const wsUrl = `${protocol}//${window.location.host}/ws/chat/${adminSessionId}/${workerId}`;
403:             
404:             chatWs = new WebSocket(wsUrl);
405:             
406:             chatWs.onopen = () => {
407:                 console.log('Chat WebSocket connected');
408:                 updateChatStatus(true);
409:                 document.getElementById('chatInput').disabled = false;
410:                 document.getElementById('sendBtn').disabled = false;
411:             };
412:             
413:             chatWs.onclose = () => {
414:                 console.log('Chat WebSocket disconnected');
415:                 updateChatStatus(false);
416:                 document.getElementById('chatInput').disabled = true;
417:                 document.getElementById('sendBtn').disabled = true;
418:             };
419:             
420:             chatWs.onerror = (error) => {
421:                 console.error('Chat WebSocket error:', error);
422:                 showError('Chat connection error');
423:             };
424:             
425:             chatWs.onmessage = (event) => {
426:                 try {
427:                     const data = JSON.parse(event.data);
428:                     handleChatMessage(data);
429:                 } catch (error) {
430:                     console.error('Error parsing chat message:', error);
431:                 }
432:             };
433:         }
434:         
435:         function handleChatMessage(data) {
436:             switch (data.type) {
437:                 case 'chat_message':
438:                     if (data.from === 'worker') {
439:                         addMessageToUI('worker', data.payload.content, new Date());
440:                         // Store in history
441:                         if (!messageHistory[selectedWorkerId]) {
442:                             messageHistory[selectedWorkerId] = [];
443:                         }
444:                         messageHistory[selectedWorkerId].push({
445:                             from: 'worker',
446:                             content: data.payload.content,
447:                             timestamp: new Date()
448:                         });
449:                     }
450:                     break;
451:                 case 'error':
452:                     showError(data.message);
453:                     break;
454:             }
455:         }
456:         
457:         function addMessageToUI(from, content, timestamp) {
458:             const messagesEl = document.getElementById('chatMessages');
459:             if (!messagesEl) return;
460:             
461:             const messageEl = document.createElement('div');
462:             messageEl.className = `message ${from}`;
463:             
464:             const time = timestamp instanceof Date ? timestamp.toLocaleTimeString() : new Date().toLocaleTimeString();
465:             
466:             messageEl.innerHTML = `
467:                 <div class="message-content">
468:                     <div class="message-bubble">${escapeHtml(content)}</div>
469:                     <div class="message-time">${time}</div>
470:                 </div>
471:             `;
472:             
473:             messagesEl.appendChild(messageEl);
474:             messagesEl.scrollTop = messagesEl.scrollHeight;
475:         }
476:         
477:         function sendMessage(event) {
478:             event.preventDefault();
479:             
480:             const input = document.getElementById('chatInput');
481:             const message = input.value.trim();
482:             
483:             if (!message || !chatWs || chatWs.readyState !== WebSocket.OPEN) return;
484:             
485:             chatWs.send(JSON.stringify({
486:                 type: 'chat_message',
487:                 content: message
488:             }));
489:             
490:             // Add to UI
491:             addMessageToUI('admin', message, new Date());
492:             
493:             // Store in history
494:             if (!messageHistory[selectedWorkerId]) {
495:                 messageHistory[selectedWorkerId] = [];
496:             }
497:             messageHistory[selectedWorkerId].push({
498:                 from: 'admin',
499:                 content: message,
500:                 timestamp: new Date()
501:             });
502:             
503:             input.value = '';
504:         }
505:         
506:         function updateChatStatus(connected) {
507:             const statusEl = document.getElementById('chatStatus');
508:             if (statusEl) {
509:                 statusEl.textContent = connected ? 'Connected' : 'Disconnected';
510:                 statusEl.className = `connection-status ${connected ? 'connected' : 'disconnected'}`;
511:             }
512:         }
513:         
514:         function showError(message) {
515:             const errorToast = document.getElementById('errorToast');
516:             errorToast.textContent = message;
517:             errorToast.style.display = 'block';
518:             
519:             setTimeout(() => {
520:                 errorToast.style.display = 'none';
521:             }, 3000);
522:         }
523:         
524:         function escapeHtml(text) {
525:             const div = document.createElement('div');
526:             div.textContent = text;
527:             return div.innerHTML;
528:         }
529:         
530:         // Initialize
531:         fetchWorkers();
532:         
533:         // Refresh worker list periodically
534:         setInterval(fetchWorkers, 5000);
535:     </script>
536: </body>
537: </html>
</file>

<file path="holepunch-go/web/rendezvous/admin/admin.html">
  1: <!DOCTYPE html>
  2: <html lang="en">
  3: <head>
  4:     <meta charset="UTF-8">
  5:     <meta name="viewport" content="width=device-width, initial-scale=1.0">
  6:     <title>Rendezvous Admin - Worker Management</title>
  7:     <style>
  8:         * {
  9:             margin: 0;
 10:             padding: 0;
 11:             box-sizing: border-box;
 12:         }
 13:         
 14:         body {
 15:             font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, sans-serif;
 16:             background-color: #f5f5f5;
 17:             color: #333;
 18:             line-height: 1.6;
 19:         }
 20:         
 21:         .container {
 22:             max-width: 1200px;
 23:             margin: 0 auto;
 24:             padding: 20px;
 25:         }
 26:         
 27:         header {
 28:             background-color: #2c3e50;
 29:             color: white;
 30:             padding: 1rem 0;
 31:             margin-bottom: 2rem;
 32:             box-shadow: 0 2px 4px rgba(0,0,0,0.1);
 33:         }
 34:         
 35:         header h1 {
 36:             text-align: center;
 37:             font-size: 2rem;
 38:         }
 39:         
 40:         .connection-status {
 41:             position: fixed;
 42:             top: 10px;
 43:             right: 10px;
 44:             padding: 0.5rem 1rem;
 45:             border-radius: 4px;
 46:             font-size: 0.875rem;
 47:             font-weight: 600;
 48:             z-index: 1000;
 49:         }
 50:         
 51:         .connection-status.connected {
 52:             background-color: #d4edda;
 53:             color: #155724;
 54:         }
 55:         
 56:         .connection-status.disconnected {
 57:             background-color: #f8d7da;
 58:             color: #721c24;
 59:         }
 60:         
 61:         .stats {
 62:             display: grid;
 63:             grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
 64:             gap: 1rem;
 65:             margin-bottom: 2rem;
 66:         }
 67:         
 68:         .stat-card {
 69:             background: white;
 70:             padding: 1.5rem;
 71:             border-radius: 8px;
 72:             box-shadow: 0 2px 4px rgba(0,0,0,0.1);
 73:             text-align: center;
 74:         }
 75:         
 76:         .stat-card h3 {
 77:             color: #7f8c8d;
 78:             font-size: 0.875rem;
 79:             text-transform: uppercase;
 80:             margin-bottom: 0.5rem;
 81:         }
 82:         
 83:         .stat-card .value {
 84:             font-size: 2rem;
 85:             font-weight: bold;
 86:             color: #2c3e50;
 87:         }
 88:         
 89:         .connection-panel {
 90:             background: white;
 91:             padding: 1.5rem;
 92:             border-radius: 8px;
 93:             box-shadow: 0 2px 4px rgba(0,0,0,0.1);
 94:             margin-bottom: 2rem;
 95:         }
 96:         
 97:         .connection-panel h3 {
 98:             margin-bottom: 1rem;
 99:             color: #2c3e50;
100:         }
101:         
102:         .selected-workers {
103:             display: flex;
104:             gap: 1rem;
105:             margin-bottom: 1rem;
106:             flex-wrap: wrap;
107:         }
108:         
109:         .selected-worker {
110:             background-color: #e3f2fd;
111:             padding: 0.5rem 1rem;
112:             border-radius: 4px;
113:             font-size: 0.875rem;
114:             display: flex;
115:             align-items: center;
116:             gap: 0.5rem;
117:         }
118:         
119:         .selected-worker .remove {
120:             cursor: pointer;
121:             color: #1565c0;
122:             font-weight: bold;
123:         }
124:         
125:         .connect-btn {
126:             background-color: #27ae60;
127:             color: white;
128:             border: none;
129:             padding: 0.75rem 1.5rem;
130:             border-radius: 4px;
131:             cursor: pointer;
132:             font-size: 1rem;
133:             transition: background-color 0.2s;
134:             margin-right: 1rem;
135:         }
136:         
137:         .connect-btn:hover:not(:disabled) {
138:             background-color: #229954;
139:         }
140:         
141:         .connect-btn:disabled {
142:             background-color: #bdc3c7;
143:             cursor: not-allowed;
144:         }
145:         
146:         .clear-btn {
147:             background-color: #e74c3c;
148:             color: white;
149:             border: none;
150:             padding: 0.75rem 1.5rem;
151:             border-radius: 4px;
152:             cursor: pointer;
153:             font-size: 1rem;
154:             transition: background-color 0.2s;
155:         }
156:         
157:         .clear-btn:hover {
158:             background-color: #c0392b;
159:         }
160:         
161:         .workers-grid {
162:             display: grid;
163:             grid-template-columns: repeat(auto-fill, minmax(350px, 1fr));
164:             gap: 1rem;
165:             margin-bottom: 2rem;
166:         }
167:         
168:         .worker-card {
169:             background: white;
170:             border-radius: 8px;
171:             padding: 1.5rem;
172:             box-shadow: 0 2px 4px rgba(0,0,0,0.1);
173:             transition: transform 0.2s, box-shadow 0.2s;
174:             cursor: pointer;
175:             position: relative;
176:         }
177:         
178:         .worker-card:hover {
179:             transform: translateY(-2px);
180:             box-shadow: 0 4px 8px rgba(0,0,0,0.15);
181:         }
182:         
183:         .worker-card.selected {
184:             border: 2px solid #3498db;
185:             background-color: #ebf5fb;
186:         }
187:         
188:         .worker-header {
189:             display: flex;
190:             justify-content: space-between;
191:             align-items: center;
192:             margin-bottom: 1rem;
193:         }
194:         
195:         .worker-id {
196:             font-family: 'Courier New', monospace;
197:             font-size: 0.875rem;
198:             color: #34495e;
199:             word-break: break-all;
200:         }
201:         
202:         .status-badge {
203:             display: inline-block;
204:             padding: 0.25rem 0.75rem;
205:             border-radius: 9999px;
206:             font-size: 0.75rem;
207:             font-weight: 600;
208:             text-transform: uppercase;
209:         }
210:         
211:         .status-connected {
212:             background-color: #d4edda;
213:             color: #155724;
214:         }
215:         
216:         .status-disconnected {
217:             background-color: #f8d7da;
218:             color: #721c24;
219:         }
220:         
221:         .worker-details {
222:             display: grid;
223:             gap: 0.5rem;
224:             font-size: 0.875rem;
225:         }
226:         
227:         .detail-row {
228:             display: flex;
229:             justify-content: space-between;
230:             padding: 0.25rem 0;
231:             border-bottom: 1px solid #eee;
232:         }
233:         
234:         .detail-label {
235:             color: #7f8c8d;
236:         }
237:         
238:         .detail-value {
239:             font-family: 'Courier New', monospace;
240:             color: #2c3e50;
241:             text-align: right;
242:         }
243:         
244:         .refresh-btn {
245:             background-color: #3498db;
246:             color: white;
247:             border: none;
248:             padding: 0.75rem 1.5rem;
249:             border-radius: 4px;
250:             cursor: pointer;
251:             font-size: 1rem;
252:             transition: background-color 0.2s;
253:         }
254:         
255:         .refresh-btn:hover {
256:             background-color: #2980b9;
257:         }
258:         
259:         .refresh-btn:disabled {
260:             background-color: #bdc3c7;
261:             cursor: not-allowed;
262:         }
263:         
264:         .controls {
265:             display: flex;
266:             justify-content: space-between;
267:             align-items: center;
268:             margin-bottom: 2rem;
269:         }
270:         
271:         .last-updated {
272:             color: #7f8c8d;
273:             font-size: 0.875rem;
274:         }
275:         
276:         .error-message {
277:             background-color: #f8d7da;
278:             color: #721c24;
279:             padding: 1rem;
280:             border-radius: 4px;
281:             margin-bottom: 1rem;
282:             display: none;
283:         }
284:         
285:         .success-message {
286:             background-color: #d4edda;
287:             color: #155724;
288:             padding: 1rem;
289:             border-radius: 4px;
290:             margin-bottom: 1rem;
291:             display: none;
292:         }
293:         
294:         .loading {
295:             text-align: center;
296:             padding: 2rem;
297:             color: #7f8c8d;
298:         }
299:         
300:         .tag {
301:             display: inline-block;
302:             padding: 0.2rem 0.5rem;
303:             border-radius: 3px;
304:             font-size: 0.75rem;
305:             margin-right: 0.25rem;
306:         }
307:         
308:         .tag-udp {
309:             background-color: #e3f2fd;
310:             color: #1565c0;
311:         }
312:         
313:         .tag-ready {
314:             background-color: #e8f5e9;
315:             color: #2e7d32;
316:         }
317:         
318:         .event-log {
319:             background: white;
320:             padding: 1rem;
321:             border-radius: 8px;
322:             box-shadow: 0 2px 4px rgba(0,0,0,0.1);
323:             margin-top: 2rem;
324:             max-height: 200px;
325:             overflow-y: auto;
326:         }
327:         
328:         .event-log h3 {
329:             margin-bottom: 0.5rem;
330:             color: #2c3e50;
331:         }
332:         
333:         .event-item {
334:             padding: 0.25rem 0;
335:             border-bottom: 1px solid #eee;
336:             font-size: 0.875rem;
337:             color: #555;
338:         }
339:         
340:         .event-time {
341:             color: #7f8c8d;
342:             margin-right: 0.5rem;
343:         }
344:     </style>
345: </head>
346: <body>
347:     <div class="connection-status disconnected" id="wsStatus">WebSocket: Disconnected</div>
348:     
349:     <header>
350:         <div class="container">
351:             <h1>Rendezvous Service Admin</h1>
352:         </div>
353:     </header>
354:     
355:     <div class="container">
356:         <div class="error-message" id="errorMessage"></div>
357:         <div class="success-message" id="successMessage"></div>
358:         
359:         <div class="controls">
360:             <button class="refresh-btn" onclick="refreshWorkers()">Refresh Workers</button>
361:             <a href="/admin-chat" style="background-color: #27ae60; color: white; padding: 0.75rem 1.5rem; border-radius: 4px; text-decoration: none; font-size: 1rem; display: inline-block;">Open Chat Interface</a>
362:             <div class="last-updated" id="lastUpdated"></div>
363:         </div>
364:         
365:         <div class="stats" id="stats">
366:             <div class="stat-card">
367:                 <h3>Total Workers</h3>
368:                 <div class="value" id="totalCount">-</div>
369:             </div>
370:             <div class="stat-card">
371:                 <h3>Connected</h3>
372:                 <div class="value" id="connectedCount">-</div>
373:             </div>
374:             <div class="stat-card">
375:                 <h3>Ready for Pairing</h3>
376:                 <div class="value" id="readyCount">-</div>
377:             </div>
378:         </div>
379:         
380:         <div class="connection-panel">
381:             <h3>Manual Connection Control</h3>
382:             <div class="selected-workers" id="selectedWorkers">
383:                 <div style="color: #7f8c8d;">Select two workers to connect them...</div>
384:             </div>
385:             <div>
386:                 <button class="connect-btn" onclick="connectSelectedWorkers()" disabled>Connect Workers</button>
387:                 <button class="clear-btn" onclick="clearSelection()">Clear Selection</button>
388:             </div>
389:         </div>
390:         
391:         <h2 style="margin-bottom: 1rem;">Connected Workers</h2>
392:         <div class="workers-grid" id="workersGrid">
393:             <div class="loading">Loading workers...</div>
394:         </div>
395:         
396:         <div class="event-log">
397:             <h3>Event Log</h3>
398:             <div id="eventLog"></div>
399:         </div>
400:     </div>
401:     
402:     <script>
403:         let refreshInterval;
404:         let ws = null;
405:         let selectedWorkers = [];
406:         let workersData = {};
407:         
408:         // WebSocket connection
409:         function connectWebSocket() {
410:             const protocol = window.location.protocol === 'https:' ? 'wss:' : 'ws:';
411:             const wsUrl = `${protocol}//${window.location.host}/ws/admin`;
412:             
413:             ws = new WebSocket(wsUrl);
414:             
415:             ws.onopen = () => {
416:                 console.log('WebSocket connected');
417:                 updateConnectionStatus(true);
418:                 addEventLog('Connected to WebSocket');
419:             };
420:             
421:             ws.onclose = () => {
422:                 console.log('WebSocket disconnected');
423:                 updateConnectionStatus(false);
424:                 addEventLog('Disconnected from WebSocket');
425:                 // Reconnect after 3 seconds
426:                 setTimeout(connectWebSocket, 3000);
427:             };
428:             
429:             ws.onerror = (error) => {
430:                 console.error('WebSocket error:', error);
431:                 addEventLog('WebSocket error');
432:             };
433:             
434:             ws.onmessage = (event) => {
435:                 try {
436:                     const data = JSON.parse(event.data);
437:                     handleWebSocketMessage(data);
438:                 } catch (error) {
439:                     console.error('Error parsing WebSocket message:', error);
440:                 }
441:             };
442:         }
443:         
444:         function handleWebSocketMessage(data) {
445:             if (data.type === 'workers_update') {
446:                 updateUI({ workers: data.payload });
447:             }
448:         }
449:         
450:         function updateConnectionStatus(connected) {
451:             const statusEl = document.getElementById('wsStatus');
452:             if (connected) {
453:                 statusEl.textContent = 'WebSocket: Connected';
454:                 statusEl.className = 'connection-status connected';
455:             } else {
456:                 statusEl.textContent = 'WebSocket: Disconnected';
457:                 statusEl.className = 'connection-status disconnected';
458:             }
459:         }
460:         
461:         function addEventLog(message) {
462:             const eventLog = document.getElementById('eventLog');
463:             const time = new Date().toLocaleTimeString();
464:             const eventItem = document.createElement('div');
465:             eventItem.className = 'event-item';
466:             eventItem.innerHTML = `<span class="event-time">${time}</span>${message}`;
467:             eventLog.insertBefore(eventItem, eventLog.firstChild);
468:             
469:             // Keep only last 50 events
470:             while (eventLog.children.length > 50) {
471:                 eventLog.removeChild(eventLog.lastChild);
472:             }
473:         }
474:         
475:         async function fetchWorkers() {
476:             try {
477:                 const response = await fetch('/api/workers');
478:                 if (!response.ok) {
479:                     throw new Error(`HTTP error! status: ${response.status}`);
480:                 }
481:                 const data = await response.json();
482:                 workersData = {};
483:                 const workersList = data.workers || [];
484:                 workersList.forEach(worker => {
485:                     workersData[worker.worker_id] = worker;
486:                 });
487:                 updateUI({ workers: workersList });
488:                 hideError();
489:             } catch (error) {
490:                 console.error('Error fetching workers:', error);
491:                 showError('Failed to fetch workers: ' + error.message);
492:             }
493:         }
494:         
495:         function updateUI(data) {
496:             const workers = data.workers || [];
497:             
498:             // Update stats
499:             const totalCount = workers.length;
500:             const connectedCount = workers.filter(w => w.has_udp_endpoint).length;
501:             const readyCount = workers.filter(w => w.ready_for_pairing).length;
502:             
503:             document.getElementById('totalCount').textContent = totalCount;
504:             document.getElementById('connectedCount').textContent = connectedCount;
505:             document.getElementById('readyCount').textContent = readyCount;
506:             
507:             // Update workers grid
508:             const grid = document.getElementById('workersGrid');
509:             grid.innerHTML = '';
510:             
511:             if (workers.length === 0) {
512:                 grid.innerHTML = '<div class="loading">No workers connected</div>';
513:                 return;
514:             }
515:             
516:             workers.forEach(worker => {
517:                 const card = createWorkerCard(worker);
518:                 grid.appendChild(card);
519:             });
520:             
521:             // Update last updated time
522:             const now = new Date();
523:             document.getElementById('lastUpdated').textContent = 
524:                 `Last updated: ${now.toLocaleTimeString()}`;
525:         }
526:         
527:         function createWorkerCard(worker) {
528:             const card = document.createElement('div');
529:             card.className = 'worker-card';
530:             
531:             if (selectedWorkers.includes(worker.worker_id)) {
532:                 card.classList.add('selected');
533:             }
534:             
535:             const statusClass = worker.websocket_connected ? 'connected' : 'disconnected';
536:             const statusText = worker.websocket_connected ? 'Connected' : 'Disconnected';
537:             
538:             let tags = '';
539:             if (worker.has_udp_endpoint) {
540:                 tags += '<span class="tag tag-udp">UDP Ready</span>';
541:             }
542:             if (worker.ready_for_pairing) {
543:                 tags += '<span class="tag tag-ready">Ready for Pairing</span>';
544:             }
545:             
546:             card.innerHTML = `
547:                 <div class="worker-header">
548:                     <div>
549:                         <div class="worker-id">${worker.worker_id}</div>
550:                         <div style="margin-top: 0.5rem;">${tags}</div>
551:                     </div>
552:                     <span class="status-badge status-${statusClass}">${statusText}</span>
553:                 </div>
554:                 <div class="worker-details">
555:                     <div class="detail-row">
556:                         <span class="detail-label">WebSocket IP</span>
557:                         <span class="detail-value">${worker.websocket_ip || 'N/A'}</span>
558:                     </div>
559:                     <div class="detail-row">
560:                         <span class="detail-label">Public IP</span>
561:                         <span class="detail-value">${worker.http_public_ip || 'N/A'}</span>
562:                     </div>
563:                     <div class="detail-row">
564:                         <span class="detail-label">UDP Endpoint</span>
565:                         <span class="detail-value">${
566:                             worker.stun_udp_ip && worker.stun_udp_port 
567:                                 ? `${worker.stun_udp_ip}:${worker.stun_udp_port}` 
568:                                 : 'Not available'
569:                         }</span>
570:                     </div>
571:                 </div>
572:             `;
573:             
574:             // Add click handler
575:             card.onclick = () => toggleWorkerSelection(worker.worker_id);
576:             
577:             return card;
578:         }
579:         
580:         function toggleWorkerSelection(workerId) {
581:             const worker = workersData[workerId];
582:             
583:             if (!worker || !worker.ready_for_pairing) {
584:                 showError('Cannot select this worker - not ready for connection');
585:                 return;
586:             }
587:             
588:             const index = selectedWorkers.indexOf(workerId);
589:             if (index > -1) {
590:                 selectedWorkers.splice(index, 1);
591:             } else {
592:                 if (selectedWorkers.length >= 2) {
593:                     showError('You can only select 2 workers at a time');
594:                     return;
595:                 }
596:                 selectedWorkers.push(workerId);
597:             }
598:             
599:             updateSelectedWorkersDisplay();
600:             
601:             // Re-render worker cards to update selection state
602:             fetchWorkers();
603:         }
604:         
605:         function updateSelectedWorkersDisplay() {
606:             const container = document.getElementById('selectedWorkers');
607:             const connectBtn = document.querySelector('.connect-btn');
608:             
609:             if (selectedWorkers.length === 0) {
610:                 container.innerHTML = '<div style="color: #7f8c8d;">Select two workers to connect them...</div>';
611:                 connectBtn.disabled = true;
612:             } else {
613:                 container.innerHTML = selectedWorkers.map(id => `
614:                     <div class="selected-worker">
615:                         <span>${id.substring(0, 8)}...</span>
616:                         <span class="remove" onclick="removeFromSelection('${id}')">×</span>
617:                     </div>
618:                 `).join('');
619:                 connectBtn.disabled = selectedWorkers.length !== 2;
620:             }
621:         }
622:         
623:         function removeFromSelection(workerId) {
624:             selectedWorkers = selectedWorkers.filter(id => id !== workerId);
625:             updateSelectedWorkersDisplay();
626:             fetchWorkers();
627:         }
628:         
629:         function clearSelection() {
630:             selectedWorkers = [];
631:             updateSelectedWorkersDisplay();
632:             fetchWorkers();
633:         }
634:         
635:         async function connectSelectedWorkers() {
636:             if (selectedWorkers.length !== 2) return;
637:             
638:             const btn = document.querySelector('.connect-btn');
639:             btn.disabled = true;
640:             btn.textContent = 'Connecting...';
641:             
642:             try {
643:                 const response = await fetch('/api/connect', {
644:                     method: 'POST',
645:                     headers: {
646:                         'Content-Type': 'application/json',
647:                     },
648:                     body: JSON.stringify({
649:                         worker_id_1: selectedWorkers[0],
650:                         worker_id_2: selectedWorkers[1]
651:                     })
652:                 });
653:                 
654:                 const data = await response.json();
655:                 
656:                 if (response.ok) {
657:                     showSuccess('Workers connected successfully');
658:                     clearSelection();
659:                     addEventLog(`Connected: ${selectedWorkers[0].substring(0, 8)}... ↔ ${selectedWorkers[1].substring(0, 8)}...`);
660:                 } else {
661:                     showError(data.error || 'Failed to connect workers');
662:                 }
663:             } catch (error) {
664:                 console.error('Error connecting workers:', error);
665:                 showError('Failed to connect workers: ' + error.message);
666:             } finally {
667:                 btn.disabled = selectedWorkers.length !== 2;
668:                 btn.textContent = 'Connect Workers';
669:             }
670:         }
671:         
672:         function showError(message) {
673:             const errorEl = document.getElementById('errorMessage');
674:             errorEl.textContent = message;
675:             errorEl.style.display = 'block';
676:             setTimeout(() => {
677:                 errorEl.style.display = 'none';
678:             }, 5000);
679:         }
680:         
681:         function showSuccess(message) {
682:             const successEl = document.getElementById('successMessage');
683:             successEl.textContent = message;
684:             successEl.style.display = 'block';
685:             setTimeout(() => {
686:                 successEl.style.display = 'none';
687:             }, 5000);
688:         }
689:         
690:         function hideError() {
691:             const errorEl = document.getElementById('errorMessage');
692:             errorEl.style.display = 'none';
693:         }
694:         
695:         function refreshWorkers() {
696:             const btn = document.querySelector('.refresh-btn');
697:             btn.disabled = true;
698:             btn.textContent = 'Refreshing...';
699:             
700:             fetchWorkers().finally(() => {
701:                 btn.disabled = false;
702:                 btn.textContent = 'Refresh Workers';
703:             });
704:         }
705:         
706:         // Initial load
707:         fetchWorkers();
708:         connectWebSocket();
709:         
710:         // Periodic WebSocket ping to keep connection alive
711:         setInterval(() => {
712:             if (ws && ws.readyState === WebSocket.OPEN) {
713:                 ws.send('ping');
714:             }
715:         }, 30000);
716:         
717:         // Stop auto-refresh when page is hidden
718:         document.addEventListener('visibilitychange', () => {
719:             if (document.hidden) {
720:                 // Do nothing
721:             } else {
722:                 fetchWorkers();
723:             }
724:         });
725:     </script>
726: </body>
727: </html>
</file>

<file path="holepunch-go/web/worker/index.html">
  1: <!DOCTYPE html>
  2: <html>
  3: <head>
  4:     <meta charset="UTF-8">
  5:     <meta name="viewport" content="width=device-width, initial-scale=1.0">
  6:     <title>P2P UDP Chat - Worker: <span id="workerIdSpan">Loading...</span></title>
  7:     <script src="https://cdn.tailwindcss.com"></script>
  8:     <style>
  9:         /* Custom scrollbar for webkit browsers */
 10:         .custom-scrollbar::-webkit-scrollbar {
 11:             width: 8px;
 12:         }
 13:         .custom-scrollbar::-webkit-scrollbar-track {
 14:             background: #f1f1f1;
 15:             border-radius: 10px;
 16:         }
 17:         .custom-scrollbar::-webkit-scrollbar-thumb {
 18:             background: #888;
 19:             border-radius: 10px;
 20:         }
 21:         .custom-scrollbar::-webkit-scrollbar-thumb:hover {
 22:             background: #555;
 23:         }
 24:     </style>
 25: </head>
 26: <body class="bg-gray-200 flex flex-col items-center justify-start min-h-screen p-4 text-gray-800 antialiased">
 27: 
 28:     <div class="bg-white shadow-2xl rounded-xl p-6 sm:p-8 w-full max-w-3xl my-8">
 29:         <h1 class="text-4xl font-bold text-center text-indigo-700 mb-3">
 30:             P2P UDP Chat
 31:         </h1>
 32:         <div class="text-center text-base text-gray-600 mb-1">Worker ID: <span id="workerIdSpan" class="font-semibold text-indigo-600"></span></div>
 33:         <div id="status" class="text-center text-base text-gray-700 mb-2">Connecting to local worker backend...</div>
 34:         <div id="peerInfo" class="text-center text-base text-blue-700 font-medium mb-6">Peer: Not connected</div>
 35: 
 36:         <div id="chatbox" class="custom-scrollbar h-96 border border-gray-300 rounded-lg p-4 overflow-y-auto mb-5 bg-gray-100 space-y-3">
 37:             <!-- Messages will appear here -->
 38:         </div>
 39: 
 40:         <div class="flex flex-col sm:flex-row items-center gap-3 mb-8">
 41:             <input type="text" id="messageInput" placeholder="Type your message..." class="w-full sm:w-auto flex-grow p-4 border border-gray-300 rounded-lg focus:ring-2 focus:ring-indigo-600 focus:border-transparent outline-none text-base shadow-sm"/>
 42:             <button id="sendButton" type="button" class="w-full sm:w-auto bg-indigo-600 hover:bg-indigo-700 active:bg-indigo-800 text-white font-semibold py-4 px-8 rounded-lg transition duration-150 ease-in-out focus:outline-none focus:ring-2 focus:ring-indigo-500 focus:ring-offset-2 shadow-md hover:shadow-lg">
 43:                 Send
 44:             </button>
 45:         </div>
 46: 
 47:         <div id="benchmarkSection" class="mt-8 p-6 border border-gray-200 rounded-xl bg-slate-50 shadow">
 48:             <h3 class="text-2xl font-semibold text-gray-800 mb-4">P2P UDP Throughput Benchmark</h3>
 49:             <div class="flex flex-col sm:flex-row items-end gap-4">
 50:                 <div class="flex-grow w-full sm:w-auto">
 51:                     <label for="benchmarkSize" class="block text-base font-medium text-gray-700 mb-1.5">Data Size (KB):</label>
 52:                     <input type="number" id="benchmarkSize" value="1024" min="1" class="w-full p-3 border border-gray-300 rounded-lg focus:ring-1 focus:ring-indigo-600 focus:border-transparent outline-none text-base shadow-sm"/>
 53:                 </div>
 54:                 <button id="startBenchmarkButton" class="w-full sm:w-auto bg-green-600 hover:bg-green-700 active:bg-green-800 text-white font-semibold py-3 px-6 rounded-lg transition duration-150 ease-in-out focus:outline-none focus:ring-2 focus:ring-green-500 focus:ring-offset-2 shadow-md hover:shadow-lg">
 55:                     Start Benchmark
 56:                 </button>
 57:             </div>
 58:             <div id="benchmarkStatus" class="mt-4 text-base text-gray-700 bg-gray-100 p-4 rounded-lg min-h-[45px] shadow-inner">Benchmark status will appear here.</div>
 59:         </div>
 60:     </div>
 61: 
 62:     <script>
 63:         const workerIdSpan = document.getElementById('workerIdSpan');
 64:         const chatbox = document.getElementById('chatbox');
 65:         const messageInput = document.getElementById('messageInput');
 66:         const sendButton = document.getElementById('sendButton');
 67:         const statusDiv = document.getElementById('status');
 68:         const peerInfoDiv = document.getElementById('peerInfo');
 69:         const benchmarkSizeInput = document.getElementById('benchmarkSize');
 70:         const startBenchmarkButton = document.getElementById('startBenchmarkButton');
 71:         const benchmarkStatusDiv = document.getElementById('benchmarkStatus');
 72: 
 73:         let localUiSocket = null;
 74:         let myWorkerId = "Unknown";
 75: 
 76:         function addMessage(text, type = "system", sender = "") {
 77:             const messageDiv = document.createElement('div');
 78:             messageDiv.classList.add('p-3', 'rounded-xl', 'max-w-[90%]', 'break-words', 'shadow-sm', 'text-base');
 79:             let fullMessageText = text;
 80: 
 81:             if (type === 'local') {
 82:                 messageDiv.classList.add('bg-indigo-600', 'text-white', 'ml-auto', 'rounded-br-lg');
 83:                 fullMessageText = text;
 84:             } else if (type === 'peer') {
 85:                 messageDiv.classList.add('bg-slate-200', 'text-slate-800', 'mr-auto', 'rounded-bl-lg');
 86:                 fullMessageText = sender ? `${sender}: ${text}` : text;
 87:             } else { // system
 88:                 messageDiv.classList.add('bg-slate-100', 'text-slate-600', 'text-sm', 'italic', 'text-center', 'w-full', 'max-w-full', 'py-2', 'mx-auto', 'rounded-md');
 89:             }
 90:             messageDiv.textContent = fullMessageText;
 91:             chatbox.appendChild(messageDiv);
 92:             chatbox.scrollTop = chatbox.scrollHeight;
 93:         }
 94: 
 95:         function connectToLocalBackend() {
 96:             const wsProtocol = window.location.protocol === "https:" ? "wss:" : "ws:";
 97:             const localWsUrl = `${wsProtocol}//${window.location.host}/ui_ws`; 
 98:             
 99:             addMessage(`Attempting to connect to local UI WebSocket at ${localWsUrl}`, "system");
100:             localUiSocket = new WebSocket(localWsUrl);
101: 
102:             localUiSocket.onopen = function(event) {
103:                 statusDiv.textContent = "Connected to local worker backend. Waiting for P2P link...";
104:                 addMessage("Connection to local worker backend established.", "system");
105:             };
106: 
107:             localUiSocket.onmessage = function(event) {
108:                 try {
109:                     const data = JSON.parse(event.data);
110:                     console.log("Message from local worker backend:", data);
111:                     if (data.type === "init_info") {
112:                         const payload = data.payload;
113:                         myWorkerId = payload.worker_id;
114:                         workerIdSpan.textContent = myWorkerId ? myWorkerId.substring(0,8) + "..." : "N/A";
115:                         addMessage(`Worker ID: ${myWorkerId}`, "system");
116:                         if(payload.p2p_peer_id) {
117:                             peerInfoDiv.textContent = `P2P Connected to Peer: ${payload.p2p_peer_id.substring(0,8)}...`;
118:                             statusDiv.textContent = "P2P Link Active.";
119:                             startBenchmarkButton.disabled = false;
120:                             startBenchmarkButton.classList.remove('opacity-50', 'cursor-not-allowed');
121:                         } else {
122:                             startBenchmarkButton.disabled = true;
123:                             startBenchmarkButton.classList.add('opacity-50', 'cursor-not-allowed');
124:                         }
125:                     } else if (data.type === "p2p_message_received") {
126:                         addMessage(data.content, "peer", data.from_peer_id);
127:                     } else if (data.type === "p2p_connection_established") {
128:                         const peer_id = data.payload.peer_id;
129:                         addMessage(`P2P connection established with ${peer_id.substring(0,8)}...`, "system");
130:                         peerInfoDiv.textContent = `P2P Connected to Peer: ${peer_id.substring(0,8)}...`;
131:                         statusDiv.textContent = "P2P Link Active.";
132:                         startBenchmarkButton.disabled = false;
133:                         startBenchmarkButton.classList.remove('opacity-50', 'cursor-not-allowed');
134:                     } else if (data.type === "admin_chat_received") {
135:                         addMessage(`Admin: ${data.payload.content}`, "peer", "Admin");
136:                     } else if (data.type === "pairing_test_result") {
137:                         if (data.payload.success) {
138:                             addMessage(`Pairing test successful! RTT: ${data.payload.rtt_ms}ms`, "system");
139:                         }
140:                     } else if (data.type === "benchmark_status") {
141:                         benchmarkStatusDiv.textContent = data.message;
142:                         addMessage(data.message, "system");
143:                     } else if (data.type === "error") {
144:                         addMessage(`Error: ${data.message}`, "system");
145:                         benchmarkStatusDiv.textContent = `Error: ${data.message}`;
146:                     }
147:                 } catch (e) {
148:                     addMessage("Received non-JSON message from backend: " + event.data, "system");
149:                     console.error("Error parsing message from backend:", e, "Raw data:", event.data);
150:                 }
151:             };
152: 
153:             localUiSocket.onclose = function(event) {
154:                 statusDiv.textContent = "Disconnected from local worker backend. Attempting to reconnect...";
155:                 addMessage("Connection to local worker backend closed. Retrying in 5s...", "system");
156:                 startBenchmarkButton.disabled = true;
157:                 startBenchmarkButton.classList.add('opacity-50', 'cursor-not-allowed');
158:                 setTimeout(connectToLocalBackend, 5000);
159:             };
160: 
161:             localUiSocket.onerror = function(error) {
162:                 statusDiv.textContent = "Error connecting to local worker backend.";
163:                 addMessage("WebSocket error with local worker backend: " + error.message, "system");
164:                 console.error("WebSocket Error: ", error);
165:             };
166:         }
167: 
168:         sendButton.onclick = async function() {
169:             const messageText = messageInput.value.trim();
170:             if (messageText && localUiSocket && localUiSocket.readyState === WebSocket.OPEN) {
171:                 localUiSocket.send(JSON.stringify({
172:                     type: "send_p2p_message",
173:                     payload: { content: messageText }
174:                 }));
175:                 addMessage(messageText, "local");
176:                 messageInput.value = '';
177:             } else if (!localUiSocket || localUiSocket.readyState !== WebSocket.OPEN) {
178:                 addMessage("Not connected to worker backend.", "system");
179:             } else {
180:                 addMessage("Cannot send an empty message.", "system");
181:             }
182:         };
183:         
184:         startBenchmarkButton.disabled = true; // Initially disable
185:         startBenchmarkButton.classList.add('opacity-50', 'cursor-not-allowed');
186: 
187:         startBenchmarkButton.onclick = async function() {
188:             const sizeKb = parseInt(benchmarkSizeInput.value, 10);
189:             if (isNaN(sizeKb) || sizeKb <= 0) {
190:                 addMessage("Invalid benchmark data size.", "system");
191:                 benchmarkStatusDiv.textContent = "Invalid data size for benchmark.";
192:                 return;
193:             }
194:             
195:             if (localUiSocket && localUiSocket.readyState === WebSocket.OPEN) {
196:                 localUiSocket.send(JSON.stringify({
197:                     type: "start_benchmark_send", // Match Python
198:                     payload: { size_kb: sizeKb } // Match Python
199:                 }));
200:                 benchmarkStatusDiv.textContent = `Benchmark initiated to send ${sizeKb} KB...`;
201:             } else {
202:                 benchmarkStatusDiv.textContent = "Not connected to worker backend.";
203:                 addMessage("Cannot start benchmark: not connected to worker backend.", "system");
204:             }
205:         };
206: 
207:         messageInput.addEventListener("keypress", function(event) {
208:             if (event.key === "Enter") {
209:                 event.preventDefault();
210:                 sendButton.click();
211:             }
212:         });
213: 
214:         // Handle admin chat responses
215:         window.sendAdminResponse = function(adminId, content) {
216:             if (localUiSocket && localUiSocket.readyState === WebSocket.OPEN) {
217:                 localUiSocket.send(JSON.stringify({
218:                     type: "send_admin_response",
219:                     payload: {
220:                         admin_id: adminId,
221:                         content: content
222:                     }
223:                 }));
224:             }
225:         };
226: 
227:         connectToLocalBackend();
228:     </script>
229: </body>
230: </html>
</file>

<file path="holepunch-go/go.mod">
 1: module github.com/elisilver/holepunch
 2: 
 3: go 1.24
 4: 
 5: require (
 6: 	github.com/google/uuid v1.6.0
 7: 	github.com/gorilla/websocket v1.5.1
 8: 	github.com/labstack/echo/v4 v4.11.4
 9: 	github.com/pion/stun v0.6.1
10: )
11: 
12: require (
13: 	github.com/golang-jwt/jwt v3.2.2+incompatible // indirect
14: 	github.com/labstack/gommon v0.4.2 // indirect
15: 	github.com/mattn/go-colorable v0.1.13 // indirect
16: 	github.com/mattn/go-isatty v0.0.20 // indirect
17: 	github.com/pion/dtls/v2 v2.2.7 // indirect
18: 	github.com/pion/logging v0.2.2 // indirect
19: 	github.com/pion/transport/v2 v2.2.1 // indirect
20: 	github.com/valyala/bytebufferpool v1.0.0 // indirect
21: 	github.com/valyala/fasttemplate v1.2.2 // indirect
22: 	golang.org/x/crypto v0.17.0 // indirect
23: 	golang.org/x/net v0.19.0 // indirect
24: 	golang.org/x/sys v0.15.0 // indirect
25: 	golang.org/x/text v0.14.0 // indirect
26: 	golang.org/x/time v0.5.0 // indirect
27: )
</file>

<file path="rendezvous_service_code/__init__.py">
1: # Rendezvous service package
</file>

<file path="rendezvous_service_code/admin_websocket.py">
  1: """
  2: WebSocket handlers for admin UI and chat functionality
  3: """
  4: import json
  5: import asyncio
  6: from fastapi import WebSocket, WebSocketDisconnect
  7: 
  8: from models import service_state
  9: 
 10: 
 11: async def admin_websocket_endpoint(websocket: WebSocket):
 12:     """WebSocket endpoint for admin UI real-time updates"""
 13:     await websocket.accept()
 14:     service_state.admin_websocket_clients.append(websocket)
 15:     
 16:     print(f"Admin WebSocket client connected. Total admin clients: {len(service_state.admin_websocket_clients)}")
 17:     
 18:     try:
 19:         # Send initial state
 20:         await websocket.send_text(json.dumps({
 21:             "type": "connected",
 22:             "message": "Connected to admin WebSocket"
 23:         }))
 24:         
 25:         # Keep connection alive and wait for messages
 26:         while True:
 27:             try:
 28:                 # Wait for any message from client (for ping/pong)
 29:                 data = await websocket.receive_text()
 30:                 # Echo back for now
 31:                 if data == "ping":
 32:                     await websocket.send_text(json.dumps({"type": "pong"}))
 33:             except WebSocketDisconnect:
 34:                 break
 35:                 
 36:     except Exception as e:
 37:         print(f"Error in admin WebSocket: {e}")
 38:     finally:
 39:         if websocket in service_state.admin_websocket_clients:
 40:             service_state.admin_websocket_clients.remove(websocket)
 41:         print(f"Admin WebSocket client disconnected. Total admin clients: {len(service_state.admin_websocket_clients)}")
 42: 
 43: 
 44: async def chat_websocket_endpoint(websocket: WebSocket, admin_session_id: str, worker_id: str):
 45:     """WebSocket endpoint for admin to chat with a specific worker"""
 46:     # Verify worker exists and is connected
 47:     if worker_id not in service_state.connected_workers:
 48:         await websocket.close(code=1008, reason="Worker not found")
 49:         return
 50:     
 51:     worker_data = service_state.connected_workers[worker_id]
 52:     if not (worker_data.get("websocket") and hasattr(worker_data["websocket"], 'client_state') 
 53:             and worker_data["websocket"].client_state.value == 1):
 54:         await websocket.close(code=1008, reason="Worker not connected")
 55:         return
 56:     
 57:     await websocket.accept()
 58:     
 59:     # Store the chat session
 60:     if admin_session_id not in service_state.chat_sessions:
 61:         service_state.chat_sessions[admin_session_id] = {}
 62:     service_state.chat_sessions[admin_session_id][worker_id] = websocket
 63:     
 64:     print(f"Admin chat session '{admin_session_id}' connected to worker '{worker_id}'")
 65:     
 66:     # Send initial connection message
 67:     await websocket.send_text(json.dumps({
 68:         "type": "chat_connected",
 69:         "worker_id": worker_id,
 70:         "message": f"Connected to worker {worker_id}"
 71:     }))
 72:     
 73:     try:
 74:         while True:
 75:             try:
 76:                 # Receive message from admin
 77:                 data = await websocket.receive_text()
 78:                 message = json.loads(data)
 79:                 
 80:                 if message.get("type") == "chat_message":
 81:                     content = message.get("content")
 82:                     if content and worker_id in service_state.connected_workers:
 83:                         worker_ws = service_state.connected_workers[worker_id].get("websocket")
 84:                         if worker_ws:
 85:                             # Forward message to worker
 86:                             await worker_ws.send_text(json.dumps({
 87:                                 "type": "admin_chat_message",
 88:                                 "admin_session_id": admin_session_id,
 89:                                 "content": content
 90:                             }))
 91:                             
 92:                             # Echo back to admin with timestamp
 93:                             await websocket.send_text(json.dumps({
 94:                                 "type": "chat_message",
 95:                                 "from": "admin",
 96:                                 "content": content,
 97:                                 "timestamp": asyncio.get_event_loop().time()
 98:                             }))
 99:                         else:
100:                             await websocket.send_text(json.dumps({
101:                                 "type": "error",
102:                                 "message": "Worker disconnected"
103:                             }))
104:                             break
105:                             
106:             except WebSocketDisconnect:
107:                 break
108:             except json.JSONDecodeError:
109:                 await websocket.send_text(json.dumps({
110:                     "type": "error",
111:                     "message": "Invalid message format"
112:                 }))
113:                 
114:     except Exception as e:
115:         print(f"Error in chat session '{admin_session_id}' with worker '{worker_id}': {e}")
116:     finally:
117:         # Clean up chat session
118:         if admin_session_id in service_state.chat_sessions and worker_id in service_state.chat_sessions[admin_session_id]:
119:             del service_state.chat_sessions[admin_session_id][worker_id]
120:             if not service_state.chat_sessions[admin_session_id]:  # Remove empty session dict
121:                 del service_state.chat_sessions[admin_session_id]
122:         print(f"Admin chat session '{admin_session_id}' disconnected from worker '{worker_id}'")
</file>

<file path="rendezvous_service_code/admin-chat.html">
  1: <!DOCTYPE html>
  2: <html lang="en">
  3: <head>
  4:     <meta charset="UTF-8">
  5:     <meta name="viewport" content="width=device-width, initial-scale=1.0">
  6:     <title>Rendezvous Admin Chat</title>
  7:     <style>
  8:         * {
  9:             margin: 0;
 10:             padding: 0;
 11:             box-sizing: border-box;
 12:         }
 13:         
 14:         body {
 15:             font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, sans-serif;
 16:             background-color: #f5f5f5;
 17:             color: #333;
 18:             line-height: 1.6;
 19:             height: 100vh;
 20:             overflow: hidden;
 21:         }
 22:         
 23:         .main-container {
 24:             display: flex;
 25:             height: 100vh;
 26:         }
 27:         
 28:         .sidebar {
 29:             width: 300px;
 30:             background-color: #2c3e50;
 31:             color: white;
 32:             overflow-y: auto;
 33:             flex-shrink: 0;
 34:         }
 35:         
 36:         .sidebar h2 {
 37:             padding: 1rem;
 38:             background-color: #1a252f;
 39:             font-size: 1.2rem;
 40:             position: sticky;
 41:             top: 0;
 42:             z-index: 10;
 43:         }
 44:         
 45:         .worker-list {
 46:             padding: 0.5rem;
 47:         }
 48:         
 49:         .worker-item {
 50:             padding: 0.75rem;
 51:             margin-bottom: 0.5rem;
 52:             background-color: #34495e;
 53:             border-radius: 4px;
 54:             cursor: pointer;
 55:             transition: background-color 0.2s;
 56:             display: flex;
 57:             justify-content: space-between;
 58:             align-items: center;
 59:         }
 60:         
 61:         .worker-item:hover {
 62:             background-color: #4a5f7a;
 63:         }
 64:         
 65:         .worker-item.active {
 66:             background-color: #3498db;
 67:         }
 68:         
 69:         .worker-item.disconnected {
 70:             opacity: 0.5;
 71:             cursor: not-allowed;
 72:         }
 73:         
 74:         .worker-id {
 75:             font-family: 'Courier New', monospace;
 76:             font-size: 0.875rem;
 77:             overflow: hidden;
 78:             text-overflow: ellipsis;
 79:             white-space: nowrap;
 80:             flex: 1;
 81:         }
 82:         
 83:         .worker-status {
 84:             width: 8px;
 85:             height: 8px;
 86:             border-radius: 50%;
 87:             flex-shrink: 0;
 88:             margin-left: 0.5rem;
 89:         }
 90:         
 91:         .worker-status.connected {
 92:             background-color: #2ecc71;
 93:         }
 94:         
 95:         .worker-status.disconnected {
 96:             background-color: #e74c3c;
 97:         }
 98:         
 99:         .chat-container {
100:             flex: 1;
101:             display: flex;
102:             flex-direction: column;
103:             background-color: white;
104:         }
105:         
106:         .chat-header {
107:             padding: 1rem;
108:             background-color: #ecf0f1;
109:             border-bottom: 1px solid #bdc3c7;
110:             display: flex;
111:             justify-content: space-between;
112:             align-items: center;
113:         }
114:         
115:         .chat-header h3 {
116:             color: #2c3e50;
117:             font-size: 1.1rem;
118:         }
119:         
120:         .connection-status {
121:             padding: 0.25rem 0.75rem;
122:             border-radius: 9999px;
123:             font-size: 0.75rem;
124:             font-weight: 600;
125:         }
126:         
127:         .connection-status.connected {
128:             background-color: #d4edda;
129:             color: #155724;
130:         }
131:         
132:         .connection-status.disconnected {
133:             background-color: #f8d7da;
134:             color: #721c24;
135:         }
136:         
137:         .chat-messages {
138:             flex: 1;
139:             overflow-y: auto;
140:             padding: 1rem;
141:             background-color: #fafafa;
142:         }
143:         
144:         .message {
145:             margin-bottom: 1rem;
146:             display: flex;
147:             align-items: flex-start;
148:         }
149:         
150:         .message.admin {
151:             justify-content: flex-end;
152:         }
153:         
154:         .message.worker {
155:             justify-content: flex-start;
156:         }
157:         
158:         .message-bubble {
159:             max-width: 70%;
160:             padding: 0.75rem 1rem;
161:             border-radius: 8px;
162:             word-wrap: break-word;
163:         }
164:         
165:         .message.admin .message-bubble {
166:             background-color: #3498db;
167:             color: white;
168:             border-bottom-right-radius: 2px;
169:         }
170:         
171:         .message.worker .message-bubble {
172:             background-color: #ecf0f1;
173:             color: #2c3e50;
174:             border-bottom-left-radius: 2px;
175:         }
176:         
177:         .message-time {
178:             font-size: 0.75rem;
179:             color: #7f8c8d;
180:             margin-top: 0.25rem;
181:         }
182:         
183:         .message.admin .message-time {
184:             text-align: right;
185:         }
186:         
187:         .chat-input-container {
188:             padding: 1rem;
189:             border-top: 1px solid #bdc3c7;
190:             background-color: white;
191:         }
192:         
193:         .chat-input-form {
194:             display: flex;
195:             gap: 0.5rem;
196:         }
197:         
198:         .chat-input {
199:             flex: 1;
200:             padding: 0.75rem;
201:             border: 1px solid #bdc3c7;
202:             border-radius: 4px;
203:             font-size: 1rem;
204:             outline: none;
205:             transition: border-color 0.2s;
206:         }
207:         
208:         .chat-input:focus {
209:             border-color: #3498db;
210:         }
211:         
212:         .send-btn {
213:             padding: 0.75rem 1.5rem;
214:             background-color: #3498db;
215:             color: white;
216:             border: none;
217:             border-radius: 4px;
218:             cursor: pointer;
219:             font-size: 1rem;
220:             transition: background-color 0.2s;
221:         }
222:         
223:         .send-btn:hover:not(:disabled) {
224:             background-color: #2980b9;
225:         }
226:         
227:         .send-btn:disabled {
228:             background-color: #bdc3c7;
229:             cursor: not-allowed;
230:         }
231:         
232:         .no-selection {
233:             flex: 1;
234:             display: flex;
235:             align-items: center;
236:             justify-content: center;
237:             color: #7f8c8d;
238:             font-size: 1.2rem;
239:         }
240:         
241:         .error-toast {
242:             position: fixed;
243:             bottom: 2rem;
244:             right: 2rem;
245:             background-color: #e74c3c;
246:             color: white;
247:             padding: 1rem 1.5rem;
248:             border-radius: 4px;
249:             box-shadow: 0 4px 6px rgba(0,0,0,0.1);
250:             display: none;
251:             animation: slideIn 0.3s ease-out;
252:         }
253:         
254:         @keyframes slideIn {
255:             from {
256:                 transform: translateX(100%);
257:             }
258:             to {
259:                 transform: translateX(0);
260:             }
261:         }
262:         
263:         .back-link {
264:             position: fixed;
265:             top: 1rem;
266:             right: 1rem;
267:             background-color: #34495e;
268:             color: white;
269:             padding: 0.5rem 1rem;
270:             border-radius: 4px;
271:             text-decoration: none;
272:             font-size: 0.875rem;
273:             transition: background-color 0.2s;
274:         }
275:         
276:         .back-link:hover {
277:             background-color: #2c3e50;
278:         }
279:     </style>
280: </head>
281: <body>
282:     <a href="/admin" class="back-link">← Back to Admin Dashboard</a>
283:     
284:     <div class="main-container">
285:         <div class="sidebar">
286:             <h2>Available Workers</h2>
287:             <div class="worker-list" id="workerList">
288:                 <!-- Workers will be populated here -->
289:             </div>
290:         </div>
291:         
292:         <div class="chat-container" id="chatContainer">
293:             <div class="no-selection">
294:                 Select a worker to start chatting
295:             </div>
296:         </div>
297:     </div>
298:     
299:     <div class="error-toast" id="errorToast"></div>
300:     
301:     <script>
302:         let selectedWorkerId = null;
303:         let chatWs = null;
304:         let adminSessionId = generateSessionId();
305:         let workers = {};
306:         let messageHistory = {}; // Store messages per worker
307:         
308:         function generateSessionId() {
309:             return 'admin-' + Date.now() + '-' + Math.random().toString(36).substr(2, 9);
310:         }
311:         
312:         async function fetchWorkers() {
313:             try {
314:                 const response = await fetch('/api/workers');
315:                 const data = await response.json();
316:                 workers = {};
317:                 data.workers.forEach(worker => {
318:                     workers[worker.worker_id] = worker;
319:                 });
320:                 updateWorkerList(data.workers);
321:             } catch (error) {
322:                 console.error('Error fetching workers:', error);
323:                 showError('Failed to fetch workers');
324:             }
325:         }
326:         
327:         function updateWorkerList(workersList) {
328:             const workerListEl = document.getElementById('workerList');
329:             workerListEl.innerHTML = '';
330:             
331:             workersList.forEach(worker => {
332:                 const workerEl = document.createElement('div');
333:                 workerEl.className = `worker-item ${worker.websocket_connected ? '' : 'disconnected'} ${worker.worker_id === selectedWorkerId ? 'active' : ''}`;
334:                 workerEl.innerHTML = `
335:                     <span class="worker-id">${worker.worker_id}</span>
336:                     <span class="worker-status ${worker.websocket_connected ? 'connected' : 'disconnected'}"></span>
337:                 `;
338:                 
339:                 if (worker.websocket_connected) {
340:                     workerEl.onclick = () => selectWorker(worker.worker_id);
341:                 }
342:                 
343:                 workerListEl.appendChild(workerEl);
344:             });
345:         }
346:         
347:         function selectWorker(workerId) {
348:             if (selectedWorkerId === workerId) return;
349:             
350:             // Close existing chat connection
351:             if (chatWs) {
352:                 chatWs.close();
353:                 chatWs = null;
354:             }
355:             
356:             selectedWorkerId = workerId;
357:             
358:             // Update UI
359:             document.querySelectorAll('.worker-item').forEach(el => {
360:                 el.classList.remove('active');
361:             });
362:             event.target.closest('.worker-item').classList.add('active');
363:             
364:             // Show chat interface
365:             showChatInterface(workerId);
366:             
367:             // Connect to chat WebSocket
368:             connectToChat(workerId);
369:         }
370:         
371:         function showChatInterface(workerId) {
372:             const chatContainer = document.getElementById('chatContainer');
373:             chatContainer.innerHTML = `
374:                 <div class="chat-header">
375:                     <h3>Chat with Worker: ${workerId.substring(0, 8)}...</h3>
376:                     <span class="connection-status disconnected" id="chatStatus">Connecting...</span>
377:                 </div>
378:                 <div class="chat-messages" id="chatMessages">
379:                     <!-- Messages will appear here -->
380:                 </div>
381:                 <div class="chat-input-container">
382:                     <form class="chat-input-form" onsubmit="sendMessage(event)">
383:                         <input type="text" class="chat-input" id="chatInput" placeholder="Type a message..." disabled>
384:                         <button type="submit" class="send-btn" id="sendBtn" disabled>Send</button>
385:                     </form>
386:                 </div>
387:             `;
388:             
389:             // Load message history if available
390:             if (messageHistory[workerId]) {
391:                 const messagesEl = document.getElementById('chatMessages');
392:                 messageHistory[workerId].forEach(msg => {
393:                     addMessageToUI(msg.from, msg.content, msg.timestamp);
394:                 });
395:                 messagesEl.scrollTop = messagesEl.scrollHeight;
396:             }
397:         }
398:         
399:         function connectToChat(workerId) {
400:             const protocol = window.location.protocol === 'https:' ? 'wss:' : 'ws:';
401:             const wsUrl = `${protocol}//${window.location.host}/ws/chat/${adminSessionId}/${workerId}`;
402:             
403:             chatWs = new WebSocket(wsUrl);
404:             
405:             chatWs.onopen = () => {
406:                 console.log('Chat WebSocket connected');
407:                 updateChatStatus(true);
408:                 document.getElementById('chatInput').disabled = false;
409:                 document.getElementById('sendBtn').disabled = false;
410:             };
411:             
412:             chatWs.onclose = () => {
413:                 console.log('Chat WebSocket disconnected');
414:                 updateChatStatus(false);
415:                 document.getElementById('chatInput').disabled = true;
416:                 document.getElementById('sendBtn').disabled = true;
417:             };
418:             
419:             chatWs.onerror = (error) => {
420:                 console.error('Chat WebSocket error:', error);
421:                 showError('Chat connection error');
422:             };
423:             
424:             chatWs.onmessage = (event) => {
425:                 try {
426:                     const data = JSON.parse(event.data);
427:                     handleChatMessage(data);
428:                 } catch (error) {
429:                     console.error('Error parsing chat message:', error);
430:                 }
431:             };
432:         }
433:         
434:         function handleChatMessage(data) {
435:             switch (data.type) {
436:                 case 'chat_connected':
437:                     console.log('Chat connected:', data.message);
438:                     break;
439:                 case 'chat_message':
440:                     addMessageToUI(data.from, data.content, data.timestamp);
441:                     // Store in history
442:                     if (!messageHistory[selectedWorkerId]) {
443:                         messageHistory[selectedWorkerId] = [];
444:                     }
445:                     messageHistory[selectedWorkerId].push({
446:                         from: data.from,
447:                         content: data.content,
448:                         timestamp: data.timestamp
449:                     });
450:                     break;
451:                 case 'error':
452:                     showError(data.message);
453:                     break;
454:             }
455:         }
456:         
457:         function addMessageToUI(from, content, timestamp) {
458:             const messagesEl = document.getElementById('chatMessages');
459:             if (!messagesEl) return;
460:             
461:             const messageEl = document.createElement('div');
462:             messageEl.className = `message ${from}`;
463:             
464:             const time = timestamp ? new Date(timestamp * 1000).toLocaleTimeString() : new Date().toLocaleTimeString();
465:             
466:             messageEl.innerHTML = `
467:                 <div class="message-content">
468:                     <div class="message-bubble">${escapeHtml(content)}</div>
469:                     <div class="message-time">${time}</div>
470:                 </div>
471:             `;
472:             
473:             messagesEl.appendChild(messageEl);
474:             messagesEl.scrollTop = messagesEl.scrollHeight;
475:         }
476:         
477:         function sendMessage(event) {
478:             event.preventDefault();
479:             
480:             const input = document.getElementById('chatInput');
481:             const message = input.value.trim();
482:             
483:             if (!message || !chatWs || chatWs.readyState !== WebSocket.OPEN) return;
484:             
485:             chatWs.send(JSON.stringify({
486:                 type: 'chat_message',
487:                 content: message
488:             }));
489:             
490:             input.value = '';
491:         }
492:         
493:         function updateChatStatus(connected) {
494:             const statusEl = document.getElementById('chatStatus');
495:             if (statusEl) {
496:                 statusEl.textContent = connected ? 'Connected' : 'Disconnected';
497:                 statusEl.className = `connection-status ${connected ? 'connected' : 'disconnected'}`;
498:             }
499:         }
500:         
501:         function showError(message) {
502:             const errorToast = document.getElementById('errorToast');
503:             errorToast.textContent = message;
504:             errorToast.style.display = 'block';
505:             
506:             setTimeout(() => {
507:                 errorToast.style.display = 'none';
508:             }, 3000);
509:         }
510:         
511:         function escapeHtml(text) {
512:             const div = document.createElement('div');
513:             div.textContent = text;
514:             return div.innerHTML;
515:         }
516:         
517:         // Initialize
518:         fetchWorkers();
519:         
520:         // Refresh worker list periodically
521:         setInterval(fetchWorkers, 5000);
522:     </script>
523: </body>
524: </html>
</file>

<file path="rendezvous_service_code/admin.html">
  1: <!DOCTYPE html>
  2: <html lang="en">
  3: <head>
  4:     <meta charset="UTF-8">
  5:     <meta name="viewport" content="width=device-width, initial-scale=1.0">
  6:     <title>Rendezvous Admin - Worker Management</title>
  7:     <style>
  8:         * {
  9:             margin: 0;
 10:             padding: 0;
 11:             box-sizing: border-box;
 12:         }
 13:         
 14:         body {
 15:             font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, sans-serif;
 16:             background-color: #f5f5f5;
 17:             color: #333;
 18:             line-height: 1.6;
 19:         }
 20:         
 21:         .container {
 22:             max-width: 1200px;
 23:             margin: 0 auto;
 24:             padding: 20px;
 25:         }
 26:         
 27:         header {
 28:             background-color: #2c3e50;
 29:             color: white;
 30:             padding: 1rem 0;
 31:             margin-bottom: 2rem;
 32:             box-shadow: 0 2px 4px rgba(0,0,0,0.1);
 33:         }
 34:         
 35:         header h1 {
 36:             text-align: center;
 37:             font-size: 2rem;
 38:         }
 39:         
 40:         .connection-status {
 41:             position: fixed;
 42:             top: 10px;
 43:             right: 10px;
 44:             padding: 0.5rem 1rem;
 45:             border-radius: 4px;
 46:             font-size: 0.875rem;
 47:             font-weight: 600;
 48:             z-index: 1000;
 49:         }
 50:         
 51:         .connection-status.connected {
 52:             background-color: #d4edda;
 53:             color: #155724;
 54:         }
 55:         
 56:         .connection-status.disconnected {
 57:             background-color: #f8d7da;
 58:             color: #721c24;
 59:         }
 60:         
 61:         .stats {
 62:             display: grid;
 63:             grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
 64:             gap: 1rem;
 65:             margin-bottom: 2rem;
 66:         }
 67:         
 68:         .stat-card {
 69:             background: white;
 70:             padding: 1.5rem;
 71:             border-radius: 8px;
 72:             box-shadow: 0 2px 4px rgba(0,0,0,0.1);
 73:             text-align: center;
 74:         }
 75:         
 76:         .stat-card h3 {
 77:             color: #7f8c8d;
 78:             font-size: 0.875rem;
 79:             text-transform: uppercase;
 80:             margin-bottom: 0.5rem;
 81:         }
 82:         
 83:         .stat-card .value {
 84:             font-size: 2rem;
 85:             font-weight: bold;
 86:             color: #2c3e50;
 87:         }
 88:         
 89:         .connection-panel {
 90:             background: white;
 91:             padding: 1.5rem;
 92:             border-radius: 8px;
 93:             box-shadow: 0 2px 4px rgba(0,0,0,0.1);
 94:             margin-bottom: 2rem;
 95:         }
 96:         
 97:         .connection-panel h3 {
 98:             margin-bottom: 1rem;
 99:             color: #2c3e50;
100:         }
101:         
102:         .selected-workers {
103:             display: flex;
104:             gap: 1rem;
105:             margin-bottom: 1rem;
106:             flex-wrap: wrap;
107:         }
108:         
109:         .selected-worker {
110:             background-color: #e3f2fd;
111:             padding: 0.5rem 1rem;
112:             border-radius: 4px;
113:             font-size: 0.875rem;
114:             display: flex;
115:             align-items: center;
116:             gap: 0.5rem;
117:         }
118:         
119:         .selected-worker .remove {
120:             cursor: pointer;
121:             color: #1565c0;
122:             font-weight: bold;
123:         }
124:         
125:         .connect-btn {
126:             background-color: #27ae60;
127:             color: white;
128:             border: none;
129:             padding: 0.75rem 1.5rem;
130:             border-radius: 4px;
131:             cursor: pointer;
132:             font-size: 1rem;
133:             transition: background-color 0.2s;
134:             margin-right: 1rem;
135:         }
136:         
137:         .connect-btn:hover:not(:disabled) {
138:             background-color: #229954;
139:         }
140:         
141:         .connect-btn:disabled {
142:             background-color: #bdc3c7;
143:             cursor: not-allowed;
144:         }
145:         
146:         .clear-btn {
147:             background-color: #e74c3c;
148:             color: white;
149:             border: none;
150:             padding: 0.75rem 1.5rem;
151:             border-radius: 4px;
152:             cursor: pointer;
153:             font-size: 1rem;
154:             transition: background-color 0.2s;
155:         }
156:         
157:         .clear-btn:hover {
158:             background-color: #c0392b;
159:         }
160:         
161:         .workers-grid {
162:             display: grid;
163:             grid-template-columns: repeat(auto-fill, minmax(350px, 1fr));
164:             gap: 1rem;
165:             margin-bottom: 2rem;
166:         }
167:         
168:         .worker-card {
169:             background: white;
170:             border-radius: 8px;
171:             padding: 1.5rem;
172:             box-shadow: 0 2px 4px rgba(0,0,0,0.1);
173:             transition: transform 0.2s, box-shadow 0.2s;
174:             cursor: pointer;
175:             position: relative;
176:         }
177:         
178:         .worker-card:hover {
179:             transform: translateY(-2px);
180:             box-shadow: 0 4px 8px rgba(0,0,0,0.15);
181:         }
182:         
183:         .worker-card.selected {
184:             border: 2px solid #3498db;
185:             background-color: #ebf5fb;
186:         }
187:         
188:         .worker-header {
189:             display: flex;
190:             justify-content: space-between;
191:             align-items: center;
192:             margin-bottom: 1rem;
193:         }
194:         
195:         .worker-id {
196:             font-family: 'Courier New', monospace;
197:             font-size: 0.875rem;
198:             color: #34495e;
199:             word-break: break-all;
200:         }
201:         
202:         .status-badge {
203:             display: inline-block;
204:             padding: 0.25rem 0.75rem;
205:             border-radius: 9999px;
206:             font-size: 0.75rem;
207:             font-weight: 600;
208:             text-transform: uppercase;
209:         }
210:         
211:         .status-connected {
212:             background-color: #d4edda;
213:             color: #155724;
214:         }
215:         
216:         .status-disconnected {
217:             background-color: #f8d7da;
218:             color: #721c24;
219:         }
220:         
221:         .worker-details {
222:             display: grid;
223:             gap: 0.5rem;
224:             font-size: 0.875rem;
225:         }
226:         
227:         .detail-row {
228:             display: flex;
229:             justify-content: space-between;
230:             padding: 0.25rem 0;
231:             border-bottom: 1px solid #eee;
232:         }
233:         
234:         .detail-label {
235:             color: #7f8c8d;
236:         }
237:         
238:         .detail-value {
239:             font-family: 'Courier New', monospace;
240:             color: #2c3e50;
241:             text-align: right;
242:         }
243:         
244:         .refresh-btn {
245:             background-color: #3498db;
246:             color: white;
247:             border: none;
248:             padding: 0.75rem 1.5rem;
249:             border-radius: 4px;
250:             cursor: pointer;
251:             font-size: 1rem;
252:             transition: background-color 0.2s;
253:         }
254:         
255:         .refresh-btn:hover {
256:             background-color: #2980b9;
257:         }
258:         
259:         .refresh-btn:disabled {
260:             background-color: #bdc3c7;
261:             cursor: not-allowed;
262:         }
263:         
264:         .controls {
265:             display: flex;
266:             justify-content: space-between;
267:             align-items: center;
268:             margin-bottom: 2rem;
269:         }
270:         
271:         .last-updated {
272:             color: #7f8c8d;
273:             font-size: 0.875rem;
274:         }
275:         
276:         .error-message {
277:             background-color: #f8d7da;
278:             color: #721c24;
279:             padding: 1rem;
280:             border-radius: 4px;
281:             margin-bottom: 1rem;
282:             display: none;
283:         }
284:         
285:         .success-message {
286:             background-color: #d4edda;
287:             color: #155724;
288:             padding: 1rem;
289:             border-radius: 4px;
290:             margin-bottom: 1rem;
291:             display: none;
292:         }
293:         
294:         .loading {
295:             text-align: center;
296:             padding: 2rem;
297:             color: #7f8c8d;
298:         }
299:         
300:         .tag {
301:             display: inline-block;
302:             padding: 0.2rem 0.5rem;
303:             border-radius: 3px;
304:             font-size: 0.75rem;
305:             margin-right: 0.25rem;
306:         }
307:         
308:         .tag-udp {
309:             background-color: #e3f2fd;
310:             color: #1565c0;
311:         }
312:         
313:         .tag-ready {
314:             background-color: #e8f5e9;
315:             color: #2e7d32;
316:         }
317:         
318:         .event-log {
319:             background: white;
320:             padding: 1rem;
321:             border-radius: 8px;
322:             box-shadow: 0 2px 4px rgba(0,0,0,0.1);
323:             margin-top: 2rem;
324:             max-height: 200px;
325:             overflow-y: auto;
326:         }
327:         
328:         .event-log h3 {
329:             margin-bottom: 0.5rem;
330:             color: #2c3e50;
331:         }
332:         
333:         .event-item {
334:             padding: 0.25rem 0;
335:             border-bottom: 1px solid #eee;
336:             font-size: 0.875rem;
337:             color: #555;
338:         }
339:         
340:         .event-time {
341:             color: #7f8c8d;
342:             margin-right: 0.5rem;
343:         }
344:     </style>
345: </head>
346: <body>
347:     <div class="connection-status disconnected" id="wsStatus">WebSocket: Disconnected</div>
348:     
349:     <header>
350:         <div class="container">
351:             <h1>Rendezvous Service Admin</h1>
352:         </div>
353:     </header>
354:     
355:     <div class="container">
356:         <div class="error-message" id="errorMessage"></div>
357:         <div class="success-message" id="successMessage"></div>
358:         
359:         <div class="controls">
360:             <button class="refresh-btn" onclick="refreshWorkers()">Refresh Workers</button>
361:             <a href="/admin/chat" style="background-color: #27ae60; color: white; padding: 0.75rem 1.5rem; border-radius: 4px; text-decoration: none; font-size: 1rem; display: inline-block;">Open Chat Interface</a>
362:             <div class="last-updated" id="lastUpdated"></div>
363:         </div>
364:         
365:         <div class="stats" id="stats">
366:             <div class="stat-card">
367:                 <h3>Total Workers</h3>
368:                 <div class="value" id="totalCount">-</div>
369:             </div>
370:             <div class="stat-card">
371:                 <h3>Connected</h3>
372:                 <div class="value" id="connectedCount">-</div>
373:             </div>
374:             <div class="stat-card">
375:                 <h3>Ready for Pairing</h3>
376:                 <div class="value" id="readyCount">-</div>
377:             </div>
378:         </div>
379:         
380:         <div class="connection-panel">
381:             <h3>Manual Connection Control</h3>
382:             <div class="selected-workers" id="selectedWorkers">
383:                 <div style="color: #7f8c8d;">Select two workers to connect them...</div>
384:             </div>
385:             <div>
386:                 <button class="connect-btn" onclick="connectSelectedWorkers()" disabled>Connect Workers</button>
387:                 <button class="clear-btn" onclick="clearSelection()">Clear Selection</button>
388:             </div>
389:         </div>
390:         
391:         <h2 style="margin-bottom: 1rem;">Connected Workers</h2>
392:         <div class="workers-grid" id="workersGrid">
393:             <div class="loading">Loading workers...</div>
394:         </div>
395:         
396:         <div class="event-log">
397:             <h3>Event Log</h3>
398:             <div id="eventLog"></div>
399:         </div>
400:     </div>
401:     
402:     <script>
403:         let refreshInterval;
404:         let ws = null;
405:         let selectedWorkers = [];
406:         let workersData = {};
407:         
408:         // WebSocket connection
409:         function connectWebSocket() {
410:             const protocol = window.location.protocol === 'https:' ? 'wss:' : 'ws:';
411:             const wsUrl = `${protocol}//${window.location.host}/ws/admin`;
412:             
413:             ws = new WebSocket(wsUrl);
414:             
415:             ws.onopen = () => {
416:                 console.log('WebSocket connected');
417:                 updateConnectionStatus(true);
418:                 addEventLog('Connected to WebSocket');
419:             };
420:             
421:             ws.onclose = () => {
422:                 console.log('WebSocket disconnected');
423:                 updateConnectionStatus(false);
424:                 addEventLog('Disconnected from WebSocket');
425:                 // Reconnect after 3 seconds
426:                 setTimeout(connectWebSocket, 3000);
427:             };
428:             
429:             ws.onerror = (error) => {
430:                 console.error('WebSocket error:', error);
431:                 addEventLog('WebSocket error');
432:             };
433:             
434:             ws.onmessage = (event) => {
435:                 try {
436:                     const data = JSON.parse(event.data);
437:                     handleWebSocketMessage(data);
438:                 } catch (error) {
439:                     console.error('Error parsing WebSocket message:', error);
440:                 }
441:             };
442:         }
443:         
444:         function handleWebSocketMessage(data) {
445:             switch (data.type) {
446:                 case 'worker_connected':
447:                     addEventLog(`Worker connected: ${data.worker_id.substring(0, 8)}...`);
448:                     refreshWorkers();
449:                     break;
450:                 case 'worker_disconnected':
451:                     addEventLog(`Worker disconnected: ${data.worker_id.substring(0, 8)}...`);
452:                     // Remove from selection if selected
453:                     selectedWorkers = selectedWorkers.filter(id => id !== data.worker_id);
454:                     updateSelectedWorkersDisplay();
455:                     refreshWorkers();
456:                     break;
457:                 case 'worker_udp_updated':
458:                     addEventLog(`Worker UDP updated: ${data.worker_id.substring(0, 8)}... → ${data.udp_ip}:${data.udp_port}`);
459:                     refreshWorkers();
460:                     break;
461:                 case 'connection_initiated':
462:                     addEventLog(`Connection initiated: ${data.worker_a_id.substring(0, 8)}... ↔ ${data.worker_b_id.substring(0, 8)}...`);
463:                     break;
464:             }
465:         }
466:         
467:         function updateConnectionStatus(connected) {
468:             const statusEl = document.getElementById('wsStatus');
469:             if (connected) {
470:                 statusEl.textContent = 'WebSocket: Connected';
471:                 statusEl.className = 'connection-status connected';
472:             } else {
473:                 statusEl.textContent = 'WebSocket: Disconnected';
474:                 statusEl.className = 'connection-status disconnected';
475:             }
476:         }
477:         
478:         function addEventLog(message) {
479:             const eventLog = document.getElementById('eventLog');
480:             const time = new Date().toLocaleTimeString();
481:             const eventItem = document.createElement('div');
482:             eventItem.className = 'event-item';
483:             eventItem.innerHTML = `<span class="event-time">${time}</span>${message}`;
484:             eventLog.insertBefore(eventItem, eventLog.firstChild);
485:             
486:             // Keep only last 50 events
487:             while (eventLog.children.length > 50) {
488:                 eventLog.removeChild(eventLog.lastChild);
489:             }
490:         }
491:         
492:         async function fetchWorkers() {
493:             try {
494:                 const response = await fetch('/api/workers');
495:                 if (!response.ok) {
496:                     throw new Error(`HTTP error! status: ${response.status}`);
497:                 }
498:                 const data = await response.json();
499:                 workersData = {};
500:                 data.workers.forEach(worker => {
501:                     workersData[worker.worker_id] = worker;
502:                 });
503:                 updateUI(data);
504:                 hideError();
505:             } catch (error) {
506:                 console.error('Error fetching workers:', error);
507:                 showError('Failed to fetch workers: ' + error.message);
508:             }
509:         }
510:         
511:         function updateUI(data) {
512:             // Update stats
513:             document.getElementById('totalCount').textContent = data.total_count || 0;
514:             document.getElementById('connectedCount').textContent = data.connected_count || 0;
515:             document.getElementById('readyCount').textContent = data.ready_count || 0;
516:             
517:             // Update workers grid
518:             const grid = document.getElementById('workersGrid');
519:             grid.innerHTML = '';
520:             
521:             if (!data.workers || data.workers.length === 0) {
522:                 grid.innerHTML = '<div class="loading">No workers connected</div>';
523:                 return;
524:             }
525:             
526:             data.workers.forEach(worker => {
527:                 const card = createWorkerCard(worker);
528:                 grid.appendChild(card);
529:             });
530:             
531:             // Update last updated time
532:             const now = new Date();
533:             document.getElementById('lastUpdated').textContent = 
534:                 `Last updated: ${now.toLocaleTimeString()}`;
535:         }
536:         
537:         function createWorkerCard(worker) {
538:             const card = document.createElement('div');
539:             card.className = 'worker-card';
540:             if (selectedWorkers.includes(worker.worker_id)) {
541:                 card.classList.add('selected');
542:             }
543:             
544:             const statusClass = worker.websocket_connected ? 'connected' : 'disconnected';
545:             const statusText = worker.websocket_connected ? 'Connected' : 'Disconnected';
546:             
547:             let tags = '';
548:             if (worker.has_udp_endpoint) {
549:                 tags += '<span class="tag tag-udp">UDP Ready</span>';
550:             }
551:             if (worker.ready_for_pairing) {
552:                 tags += '<span class="tag tag-ready">Ready for Pairing</span>';
553:             }
554:             
555:             card.innerHTML = `
556:                 <div class="worker-header">
557:                     <div>
558:                         <div class="worker-id">${worker.worker_id}</div>
559:                         <div style="margin-top: 0.5rem;">${tags}</div>
560:                     </div>
561:                     <span class="status-badge status-${statusClass}">${statusText}</span>
562:                 </div>
563:                 <div class="worker-details">
564:                     <div class="detail-row">
565:                         <span class="detail-label">WebSocket IP</span>
566:                         <span class="detail-value">${worker.websocket_ip || 'N/A'}</span>
567:                     </div>
568:                     <div class="detail-row">
569:                         <span class="detail-label">Public IP</span>
570:                         <span class="detail-value">${worker.public_ip || 'N/A'}</span>
571:                     </div>
572:                     <div class="detail-row">
573:                         <span class="detail-label">UDP Endpoint</span>
574:                         <span class="detail-value">${
575:                             worker.udp_ip && worker.udp_port 
576:                                 ? `${worker.udp_ip}:${worker.udp_port}` 
577:                                 : 'Not available'
578:                         }</span>
579:                     </div>
580:                 </div>
581:             `;
582:             
583:             // Add click handler
584:             card.onclick = () => toggleWorkerSelection(worker.worker_id);
585:             
586:             return card;
587:         }
588:         
589:         function toggleWorkerSelection(workerId) {
590:             const worker = workersData[workerId];
591:             if (!worker || !worker.websocket_connected || !worker.has_udp_endpoint) {
592:                 showError('Cannot select this worker - not ready for connection');
593:                 return;
594:             }
595:             
596:             const index = selectedWorkers.indexOf(workerId);
597:             if (index > -1) {
598:                 selectedWorkers.splice(index, 1);
599:             } else {
600:                 if (selectedWorkers.length >= 2) {
601:                     showError('You can only select 2 workers at a time');
602:                     return;
603:                 }
604:                 selectedWorkers.push(workerId);
605:             }
606:             
607:             updateSelectedWorkersDisplay();
608:             
609:             // Re-render worker cards to update selection state
610:             fetchWorkers();
611:         }
612:         
613:         function updateSelectedWorkersDisplay() {
614:             const container = document.getElementById('selectedWorkers');
615:             const connectBtn = document.querySelector('.connect-btn');
616:             
617:             if (selectedWorkers.length === 0) {
618:                 container.innerHTML = '<div style="color: #7f8c8d;">Select two workers to connect them...</div>';
619:                 connectBtn.disabled = true;
620:             } else {
621:                 container.innerHTML = selectedWorkers.map(id => `
622:                     <div class="selected-worker">
623:                         <span>${id.substring(0, 8)}...</span>
624:                         <span class="remove" onclick="removeFromSelection('${id}')">×</span>
625:                     </div>
626:                 `).join('');
627:                 connectBtn.disabled = selectedWorkers.length !== 2;
628:             }
629:         }
630:         
631:         function removeFromSelection(workerId) {
632:             selectedWorkers = selectedWorkers.filter(id => id !== workerId);
633:             updateSelectedWorkersDisplay();
634:             fetchWorkers();
635:         }
636:         
637:         function clearSelection() {
638:             selectedWorkers = [];
639:             updateSelectedWorkersDisplay();
640:             fetchWorkers();
641:         }
642:         
643:         async function connectSelectedWorkers() {
644:             if (selectedWorkers.length !== 2) return;
645:             
646:             const btn = document.querySelector('.connect-btn');
647:             btn.disabled = true;
648:             btn.textContent = 'Connecting...';
649:             
650:             try {
651:                 const response = await fetch('/api/connect', {
652:                     method: 'POST',
653:                     headers: {
654:                         'Content-Type': 'application/json',
655:                     },
656:                     body: JSON.stringify({
657:                         worker_a_id: selectedWorkers[0],
658:                         worker_b_id: selectedWorkers[1]
659:                     })
660:                 });
661:                 
662:                 const data = await response.json();
663:                 
664:                 if (response.ok) {
665:                     showSuccess(data.message);
666:                     clearSelection();
667:                 } else {
668:                     showError(data.detail || 'Failed to connect workers');
669:                 }
670:             } catch (error) {
671:                 console.error('Error connecting workers:', error);
672:                 showError('Failed to connect workers: ' + error.message);
673:             } finally {
674:                 btn.disabled = selectedWorkers.length !== 2;
675:                 btn.textContent = 'Connect Workers';
676:             }
677:         }
678:         
679:         function showError(message) {
680:             const errorEl = document.getElementById('errorMessage');
681:             errorEl.textContent = message;
682:             errorEl.style.display = 'block';
683:             setTimeout(() => {
684:                 errorEl.style.display = 'none';
685:             }, 5000);
686:         }
687:         
688:         function showSuccess(message) {
689:             const successEl = document.getElementById('successMessage');
690:             successEl.textContent = message;
691:             successEl.style.display = 'block';
692:             setTimeout(() => {
693:                 successEl.style.display = 'none';
694:             }, 5000);
695:         }
696:         
697:         function hideError() {
698:             const errorEl = document.getElementById('errorMessage');
699:             errorEl.style.display = 'none';
700:         }
701:         
702:         function refreshWorkers() {
703:             const btn = document.querySelector('.refresh-btn');
704:             btn.disabled = true;
705:             btn.textContent = 'Refreshing...';
706:             
707:             fetchWorkers().finally(() => {
708:                 btn.disabled = false;
709:                 btn.textContent = 'Refresh Workers';
710:             });
711:         }
712:         
713:         function startAutoRefresh() {
714:             // Stop using interval-based refresh since we have WebSocket
715:             // refreshInterval = setInterval(fetchWorkers, 5000);
716:         }
717:         
718:         function stopAutoRefresh() {
719:             if (refreshInterval) {
720:                 clearInterval(refreshInterval);
721:             }
722:         }
723:         
724:         // Initial load
725:         fetchWorkers();
726:         connectWebSocket();
727:         
728:         // Periodic WebSocket ping to keep connection alive
729:         setInterval(() => {
730:             if (ws && ws.readyState === WebSocket.OPEN) {
731:                 ws.send('ping');
732:             }
733:         }, 30000);
734:         
735:         // Stop auto-refresh when page is hidden
736:         document.addEventListener('visibilitychange', () => {
737:             if (document.hidden) {
738:                 stopAutoRefresh();
739:             } else {
740:                 fetchWorkers();
741:             }
742:         });
743:     </script>
744: </body>
745: </html>
</file>

<file path="rendezvous_service_code/broadcast.py">
 1: """
 2: Broadcasting utilities for admin clients
 3: """
 4: import json
 5: from typing import Dict, Any
 6: 
 7: from models import service_state
 8: 
 9: 
10: async def broadcast_to_admin_clients(message: Dict[str, Any]):
11:     """Send a message to all connected admin UI WebSocket clients"""
12:     if service_state.admin_websocket_clients:
13:         # Create a copy to avoid modification during iteration
14:         clients_copy = service_state.admin_websocket_clients.copy()
15:         for client in clients_copy:
16:             try:
17:                 await client.send_text(json.dumps(message))
18:             except Exception as e:
19:                 print(f"Error broadcasting to admin client: {e}")
20:                 # Remove disconnected client
21:                 if client in service_state.admin_websocket_clients:
22:                     service_state.admin_websocket_clients.remove(client)
</file>

<file path="rendezvous_service_code/main_original_backup.py">
  1: import asyncio
  2: import uvicorn
  3: from fastapi import FastAPI, WebSocket, WebSocketDisconnect, HTTPException
  4: from fastapi.staticfiles import StaticFiles
  5: from fastapi.responses import HTMLResponse
  6: from fastapi.middleware.cors import CORSMiddleware
  7: from typing import Dict, Optional, List, Tuple
  8: from pydantic import BaseModel
  9: import os
 10: import json
 11: from pathlib import Path
 12: 
 13: app = FastAPI(title="Rendezvous Service")
 14: 
 15: # Add CORS middleware for API access
 16: app.add_middleware(
 17:     CORSMiddleware,
 18:     allow_origins=["*"],  # In production, specify allowed origins
 19:     allow_credentials=True,
 20:     allow_methods=["*"],
 21:     allow_headers=["*"],
 22: )
 23: 
 24: # connected_workers structure from Step 3A:
 25: # { worker_id: { "websocket_observed_ip": ..., "websocket_observed_port": ...,
 26: #                "websocket": WebSocket, 
 27: #                "stun_reported_udp_ip": ..., "stun_reported_udp_port": ...,
 28: #                "http_reported_public_ip": ... # Optional, if you keep it
 29: #              }}
 30: connected_workers: Dict[str, Dict] = {}
 31: 
 32: # List of worker_ids that have reported UDP info and are waiting for a peer
 33: workers_ready_for_pairing: List[str] = []
 34: 
 35: # Admin UI WebSocket clients
 36: admin_websocket_clients: List[WebSocket] = []
 37: 
 38: # Chat sessions: admin_id -> worker_id -> websocket
 39: chat_sessions: Dict[str, Dict[str, WebSocket]] = {}
 40: 
 41: # Pydantic models for API requests
 42: class ConnectionRequest(BaseModel):
 43:     worker_a_id: str
 44:     worker_b_id: str
 45: 
 46: class ChatMessage(BaseModel):
 47:     content: str
 48:     worker_id: str
 49: 
 50: async def broadcast_to_admin_clients(message: dict):
 51:     """Send a message to all connected admin UI WebSocket clients"""
 52:     global admin_websocket_clients
 53:     if admin_websocket_clients:
 54:         # Create a copy to avoid modification during iteration
 55:         clients_copy = admin_websocket_clients.copy()
 56:         for client in clients_copy:
 57:             try:
 58:                 await client.send_text(json.dumps(message))
 59:             except Exception as e:
 60:                 print(f"Error broadcasting to admin client: {e}")
 61:                 # Remove disconnected client
 62:                 if client in admin_websocket_clients:
 63:                     admin_websocket_clients.remove(client)
 64: 
 65: async def attempt_to_pair_workers(newly_ready_worker_id: str):
 66:     global workers_ready_for_pairing, connected_workers
 67: 
 68:     # Ensure the worker trying to pair is valid and has WebSocket
 69:     newly_ready_worker_data = connected_workers.get(newly_ready_worker_id)
 70:     if not (newly_ready_worker_data and newly_ready_worker_data.get("stun_reported_udp_ip") and 
 71:             newly_ready_worker_data.get("websocket") and 
 72:             hasattr(newly_ready_worker_data["websocket"], 'client_state') and 
 73:             newly_ready_worker_data["websocket"].client_state.value == 1):
 74:         print(f"Pairing: Newly ready worker '{newly_ready_worker_id}' is not valid, lacks UDP info, or WebSocket is disconnected. Cannot initiate pairing.")
 75:         if newly_ready_worker_id in workers_ready_for_pairing:
 76:             workers_ready_for_pairing.remove(newly_ready_worker_id)
 77:         # Also ensure it's removed from connected_workers if its WebSocket is truly gone or invalid
 78:         if newly_ready_worker_id in connected_workers and (not newly_ready_worker_data or not newly_ready_worker_data.get("websocket") or 
 79:                                                         not hasattr(newly_ready_worker_data.get("websocket"), 'client_state') or
 80:                                                         newly_ready_worker_data.get("websocket").client_state.value != 1):
 81:             del connected_workers[newly_ready_worker_id]
 82:             print(f"Cleaned up disconnected newly_ready_worker_id '{newly_ready_worker_id}' from connected_workers.")
 83:         return
 84: 
 85:     if newly_ready_worker_id not in workers_ready_for_pairing:
 86:         workers_ready_for_pairing.append(newly_ready_worker_id)
 87:         print(f"Rendezvous: Worker '{newly_ready_worker_id}' added to ready_for_pairing list. Current list: {workers_ready_for_pairing}")
 88: 
 89:     if len(workers_ready_for_pairing) < 2:
 90:         print(f"Rendezvous: Not enough workers ready for pairing ({len(workers_ready_for_pairing)}). Waiting for more.")
 91:         return
 92: 
 93:     peer_a_id = None
 94:     peer_b_id = None
 95:     
 96:     # Create a copy of the list to iterate over, allowing modification of the original
 97:     candidate_ids = list(workers_ready_for_pairing)
 98:     
 99:     # NEW: Expand candidate list to include other connected workers that have
100:     # valid UDP info and active WebSocket, even if they are not currently
101:     # in the "workers_ready_for_pairing" list. This prevents a situation
102:     # where a long-standing worker that was already removed from the ready
103:     # list never gets paired with a newly-arriving worker until it next
104:     # refreshes its STUN endpoint.
105:     extra_candidates = [wid for wid, wdata in connected_workers.items()
106:                         if wid not in workers_ready_for_pairing
107:                         and wid != newly_ready_worker_id
108:                         and wdata.get("stun_reported_udp_ip")
109:                         and wdata.get("stun_reported_udp_port")
110:                         and wdata.get("websocket")
111:                         and hasattr(wdata["websocket"], 'client_state')
112:                         and wdata["websocket"].client_state.value == 1]
113:     if extra_candidates:
114:         print(f"Rendezvous: Found {len(extra_candidates)} additional connected worker(s) with UDP info that were not in ready list: {extra_candidates}")
115:         candidate_ids.extend(extra_candidates)
116:     # END NEW BLOCK
117:     
118:     for worker_id in candidate_ids:
119:         worker_data = connected_workers.get(worker_id)
120:         # Check if worker is still valid and its WebSocket is connected
121:         if not (worker_data and worker_data.get("stun_reported_udp_ip") and 
122:                 worker_data.get("websocket") and 
123:                 hasattr(worker_data["websocket"], 'client_state') and 
124:                 worker_data["websocket"].client_state.value == 1):
125:             
126:             print(f"Pairing: Worker '{worker_id}' in ready_list is stale or disconnected. Removing.")
127:             if worker_id in workers_ready_for_pairing:
128:                 workers_ready_for_pairing.remove(worker_id)
129:             if worker_id in connected_workers: # Remove from main dict too if its websocket is bad
130:                  # Check ws state again to be sure before deleting, in case it reconnected quickly
131:                 current_ws_state_in_dict = connected_workers[worker_id].get("websocket")
132:                 if not current_ws_state_in_dict or not hasattr(current_ws_state_in_dict, 'client_state') or current_ws_state_in_dict.client_state.value != 1 :
133:                     del connected_workers[worker_id]
134:                     print(f"Cleaned up stale worker '{worker_id}' from connected_workers during pairing attempt.")
135:             continue # Skip this stale worker
136: 
137:         # Worker is valid, try to find a peer for it
138:         if peer_a_id is None:
139:             peer_a_id = worker_id
140:         elif peer_a_id != worker_id: # Found a distinct, valid second peer
141:             peer_b_id = worker_id
142:             break # Found a pair
143: 
144:     if peer_a_id and peer_b_id:
145:         # Selected pair: peer_a_id, peer_b_id
146:         print(f"Rendezvous: Attempting to pair Worker '{peer_a_id}' with Worker '{peer_b_id}'.")
147: 
148:         peer_a_data = connected_workers.get(peer_a_id) # Re-fetch, in case of rapid changes (though less likely now)
149:         peer_b_data = connected_workers.get(peer_b_id)
150: 
151:         # Final check for data integrity and WebSocket state before sending offers
152:         if not (peer_a_data and peer_b_data and
153:                 peer_a_data.get("stun_reported_udp_ip") and peer_a_data.get("stun_reported_udp_port") and
154:                 peer_b_data.get("stun_reported_udp_ip") and peer_b_data.get("stun_reported_udp_port") and
155:                 peer_a_data.get("websocket") and hasattr(peer_a_data["websocket"], 'client_state') and peer_a_data["websocket"].client_state.value == 1 and
156:                 peer_b_data.get("websocket") and hasattr(peer_b_data["websocket"], 'client_state') and peer_b_data["websocket"].client_state.value == 1):
157:             
158:             print(f"Pairing Error: Post-selection data integrity or WebSocket issue for {peer_a_id} or {peer_b_id}. Aborting this pair.")
159:             # Don't re-add to workers_ready_for_pairing here. If they are still valid, 
160:             # they'll be picked up in a subsequent call or re-register.
161:             # Cleanup if one of them is now definitively disconnected:
162:             for p_id in [peer_a_id, peer_b_id]:
163:                 p_data = connected_workers.get(p_id)
164:                 if p_data and (not p_data.get("websocket") or not hasattr(p_data["websocket"], 'client_state') or p_data["websocket"].client_state.value != 1):
165:                     if p_id in workers_ready_for_pairing: workers_ready_for_pairing.remove(p_id)
166:                     if p_id in connected_workers: del connected_workers[p_id]
167:                     print(f"Cleaned up disconnected peer '{p_id}' after failed pairing integrity check.")
168:             return
169: 
170:         # If all checks passed, remove from ready list and send offers
171:         if peer_a_id in workers_ready_for_pairing: workers_ready_for_pairing.remove(peer_a_id)
172:         if peer_b_id in workers_ready_for_pairing: workers_ready_for_pairing.remove(peer_b_id)
173:         print(f"Rendezvous: Removed '{peer_a_id}' and '{peer_b_id}' from ready_for_pairing. Updated list: {workers_ready_for_pairing}")
174: 
175:         peer_a_ws = peer_a_data["websocket"]
176:         peer_b_ws = peer_b_data["websocket"]
177: 
178:         offer_to_b_payload = { 
179:             "type": "p2p_connection_offer",
180:             "peer_worker_id": peer_a_id,
181:             "peer_udp_ip": peer_a_data["stun_reported_udp_ip"],
182:             "peer_udp_port": peer_a_data["stun_reported_udp_port"]
183:         }
184:         offer_to_a_payload = { 
185:             "type": "p2p_connection_offer",
186:             "peer_worker_id": peer_b_id,
187:             "peer_udp_ip": peer_b_data["stun_reported_udp_ip"],
188:             "peer_udp_port": peer_b_data["stun_reported_udp_port"]
189:         }
190: 
191:         try:
192:             # Send B's info to A
193:             # No need to check ws.client_state again due to comprehensive check above, but doesn't hurt.
194:             await peer_a_ws.send_text(json.dumps(offer_to_a_payload))
195:             print(f"Rendezvous: Sent connection offer to Worker '{peer_a_id}' (for peer '{peer_b_id}').")
196: 
197:             # Send A's info to B
198:             await peer_b_ws.send_text(json.dumps(offer_to_b_payload))
199:             print(f"Rendezvous: Sent connection offer to Worker '{peer_b_id}' (for peer '{peer_a_id}').")
200:         except Exception as e:
201:             print(f"Rendezvous: Error sending P2P connection offers: {e}")
202:     else:
203:         print(f"Rendezvous: No suitable peer found in ready_for_pairing list for newly ready worker '{newly_ready_worker_id}'.")
204: 
205: async def manual_pair_workers(worker_a_id: str, worker_b_id: str) -> bool:
206:     """Manually pair two specific workers. Returns True if successful."""
207:     global connected_workers
208:     
209:     # Get worker data
210:     worker_a_data = connected_workers.get(worker_a_id)
211:     worker_b_data = connected_workers.get(worker_b_id)
212:     
213:     # Validate both workers exist and have necessary data
214:     if not worker_a_data:
215:         raise HTTPException(status_code=404, detail=f"Worker '{worker_a_id}' not found")
216:     if not worker_b_data:
217:         raise HTTPException(status_code=404, detail=f"Worker '{worker_b_id}' not found")
218:     
219:     # Check WebSocket connections
220:     if not (worker_a_data.get("websocket") and hasattr(worker_a_data["websocket"], 'client_state') 
221:             and worker_a_data["websocket"].client_state.value == 1):
222:         raise HTTPException(status_code=400, detail=f"Worker '{worker_a_id}' WebSocket not connected")
223:     if not (worker_b_data.get("websocket") and hasattr(worker_b_data["websocket"], 'client_state') 
224:             and worker_b_data["websocket"].client_state.value == 1):
225:         raise HTTPException(status_code=400, detail=f"Worker '{worker_b_id}' WebSocket not connected")
226:     
227:     # Check UDP endpoints
228:     if not (worker_a_data.get("stun_reported_udp_ip") and worker_a_data.get("stun_reported_udp_port")):
229:         raise HTTPException(status_code=400, detail=f"Worker '{worker_a_id}' UDP endpoint not available")
230:     if not (worker_b_data.get("stun_reported_udp_ip") and worker_b_data.get("stun_reported_udp_port")):
231:         raise HTTPException(status_code=400, detail=f"Worker '{worker_b_id}' UDP endpoint not available")
232:     
233:     # Send connection offers
234:     try:
235:         # Prepare offers
236:         offer_to_a = {
237:             "type": "p2p_connection_offer",
238:             "peer_worker_id": worker_b_id,
239:             "peer_udp_ip": worker_b_data["stun_reported_udp_ip"],
240:             "peer_udp_port": worker_b_data["stun_reported_udp_port"]
241:         }
242:         offer_to_b = {
243:             "type": "p2p_connection_offer", 
244:             "peer_worker_id": worker_a_id,
245:             "peer_udp_ip": worker_a_data["stun_reported_udp_ip"],
246:             "peer_udp_port": worker_a_data["stun_reported_udp_port"]
247:         }
248:         
249:         # Send offers
250:         await worker_a_data["websocket"].send_text(json.dumps(offer_to_a))
251:         print(f"Manual pairing: Sent connection offer to Worker '{worker_a_id}' (for peer '{worker_b_id}')")
252:         
253:         await worker_b_data["websocket"].send_text(json.dumps(offer_to_b))
254:         print(f"Manual pairing: Sent connection offer to Worker '{worker_b_id}' (for peer '{worker_a_id}')")
255:         
256:         return True
257:         
258:     except Exception as e:
259:         print(f"Manual pairing: Error sending connection offers: {e}")
260:         raise HTTPException(status_code=500, detail=f"Failed to send connection offers: {str(e)}")
261: 
262: @app.websocket("/ws/register/{worker_id}")
263: async def websocket_register_worker(websocket: WebSocket, worker_id: str):
264:     global connected_workers, workers_ready_for_pairing
265:     await websocket.accept()
266:     client_host = websocket.client.host 
267:     client_port = websocket.client.port 
268:     
269:     print(f"Worker '{worker_id}' connecting from WebSocket endpoint: {client_host}:{client_port}")
270: 
271:     if worker_id in connected_workers:
272:         print(f"Worker '{worker_id}' re-connecting or duplicate ID detected.")
273:         old_ws_data = connected_workers.get(worker_id)
274:         if old_ws_data:
275:             old_ws = old_ws_data.get("websocket")
276:             if old_ws and hasattr(old_ws, 'client_state') and old_ws.client_state.value == 1:
277:                  try: await old_ws.close(code=1012, reason="New connection from same worker ID / Service Restarting")
278:                  except Exception: pass
279:         if worker_id in workers_ready_for_pairing: 
280:             workers_ready_for_pairing.remove(worker_id)
281: 
282:     connected_workers[worker_id] = {
283:         "websocket_observed_ip": client_host, 
284:         "websocket_observed_port": client_port, 
285:         "websocket": websocket,
286:         "stun_reported_udp_ip": None, 
287:         "stun_reported_udp_port": None,
288:         "http_reported_public_ip": None # Field for general public IP
289:     }
290:     print(f"Worker '{worker_id}' registered. WebSocket EP: {client_host}:{client_port}. Total: {len(connected_workers)}")
291:     
292:     # Broadcast worker connected event
293:     await broadcast_to_admin_clients({
294:         "type": "worker_connected",
295:         "worker_id": worker_id,
296:         "websocket_ip": client_host,
297:         "websocket_port": client_port,
298:         "total_workers": len(connected_workers)
299:     })
300: 
301:     try:
302:         while True: 
303:             raw_data = await websocket.receive_text()
304:             print(f"Rendezvous: Received raw message from '{worker_id}': {raw_data}")
305:             try:
306:                 message = json.loads(raw_data)
307:                 msg_type = message.get("type")
308: 
309:                 if msg_type == "register_public_ip":
310:                     new_ip = message.get("ip")
311:                     if new_ip and worker_id in connected_workers:
312:                         connected_workers[worker_id]["http_reported_public_ip"] = new_ip 
313:                         print(f"Worker '{worker_id}' reported HTTP-based public IP: {new_ip}")
314:                 
315:                 elif msg_type == "update_udp_endpoint":
316:                     udp_ip = message.get("udp_ip")
317:                     udp_port = message.get("udp_port")
318:                     if udp_ip and udp_port and worker_id in connected_workers:
319:                         connected_workers[worker_id]["stun_reported_udp_ip"] = udp_ip
320:                         connected_workers[worker_id]["stun_reported_udp_port"] = int(udp_port)
321:                         print(f"Worker '{worker_id}' updated STUN UDP endpoint to: {udp_ip}:{udp_port}")
322:                         await websocket.send_text(json.dumps({"type": "udp_endpoint_ack", "status": "success"}))
323:                         # Broadcast UDP endpoint update
324:                         await broadcast_to_admin_clients({
325:                             "type": "worker_udp_updated",
326:                             "worker_id": worker_id,
327:                             "udp_ip": udp_ip,
328:                             "udp_port": udp_port
329:                         })
330:                         await attempt_to_pair_workers(worker_id)
331:                     else:
332:                         await websocket.send_text(json.dumps({"type": "udp_endpoint_ack", "status": "error", "detail": "Missing IP or Port"}))
333:                 
334:                 elif msg_type == "echo_request": 
335:                     payload = message.get("payload", "")
336:                     await websocket.send_text(json.dumps({
337:                         "type": "echo_response",
338:                         "original_payload": payload,
339:                         "processed_by_rendezvous": f"Rendezvous processed: '{payload.upper()}' for worker {worker_id}"
340:                     }))
341:                 
342:                 elif msg_type == "chat_response":
343:                     # Worker is responding to admin chat
344:                     admin_session_id = message.get("admin_session_id")
345:                     chat_content = message.get("content")
346:                     if admin_session_id and chat_content:
347:                         # Forward to the appropriate admin chat session
348:                         if admin_session_id in chat_sessions and worker_id in chat_sessions[admin_session_id]:
349:                             admin_ws = chat_sessions[admin_session_id][worker_id]
350:                             try:
351:                                 await admin_ws.send_text(json.dumps({
352:                                     "type": "chat_message",
353:                                     "from": "worker",
354:                                     "worker_id": worker_id,
355:                                     "content": chat_content,
356:                                     "timestamp": asyncio.get_event_loop().time()
357:                                 }))
358:                             except Exception as e:
359:                                 print(f"Error forwarding chat to admin: {e}")
360:                 
361:                 else:
362:                     print(f"Rendezvous: Worker '{worker_id}' sent unhandled message type: {msg_type}")
363: 
364:             except json.JSONDecodeError: print(f"Rendezvous: Worker '{worker_id}' sent non-JSON: {raw_data}")
365:             except AttributeError: print(f"Rendezvous: Worker '{worker_id}' sent malformed JSON: {raw_data}")
366:             except KeyError: print(f"Rendezvous: Worker '{worker_id}' no longer in dict.")
367: 
368:     except WebSocketDisconnect:
369:         print(f"Worker '{worker_id}' disconnected from WebSocket EP: {client_host}:{client_port}.")
370:     except Exception as e:
371:         print(f"Error with worker '{worker_id}' WebSocket: {e}")
372:     finally:
373:         if worker_id in connected_workers and connected_workers[worker_id].get("websocket") == websocket:
374:             del connected_workers[worker_id]
375:             print(f"Worker '{worker_id}' de-registered. Total: {len(connected_workers)}")
376:             # Broadcast worker disconnected event
377:             await broadcast_to_admin_clients({
378:                 "type": "worker_disconnected",
379:                 "worker_id": worker_id,
380:                 "total_workers": len(connected_workers)
381:             })
382:         if worker_id in workers_ready_for_pairing: 
383:             workers_ready_for_pairing.remove(worker_id)
384:             print(f"Worker '{worker_id}' removed from pending pairing list due to disconnect.")
385: 
386: @app.get("/")
387: async def read_root():
388:     return {"message": "Rendezvous Service is running. Test."}
389: 
390: @app.get("/admin")
391: async def admin_ui():
392:     """Serve the admin UI HTML page"""
393:     admin_html_path = Path(__file__).parent / "admin.html"
394:     if admin_html_path.exists():
395:         with open(admin_html_path, "r") as f:
396:             html_content = f.read()
397:         return HTMLResponse(content=html_content)
398:     else:
399:         return HTMLResponse(content="<h1>Admin UI not found</h1>", status_code=404)
400: 
401: @app.get("/admin/chat")
402: async def admin_chat_ui():
403:     """Serve the admin chat UI HTML page"""
404:     chat_html_path = Path(__file__).parent / "admin-chat.html"
405:     if chat_html_path.exists():
406:         with open(chat_html_path, "r") as f:
407:             html_content = f.read()
408:         return HTMLResponse(content=html_content)
409:     else:
410:         return HTMLResponse(content="<h1>Admin Chat UI not found</h1>", status_code=404)
411: 
412: @app.get("/debug/list_workers")
413: async def list_workers():
414:     workers_info = {}
415:     for worker_id_key, data_val in list(connected_workers.items()):
416:         ws_object = data_val.get("websocket")
417:         is_connected = False
418:         if ws_object and hasattr(ws_object, 'client_state') and ws_object.client_state.value == 1:
419:             is_connected = True
420:         
421:         workers_info[worker_id_key] = {
422:             "websocket_observed_ip": data_val.get("websocket_observed_ip"),
423:             "websocket_observed_port": data_val.get("websocket_observed_port"),
424:             "http_reported_public_ip": data_val.get("http_reported_public_ip"),
425:             "stun_reported_udp_ip": data_val.get("stun_reported_udp_ip"),
426:             "stun_reported_udp_port": data_val.get("stun_reported_udp_port"),
427:             "websocket_connected": is_connected
428:         }
429:     return {"connected_workers_count": len(workers_info), "workers": workers_info, "ready_for_pairing_count": len(workers_ready_for_pairing), "ready_list": workers_ready_for_pairing}
430: 
431: @app.get("/api/workers")
432: async def api_list_workers():
433:     """API endpoint for listing all connected workers with their status"""
434:     workers_list = []
435:     for worker_id, data in connected_workers.items():
436:         ws_object = data.get("websocket")
437:         is_connected = False
438:         if ws_object and hasattr(ws_object, 'client_state') and ws_object.client_state.value == 1:
439:             is_connected = True
440:         
441:         # Check if worker has valid UDP endpoint
442:         has_udp = bool(data.get("stun_reported_udp_ip") and data.get("stun_reported_udp_port"))
443:         
444:         # Check if worker is ready for pairing
445:         is_ready = worker_id in workers_ready_for_pairing
446:         
447:         workers_list.append({
448:             "worker_id": worker_id,
449:             "websocket_connected": is_connected,
450:             "has_udp_endpoint": has_udp,
451:             "ready_for_pairing": is_ready,
452:             "websocket_ip": data.get("websocket_observed_ip"),
453:             "websocket_port": data.get("websocket_observed_port"),
454:             "public_ip": data.get("http_reported_public_ip"),
455:             "udp_ip": data.get("stun_reported_udp_ip"),
456:             "udp_port": data.get("stun_reported_udp_port")
457:         })
458:     
459:     return {
460:         "workers": workers_list,
461:         "total_count": len(workers_list),
462:         "connected_count": sum(1 for w in workers_list if w["websocket_connected"]),
463:         "ready_count": len(workers_ready_for_pairing)
464:     }
465: 
466: @app.post("/api/connect")
467: async def connect_workers(request: ConnectionRequest):
468:     """Manually connect two specific workers"""
469:     if request.worker_a_id == request.worker_b_id:
470:         raise HTTPException(status_code=400, detail="Cannot connect a worker to itself")
471:     
472:     try:
473:         success = await manual_pair_workers(request.worker_a_id, request.worker_b_id)
474:         # Broadcast connection event to admin clients
475:         await broadcast_to_admin_clients({
476:             "type": "connection_initiated",
477:             "worker_a_id": request.worker_a_id,
478:             "worker_b_id": request.worker_b_id,
479:             "timestamp": asyncio.get_event_loop().time()
480:         })
481:         return {
482:             "success": success,
483:             "message": f"Connection initiated between {request.worker_a_id} and {request.worker_b_id}"
484:         }
485:     except HTTPException:
486:         raise
487:     except Exception as e:
488:         raise HTTPException(status_code=500, detail=str(e))
489: 
490: @app.websocket("/ws/admin")
491: async def admin_websocket_endpoint(websocket: WebSocket):
492:     """WebSocket endpoint for admin UI real-time updates"""
493:     global admin_websocket_clients
494:     await websocket.accept()
495:     admin_websocket_clients.append(websocket)
496:     
497:     print(f"Admin WebSocket client connected. Total admin clients: {len(admin_websocket_clients)}")
498:     
499:     try:
500:         # Send initial state
501:         await websocket.send_text(json.dumps({
502:             "type": "connected",
503:             "message": "Connected to admin WebSocket"
504:         }))
505:         
506:         # Keep connection alive and wait for messages
507:         while True:
508:             try:
509:                 # Wait for any message from client (for ping/pong)
510:                 data = await websocket.receive_text()
511:                 # Echo back for now
512:                 if data == "ping":
513:                     await websocket.send_text(json.dumps({"type": "pong"}))
514:             except WebSocketDisconnect:
515:                 break
516:                 
517:     except Exception as e:
518:         print(f"Error in admin WebSocket: {e}")
519:     finally:
520:         if websocket in admin_websocket_clients:
521:             admin_websocket_clients.remove(websocket)
522:         print(f"Admin WebSocket client disconnected. Total admin clients: {len(admin_websocket_clients)}")
523: 
524: @app.websocket("/ws/chat/{admin_session_id}/{worker_id}")
525: async def chat_websocket_endpoint(websocket: WebSocket, admin_session_id: str, worker_id: str):
526:     """WebSocket endpoint for admin to chat with a specific worker"""
527:     global chat_sessions, connected_workers
528:     
529:     # Verify worker exists and is connected
530:     if worker_id not in connected_workers:
531:         await websocket.close(code=1008, reason="Worker not found")
532:         return
533:     
534:     worker_data = connected_workers[worker_id]
535:     if not (worker_data.get("websocket") and hasattr(worker_data["websocket"], 'client_state') 
536:             and worker_data["websocket"].client_state.value == 1):
537:         await websocket.close(code=1008, reason="Worker not connected")
538:         return
539:     
540:     await websocket.accept()
541:     
542:     # Store the chat session
543:     if admin_session_id not in chat_sessions:
544:         chat_sessions[admin_session_id] = {}
545:     chat_sessions[admin_session_id][worker_id] = websocket
546:     
547:     print(f"Admin chat session '{admin_session_id}' connected to worker '{worker_id}'")
548:     
549:     # Send initial connection message
550:     await websocket.send_text(json.dumps({
551:         "type": "chat_connected",
552:         "worker_id": worker_id,
553:         "message": f"Connected to worker {worker_id}"
554:     }))
555:     
556:     try:
557:         while True:
558:             try:
559:                 # Receive message from admin
560:                 data = await websocket.receive_text()
561:                 message = json.loads(data)
562:                 
563:                 if message.get("type") == "chat_message":
564:                     content = message.get("content")
565:                     if content and worker_id in connected_workers:
566:                         worker_ws = connected_workers[worker_id].get("websocket")
567:                         if worker_ws:
568:                             # Forward message to worker
569:                             await worker_ws.send_text(json.dumps({
570:                                 "type": "admin_chat_message",
571:                                 "admin_session_id": admin_session_id,
572:                                 "content": content
573:                             }))
574:                             
575:                             # Echo back to admin with timestamp
576:                             await websocket.send_text(json.dumps({
577:                                 "type": "chat_message",
578:                                 "from": "admin",
579:                                 "content": content,
580:                                 "timestamp": asyncio.get_event_loop().time()
581:                             }))
582:                         else:
583:                             await websocket.send_text(json.dumps({
584:                                 "type": "error",
585:                                 "message": "Worker disconnected"
586:                             }))
587:                             break
588:                             
589:             except WebSocketDisconnect:
590:                 break
591:             except json.JSONDecodeError:
592:                 await websocket.send_text(json.dumps({
593:                     "type": "error",
594:                     "message": "Invalid message format"
595:                 }))
596:                 
597:     except Exception as e:
598:         print(f"Error in chat session '{admin_session_id}' with worker '{worker_id}': {e}")
599:     finally:
600:         # Clean up chat session
601:         if admin_session_id in chat_sessions and worker_id in chat_sessions[admin_session_id]:
602:             del chat_sessions[admin_session_id][worker_id]
603:             if not chat_sessions[admin_session_id]:  # Remove empty session dict
604:                 del chat_sessions[admin_session_id]
605:         print(f"Admin chat session '{admin_session_id}' disconnected from worker '{worker_id}'")
606: 
607: if __name__ == "__main__":
608:     uvicorn.run(app, host="0.0.0.0", port=int(os.environ.get("PORT", 8080)), log_level="trace")
</file>

<file path="rendezvous_service_code/models.py">
 1: """
 2: Data models and shared state for the rendezvous service
 3: """
 4: from pydantic import BaseModel
 5: from typing import Dict, List, Optional
 6: from fastapi import WebSocket
 7: 
 8: 
 9: # Pydantic models for API requests
10: class ConnectionRequest(BaseModel):
11:     worker_a_id: str
12:     worker_b_id: str
13: 
14: 
15: class ChatMessage(BaseModel):
16:     content: str
17:     worker_id: str
18: 
19: 
20: # Global state containers
21: class ServiceState:
22:     """Container for all service state"""
23:     def __init__(self):
24:         # connected_workers structure:
25:         # { worker_id: { "websocket_observed_ip": ..., "websocket_observed_port": ...,
26:         #                "websocket": WebSocket, 
27:         #                "stun_reported_udp_ip": ..., "stun_reported_udp_port": ...,
28:         #                "http_reported_public_ip": ... # Optional
29:         #              }}
30:         self.connected_workers: Dict[str, Dict] = {}
31:         
32:         # List of worker_ids that have reported UDP info and are waiting for a peer
33:         self.workers_ready_for_pairing: List[str] = []
34:         
35:         # Admin UI WebSocket clients
36:         self.admin_websocket_clients: List[WebSocket] = []
37:         
38:         # Chat sessions: admin_id -> worker_id -> websocket
39:         self.chat_sessions: Dict[str, Dict[str, WebSocket]] = {}
40: 
41: 
42: # Create a global instance
43: service_state = ServiceState()
</file>

<file path="rendezvous_service_code/pairing.py">
  1: """
  2: Worker pairing logic for P2P connections
  3: """
  4: import asyncio
  5: import json
  6: from typing import Optional
  7: from fastapi import HTTPException
  8: 
  9: from models import service_state
 10: 
 11: 
 12: async def attempt_to_pair_workers(newly_ready_worker_id: str):
 13:     """Attempt to pair a newly ready worker with another available worker"""
 14:     # Ensure the worker trying to pair is valid and has WebSocket
 15:     newly_ready_worker_data = service_state.connected_workers.get(newly_ready_worker_id)
 16:     if not (newly_ready_worker_data and newly_ready_worker_data.get("stun_reported_udp_ip") and 
 17:             newly_ready_worker_data.get("websocket") and 
 18:             hasattr(newly_ready_worker_data["websocket"], 'client_state') and 
 19:             newly_ready_worker_data["websocket"].client_state.value == 1):
 20:         print(f"Pairing: Newly ready worker '{newly_ready_worker_id}' is not valid, lacks UDP info, or WebSocket is disconnected. Cannot initiate pairing.")
 21:         if newly_ready_worker_id in service_state.workers_ready_for_pairing:
 22:             service_state.workers_ready_for_pairing.remove(newly_ready_worker_id)
 23:         # Also ensure it's removed from connected_workers if its WebSocket is truly gone or invalid
 24:         if newly_ready_worker_id in service_state.connected_workers and (not newly_ready_worker_data or not newly_ready_worker_data.get("websocket") or 
 25:                                                         not hasattr(newly_ready_worker_data.get("websocket"), 'client_state') or
 26:                                                         newly_ready_worker_data.get("websocket").client_state.value != 1):
 27:             del service_state.connected_workers[newly_ready_worker_id]
 28:             print(f"Cleaned up disconnected newly_ready_worker_id '{newly_ready_worker_id}' from connected_workers.")
 29:         return
 30: 
 31:     if newly_ready_worker_id not in service_state.workers_ready_for_pairing:
 32:         service_state.workers_ready_for_pairing.append(newly_ready_worker_id)
 33:         print(f"Rendezvous: Worker '{newly_ready_worker_id}' added to ready_for_pairing list. Current list: {service_state.workers_ready_for_pairing}")
 34: 
 35:     if len(service_state.workers_ready_for_pairing) < 2:
 36:         print(f"Rendezvous: Not enough workers ready for pairing ({len(service_state.workers_ready_for_pairing)}). Waiting for more.")
 37:         return
 38: 
 39:     peer_a_id = None
 40:     peer_b_id = None
 41:     
 42:     # Create a copy of the list to iterate over, allowing modification of the original
 43:     candidate_ids = list(service_state.workers_ready_for_pairing)
 44:     
 45:     # Expand candidate list to include other connected workers that have
 46:     # valid UDP info and active WebSocket
 47:     extra_candidates = [wid for wid, wdata in service_state.connected_workers.items()
 48:                         if wid not in service_state.workers_ready_for_pairing
 49:                         and wid != newly_ready_worker_id
 50:                         and wdata.get("stun_reported_udp_ip")
 51:                         and wdata.get("stun_reported_udp_port")
 52:                         and wdata.get("websocket")
 53:                         and hasattr(wdata["websocket"], 'client_state')
 54:                         and wdata["websocket"].client_state.value == 1]
 55:     if extra_candidates:
 56:         print(f"Rendezvous: Found {len(extra_candidates)} additional connected worker(s) with UDP info that were not in ready list: {extra_candidates}")
 57:         candidate_ids.extend(extra_candidates)
 58:     
 59:     for worker_id in candidate_ids:
 60:         worker_data = service_state.connected_workers.get(worker_id)
 61:         # Check if worker is still valid and its WebSocket is connected
 62:         if not (worker_data and worker_data.get("stun_reported_udp_ip") and 
 63:                 worker_data.get("websocket") and 
 64:                 hasattr(worker_data["websocket"], 'client_state') and 
 65:                 worker_data["websocket"].client_state.value == 1):
 66:             
 67:             print(f"Pairing: Worker '{worker_id}' in ready_list is stale or disconnected. Removing.")
 68:             if worker_id in service_state.workers_ready_for_pairing:
 69:                 service_state.workers_ready_for_pairing.remove(worker_id)
 70:             if worker_id in service_state.connected_workers:
 71:                 current_ws_state_in_dict = service_state.connected_workers[worker_id].get("websocket")
 72:                 if not current_ws_state_in_dict or not hasattr(current_ws_state_in_dict, 'client_state') or current_ws_state_in_dict.client_state.value != 1 :
 73:                     del service_state.connected_workers[worker_id]
 74:                     print(f"Cleaned up stale worker '{worker_id}' from connected_workers during pairing attempt.")
 75:             continue
 76: 
 77:         # Worker is valid, try to find a peer for it
 78:         if peer_a_id is None:
 79:             peer_a_id = worker_id
 80:         elif peer_a_id != worker_id:
 81:             peer_b_id = worker_id
 82:             break
 83: 
 84:     if peer_a_id and peer_b_id:
 85:         # Selected pair: peer_a_id, peer_b_id
 86:         print(f"Rendezvous: Attempting to pair Worker '{peer_a_id}' with Worker '{peer_b_id}'.")
 87: 
 88:         peer_a_data = service_state.connected_workers.get(peer_a_id)
 89:         peer_b_data = service_state.connected_workers.get(peer_b_id)
 90: 
 91:         # Final check for data integrity and WebSocket state before sending offers
 92:         if not (peer_a_data and peer_b_data and
 93:                 peer_a_data.get("stun_reported_udp_ip") and peer_a_data.get("stun_reported_udp_port") and
 94:                 peer_b_data.get("stun_reported_udp_ip") and peer_b_data.get("stun_reported_udp_port") and
 95:                 peer_a_data.get("websocket") and hasattr(peer_a_data["websocket"], 'client_state') and peer_a_data["websocket"].client_state.value == 1 and
 96:                 peer_b_data.get("websocket") and hasattr(peer_b_data["websocket"], 'client_state') and peer_b_data["websocket"].client_state.value == 1):
 97:             
 98:             print(f"Pairing Error: Post-selection data integrity or WebSocket issue for {peer_a_id} or {peer_b_id}. Aborting this pair.")
 99:             for p_id in [peer_a_id, peer_b_id]:
100:                 p_data = service_state.connected_workers.get(p_id)
101:                 if p_data and (not p_data.get("websocket") or not hasattr(p_data["websocket"], 'client_state') or p_data["websocket"].client_state.value != 1):
102:                     if p_id in service_state.workers_ready_for_pairing: 
103:                         service_state.workers_ready_for_pairing.remove(p_id)
104:                     if p_id in service_state.connected_workers: 
105:                         del service_state.connected_workers[p_id]
106:                     print(f"Cleaned up disconnected peer '{p_id}' after failed pairing integrity check.")
107:             return
108: 
109:         # If all checks passed, remove from ready list and send offers
110:         if peer_a_id in service_state.workers_ready_for_pairing: 
111:             service_state.workers_ready_for_pairing.remove(peer_a_id)
112:         if peer_b_id in service_state.workers_ready_for_pairing: 
113:             service_state.workers_ready_for_pairing.remove(peer_b_id)
114:         print(f"Rendezvous: Removed '{peer_a_id}' and '{peer_b_id}' from ready_for_pairing. Updated list: {service_state.workers_ready_for_pairing}")
115: 
116:         peer_a_ws = peer_a_data["websocket"]
117:         peer_b_ws = peer_b_data["websocket"]
118: 
119:         offer_to_b_payload = { 
120:             "type": "p2p_connection_offer",
121:             "peer_worker_id": peer_a_id,
122:             "peer_udp_ip": peer_a_data["stun_reported_udp_ip"],
123:             "peer_udp_port": peer_a_data["stun_reported_udp_port"]
124:         }
125:         offer_to_a_payload = { 
126:             "type": "p2p_connection_offer",
127:             "peer_worker_id": peer_b_id,
128:             "peer_udp_ip": peer_b_data["stun_reported_udp_ip"],
129:             "peer_udp_port": peer_b_data["stun_reported_udp_port"]
130:         }
131: 
132:         try:
133:             await peer_a_ws.send_text(json.dumps(offer_to_a_payload))
134:             print(f"Rendezvous: Sent connection offer to Worker '{peer_a_id}' (for peer '{peer_b_id}').")
135: 
136:             await peer_b_ws.send_text(json.dumps(offer_to_b_payload))
137:             print(f"Rendezvous: Sent connection offer to Worker '{peer_b_id}' (for peer '{peer_a_id}').")
138:         except Exception as e:
139:             print(f"Rendezvous: Error sending P2P connection offers: {e}")
140:     else:
141:         print(f"Rendezvous: No suitable peer found in ready_for_pairing list for newly ready worker '{newly_ready_worker_id}'.")
142: 
143: 
144: async def manual_pair_workers(worker_a_id: str, worker_b_id: str) -> bool:
145:     """Manually pair two specific workers. Returns True if successful."""
146:     # Get worker data
147:     worker_a_data = service_state.connected_workers.get(worker_a_id)
148:     worker_b_data = service_state.connected_workers.get(worker_b_id)
149:     
150:     # Validate both workers exist and have necessary data
151:     if not worker_a_data:
152:         raise HTTPException(status_code=404, detail=f"Worker '{worker_a_id}' not found")
153:     if not worker_b_data:
154:         raise HTTPException(status_code=404, detail=f"Worker '{worker_b_id}' not found")
155:     
156:     # Check WebSocket connections
157:     if not (worker_a_data.get("websocket") and hasattr(worker_a_data["websocket"], 'client_state') 
158:             and worker_a_data["websocket"].client_state.value == 1):
159:         raise HTTPException(status_code=400, detail=f"Worker '{worker_a_id}' WebSocket not connected")
160:     if not (worker_b_data.get("websocket") and hasattr(worker_b_data["websocket"], 'client_state') 
161:             and worker_b_data["websocket"].client_state.value == 1):
162:         raise HTTPException(status_code=400, detail=f"Worker '{worker_b_id}' WebSocket not connected")
163:     
164:     # Check UDP endpoints
165:     if not (worker_a_data.get("stun_reported_udp_ip") and worker_a_data.get("stun_reported_udp_port")):
166:         raise HTTPException(status_code=400, detail=f"Worker '{worker_a_id}' UDP endpoint not available")
167:     if not (worker_b_data.get("stun_reported_udp_ip") and worker_b_data.get("stun_reported_udp_port")):
168:         raise HTTPException(status_code=400, detail=f"Worker '{worker_b_id}' UDP endpoint not available")
169:     
170:     # Send connection offers
171:     try:
172:         # Prepare offers
173:         offer_to_a = {
174:             "type": "p2p_connection_offer",
175:             "peer_worker_id": worker_b_id,
176:             "peer_udp_ip": worker_b_data["stun_reported_udp_ip"],
177:             "peer_udp_port": worker_b_data["stun_reported_udp_port"]
178:         }
179:         offer_to_b = {
180:             "type": "p2p_connection_offer", 
181:             "peer_worker_id": worker_a_id,
182:             "peer_udp_ip": worker_a_data["stun_reported_udp_ip"],
183:             "peer_udp_port": worker_a_data["stun_reported_udp_port"]
184:         }
185:         
186:         # Send offers
187:         await worker_a_data["websocket"].send_text(json.dumps(offer_to_a))
188:         print(f"Manual pairing: Sent connection offer to Worker '{worker_a_id}' (for peer '{worker_b_id}')")
189:         
190:         await worker_b_data["websocket"].send_text(json.dumps(offer_to_b))
191:         print(f"Manual pairing: Sent connection offer to Worker '{worker_b_id}' (for peer '{worker_a_id}')")
192:         
193:         return True
194:         
195:     except Exception as e:
196:         print(f"Manual pairing: Error sending connection offers: {e}")
197:         raise HTTPException(status_code=500, detail=f"Failed to send connection offers: {str(e)}")
</file>

<file path="rendezvous_service_code/README.md">
 1: # Rendezvous Service - Refactored Structure
 2: 
 3: This service facilitates P2P connections between workers and provides admin interfaces for monitoring and control.
 4: 
 5: ## Project Structure
 6: 
 7: ```
 8: rendezvous_service_code/
 9: ├── main.py                 # Main FastAPI application and entry point
10: ├── models.py              # Data models and shared state
11: ├── worker_websocket.py    # WebSocket handler for worker connections
12: ├── admin_websocket.py     # WebSocket handlers for admin UI and chat
13: ├── api_endpoints.py       # REST API endpoints
14: ├── pairing.py            # Worker pairing logic
15: ├── broadcast.py          # Broadcasting utilities
16: ├── admin.html            # Admin dashboard UI
17: ├── admin-chat.html       # Admin chat interface
18: └── requirements.txt      # Python dependencies
19: ```
20: 
21: ## Module Descriptions
22: 
23: ### main.py
24: - FastAPI application setup
25: - Route registration
26: - CORS configuration
27: - Application entry point
28: 
29: ### models.py
30: - Pydantic models for API requests
31: - ServiceState class containing all global state
32: - Shared data structures
33: 
34: ### worker_websocket.py
35: - Handles worker WebSocket connections
36: - Processes worker messages (UDP updates, chat responses)
37: - Manages worker registration/deregistration
38: 
39: ### admin_websocket.py
40: - Admin UI WebSocket for real-time updates
41: - Chat WebSocket for admin-to-worker communication
42: 
43: ### api_endpoints.py
44: - REST endpoints for worker listing
45: - Manual connection control
46: - Static file serving for admin UIs
47: 
48: ### pairing.py
49: - Automatic worker pairing logic
50: - Manual pairing functionality
51: - Connection validation
52: 
53: ### broadcast.py
54: - Utility functions for broadcasting to admin clients
55: 
56: ## Key Features
57: 
58: 1. **Worker Management**
59:    - Real-time worker status tracking
60:    - UDP endpoint discovery via STUN
61:    - Automatic and manual pairing
62: 
63: 2. **Admin Dashboard** (`/admin`)
64:    - Live worker status
65:    - Manual connection control
66:    - Event logging
67: 
68: 3. **Admin Chat** (`/admin/chat`)
69:    - Direct communication with workers
70:    - Real-time messaging
71:    - Message history
72: 
73: ## API Endpoints
74: 
75: - `GET /` - Health check
76: - `GET /admin` - Admin dashboard
77: - `GET /admin/chat` - Chat interface
78: - `GET /api/workers` - List all workers
79: - `POST /api/connect` - Manually connect two workers
80: - `WS /ws/register/{worker_id}` - Worker WebSocket
81: - `WS /ws/admin` - Admin updates WebSocket
82: - `WS /ws/chat/{admin_session_id}/{worker_id}` - Chat WebSocket
83: 
84: ## Running the Service
85: 
86: ```bash
87: python main.py
88: ```
89: 
90: Or with Docker:
91: ```bash
92: docker build -f Dockerfile.rendezvous -t rendezvous-service .
93: docker run -p 8080:8080 rendezvous-service
94: ```
</file>

<file path="holepunch-go/pkg/p2p/protocol.go">
  1: package p2p
  2: 
  3: import (
  4: 	"encoding/base64"
  5: 	"encoding/json"
  6: 	"fmt"
  7: 	"log"
  8: 	"net"
  9: 	"strings"
 10: 	"sync"
 11: 	"time"
 12: 
 13: 	"github.com/elisilver/holepunch/pkg/models"
 14: 	"github.com/gorilla/websocket"
 15: )
 16: 
 17: type P2PProtocol struct {
 18: 	conn            *net.UDPConn
 19: 	state           *models.WorkerState
 20: 	messageHandlers map[string]MessageHandler
 21: 	mu              sync.RWMutex
 22: }
 23: 
 24: type MessageHandler func(msg *models.P2PMessage, addr *net.UDPAddr) error
 25: 
 26: func NewP2PProtocol(conn *net.UDPConn, state *models.WorkerState) *P2PProtocol {
 27: 	p := &P2PProtocol{
 28: 		conn:            conn,
 29: 		state:           state,
 30: 		messageHandlers: make(map[string]MessageHandler),
 31: 	}
 32: 
 33: 	p.registerHandlers()
 34: 	return p
 35: }
 36: 
 37: func (p *P2PProtocol) registerHandlers() {
 38: 	p.messageHandlers["chat_message"] = p.handleChatMessage
 39: 	p.messageHandlers["p2p_keep_alive"] = p.handleKeepAlive
 40: 	p.messageHandlers["p2p_pairing_test"] = p.handlePairingTest
 41: 	p.messageHandlers["p2p_pairing_echo"] = p.handlePairingEcho
 42: 	p.messageHandlers["benchmark_chunk"] = p.handleBenchmarkChunk
 43: 	p.messageHandlers["benchmark_end"] = p.handleBenchmarkEnd
 44: }
 45: 
 46: func (p *P2PProtocol) Start() {
 47: 	go p.readLoop()
 48: }
 49: 
 50: func (p *P2PProtocol) readLoop() {
 51: 	buffer := make([]byte, 65535)
 52: 
 53: 	log.Printf("P2P UDP Read: Starting readLoop for worker %s on %s", p.state.WorkerID, p.conn.LocalAddr().String())
 54: 
 55: 	for {
 56: 		n, addr, err := p.conn.ReadFromUDP(buffer)
 57: 		if addr != nil {
 58: 			log.Printf("P2P UDP Read: Raw packet received from %s on %s (Worker: %s)", addr.String(), p.conn.LocalAddr().String(), p.state.WorkerID)
 59: 		}
 60: 
 61: 		if err != nil {
 62: 			if strings.Contains(err.Error(), "use of closed network connection") {
 63: 				log.Printf("P2P UDP Read: Listener closed, exiting readLoop for worker %s.", p.state.WorkerID)
 64: 				return
 65: 			}
 66: 			log.Printf("P2P UDP Read: Error reading from UDP for worker %s: %v", p.state.WorkerID, err)
 67: 			continue
 68: 		}
 69: 
 70: 		messageStr := string(buffer[:n])
 71: 		log.Printf("P2P UDP Read: Received %d bytes from %s. Raw content: %s", n, addr.String(), messageStr)
 72: 
 73: 		if strings.Contains(messageStr, "P2P_PING_FROM_") {
 74: 			log.Printf("P2P UDP Read: Worker '%s': !!! P2P UDP Ping (legacy) received from %s !!!", p.state.WorkerID, addr.String())
 75: 			p.state.Mu.Lock()
 76: 			p.state.LastP2PMessageTime = time.Now()
 77: 			p.state.Mu.Unlock()
 78: 			continue
 79: 		}
 80: 
 81: 
 82: 		// Check if this might be a STUN response (from known STUN servers)
 83: 		if addr.Port == 19302 || addr.Port == 3478 {
 84: 			// This is likely a STUN response - ignore it
 85: 			log.Printf("P2P UDP Read: Ignoring STUN response from %s (%d bytes)", addr.String(), n)
 86: 			continue
 87: 		}
 88: 
 89: 		var msg models.P2PMessage
 90: 		if err := json.Unmarshal(buffer[:n], &msg); err != nil {
 91: 			log.Printf("P2P UDP Read: Failed to unmarshal P2P message from %s for worker %s. Error: %v. Raw: '%s'", addr.String(), p.state.WorkerID, err, messageStr)
 92: 			continue
 93: 		}
 94: 		log.Printf("P2P UDP Read: Successfully unmarshalled message type '%s' from %s (FromWorkerID: %s) for worker %s", msg.Type, addr.String(), msg.FromWorkerID, p.state.WorkerID)
 95: 
 96: 		p.state.Mu.Lock()
 97: 		p.state.LastP2PMessageTime = time.Now()
 98: 		p.state.Mu.Unlock()
 99: 
100: 		if handler, ok := p.messageHandlers[msg.Type]; ok {
101: 			if err := handler(&msg, addr); err != nil {
102: 				log.Printf("P2P UDP Read: Error in handler for message type '%s' from %s for worker %s: %v", msg.Type, addr.String(), p.state.WorkerID, err)
103: 			}
104: 		} else {
105: 			log.Printf("P2P UDP Read: Unknown P2P message type '%s' from %s for worker %s. Raw: '%s'", msg.Type, addr.String(), p.state.WorkerID, messageStr)
106: 		}
107: 	}
108: }
109: 
110: func (p *P2PProtocol) SendMessage(msgType string, payload map[string]interface{}, addr *net.UDPAddr) error {
111: 	msg := models.P2PMessage{
112: 		Type:         msgType,
113: 		FromWorkerID: p.state.WorkerID,
114: 		Payload:      payload,
115: 		Timestamp:    time.Now(),
116: 	}
117: 
118: 	data, err := json.Marshal(msg)
119: 	if err != nil {
120: 		log.Printf("P2P UDP Send: Failed to marshal message type '%s' for %s: %v", msgType, addr.String(), err)
121: 		return fmt.Errorf("failed to marshal message: %w", err)
122: 	}
123: 
124: 	n, err := p.conn.WriteToUDP(data, addr)
125: 	if err != nil {
126: 		log.Printf("P2P UDP Send: Failed to write UDP data for message type '%s' to %s: %v", msgType, addr.String(), err)
127: 		return err
128: 	}
129: 	log.Printf("P2P UDP Send: Successfully sent %d bytes of type '%s' (From: %s) to %s", n, msgType, p.state.WorkerID, addr.String())
130: 	return nil
131: }
132: 
133: func (p *P2PProtocol) handleChatMessage(msg *models.P2PMessage, addr *net.UDPAddr) error {
134: 	content, ok := msg.Payload["content"].(string)
135: 	if !ok {
136: 		log.Printf("P2P Chat: Invalid chat message format from %s for worker %s. Payload: %v", addr.String(), p.state.WorkerID, msg.Payload)
137: 		return fmt.Errorf("invalid chat message format")
138: 	}
139: 
140: 	log.Printf("P2P Chat: Worker %s received chat from %s (PeerWorkerID: %s): %s", p.state.WorkerID, addr.String(), msg.FromWorkerID, content)
141: 
142: 	p.state.Mu.RLock()
143: 	clients := make([]*websocket.Conn, len(p.state.UIWebsocketClients))
144: 	copy(clients, p.state.UIWebsocketClients)
145: 	p.state.Mu.RUnlock()
146: 
147: 	uiMsg := map[string]interface{}{
148: 		"type": "p2p_message_received",
149: 		"payload": map[string]interface{}{
150: 			"from_peer_id": msg.FromWorkerID,
151: 			"content":      content,
152: 		},
153: 	}
154: 
155: 	for _, client := range clients {
156: 		if client == nil {
157: 			log.Printf("P2P Chat: Worker %s found nil UI websocket client when trying to forward message from %s", p.state.WorkerID, msg.FromWorkerID)
158: 			continue
159: 		}
160: 		if err := client.WriteJSON(uiMsg); err != nil {
161: 			log.Printf("P2P Chat: Worker %s failed to forward chat message from %s to UI client %s: %v", p.state.WorkerID, msg.FromWorkerID, client.RemoteAddr(), err)
162: 		} else {
163: 			log.Printf("P2P Chat: Worker %s successfully forwarded chat message from %s to UI client %s", p.state.WorkerID, msg.FromWorkerID, client.RemoteAddr())
164: 		}
165: 	}
166: 
167: 	return nil
168: }
169: 
170: func (p *P2PProtocol) handleKeepAlive(msg *models.P2PMessage, addr *net.UDPAddr) error {
171: 	log.Printf("Received keep-alive from %s (WorkerID: %s)", addr, msg.FromWorkerID)
172: 	return nil
173: }
174: 
175: func (p *P2PProtocol) handlePairingTest(msg *models.P2PMessage, addr *net.UDPAddr) error {
176: 	timestampPayload, ok := msg.Payload["timestamp"].(float64)
177: 	if !ok {
178: 		timestampInt64, okInt := msg.Payload["timestamp"].(int64)
179: 		if !okInt {
180: 			return fmt.Errorf("invalid pairing test format: missing or invalid type for timestamp. Got: %T", msg.Payload["timestamp"])
181: 		}
182: 		timestampPayload = float64(timestampInt64)
183: 	}
184: 
185: 	log.Printf("Received pairing test from %s (WorkerID: %s, Timestamp: %v). Sending echo.", addr, msg.FromWorkerID, timestampPayload)
186: 
187: 	return p.SendMessage("p2p_pairing_echo", map[string]interface{}{
188: 		"original_timestamp": timestampPayload,
189: 	}, addr)
190: }
191: 
192: func (p *P2PProtocol) handlePairingEcho(msg *models.P2PMessage, addr *net.UDPAddr) error {
193: 	originalTimestampFloat, ok := msg.Payload["original_timestamp"].(float64)
194: 	if !ok {
195: 		return fmt.Errorf("invalid pairing echo format: missing or invalid original_timestamp. Got: %T", msg.Payload["original_timestamp"])
196: 	}
197: 
198: 	// Calculate RTT in milliseconds, matching Python's float arithmetic then convert
199: 	rttMs := ((float64(time.Now().UnixNano()) / 1e9) - originalTimestampFloat) * 1000.0
200: 	log.Printf("Pairing test with %s (WorkerID: %s) completed. RTT: %.2fms", addr, msg.FromWorkerID, rttMs)
201: 
202: 	p.state.Mu.RLock()
203: 	clients := p.state.UIWebsocketClients
204: 	p.state.Mu.RUnlock()
205: 
206: 	// Use message type that matches the UI expectation
207: 	uiMsg := map[string]interface{}{
208: 		"type": "pairing_test_result",
209: 		"payload": map[string]interface{}{
210: 			"success": true,
211: 			"rtt_ms":  rttMs, // Send as float64
212: 		},
213: 	}
214: 
215: 	for _, client := range clients {
216: 		if err := client.WriteJSON(uiMsg); err != nil {
217: 			log.Printf("Failed to send pairing test result to UI: %v", err)
218: 		}
219: 	}
220: 
221: 	return nil
222: }
223: 
224: func (p *P2PProtocol) handleBenchmarkChunk(msg *models.P2PMessage, addr *net.UDPAddr) error {
225: 	sessionID, ok := msg.Payload["session_id"].(string)
226: 	if !ok {
227: 		return fmt.Errorf("invalid benchmark chunk format: missing session_id")
228: 	}
229: 
230: 	// Extract seq number if present (for Python compatibility)
231: 	var seq int
232: 	if seqVal, ok := msg.Payload["seq"]; ok {
233: 		switch v := seqVal.(type) {
234: 		case float64:
235: 			seq = int(v)
236: 		case int:
237: 			seq = v
238: 		}
239: 	}
240: 
241: 	// Extract from_worker_id if present (for Python compatibility)
242: 	fromWorkerID, _ := msg.Payload["from_worker_id"].(string)
243: 
244: 	// Handle base64 encoded payload from Python-style implementation
245: 	payloadB64, ok := msg.Payload["payload"].(string)
246: 	if !ok {
247: 		return fmt.Errorf("invalid benchmark chunk format: missing payload string")
248: 	}
249: 	decodedPayload, err := base64.StdEncoding.DecodeString(payloadB64)
250: 	if err != nil {
251: 		return fmt.Errorf("failed to decode base64 benchmark payload: %w", err)
252: 	}
253: 	dataSize := len(decodedPayload) // Actual size after decode
254: 
255: 	p.state.Mu.Lock()
256: 	session, exists := p.state.BenchmarkSessions[sessionID]
257: 	if !exists {
258: 		session = &models.BenchmarkSession{
259: 			StartTime: time.Now(),
260: 			Active:    true,
261: 		}
262: 		p.state.BenchmarkSessions[sessionID] = session
263: 		log.Printf("Started new benchmark session %s from worker %s", sessionID, fromWorkerID)
264: 	}
265: 
266: 	session.BytesReceived += int64(dataSize)
267: 	session.ChunksReceived++
268: 	if seq > 0 && seq%100 == 0 { // Log progress every 100 chunks
269: 		log.Printf("Benchmark session %s: received chunk %d, total bytes: %d", sessionID, seq, session.BytesReceived)
270: 	}
271: 	p.state.Mu.Unlock()
272: 
273: 	return nil
274: }
275: 
276: func (p *P2PProtocol) handleBenchmarkEnd(msg *models.P2PMessage, addr *net.UDPAddr) error {
277: 	sessionID, ok := msg.Payload["session_id"].(string)
278: 	if !ok {
279: 		return fmt.Errorf("invalid benchmark end format")
280: 	}
281: 
282: 	// Extract total_chunks if present (for Python compatibility)
283: 	var totalChunks int
284: 	if tcVal, ok := msg.Payload["total_chunks"]; ok {
285: 		switch v := tcVal.(type) {
286: 		case float64:
287: 			totalChunks = int(v)
288: 		case int:
289: 			totalChunks = v
290: 		}
291: 	}
292: 
293: 	// Extract from_worker_id if present (for Python compatibility)
294: 	fromWorkerID, _ := msg.Payload["from_worker_id"].(string)
295: 
296: 	p.state.Mu.Lock()
297: 	session, exists := p.state.BenchmarkSessions[sessionID]
298: 	if exists {
299: 		session.Active = false
300: 		duration := time.Since(session.StartTime).Seconds()
301: 		throughput := float64(session.BytesReceived) / duration / 1024 / 1024
302: 
303: 		log.Printf("Benchmark %s completed: %.2f MB in %.2fs (%.2f MB/s) from worker %s (expected %d chunks, received %d)",
304: 			sessionID, float64(session.BytesReceived)/1024/1024, duration, throughput, 
305: 			fromWorkerID, totalChunks, session.ChunksReceived)
306: 
307: 		// Send results to UI
308: 		p.state.Mu.Unlock() // Unlock before sending to UI to avoid deadlock
309: 		
310: 		// Notify UI clients about benchmark completion
311: 		p.state.Mu.RLock()
312: 		clients := p.state.UIWebsocketClients
313: 		p.state.Mu.RUnlock()
314: 
315: 		uiMsg := map[string]interface{}{
316: 			"type": "benchmark_status",
317: 			"payload": map[string]interface{}{
318: 				"status":         "completed",
319: 				"session_id":     sessionID,
320: 				"from_worker_id": fromWorkerID,
321: 				"bytes_received": session.BytesReceived,
322: 				"duration_sec":   duration,
323: 				"throughput_mbps": throughput,
324: 				"chunks_received": session.ChunksReceived,
325: 				"total_chunks":   totalChunks,
326: 			},
327: 		}
328: 
329: 		for _, client := range clients {
330: 			if err := client.WriteJSON(uiMsg); err != nil {
331: 				log.Printf("Failed to send benchmark results to UI: %v", err)
332: 			}
333: 		}
334: 
335: 		// Clean up session
336: 		p.state.Mu.Lock()
337: 		delete(p.state.BenchmarkSessions, sessionID)
338: 	}
339: 	p.state.Mu.Unlock()
340: 
341: 	return nil
342: }
343: 
344: func (p *P2PProtocol) StartKeepAlive(peerAddr *net.UDPAddr) {
345: 	p.state.Mu.Lock()
346: 	if p.state.P2PKeepAliveTask != nil {
347: 		close(p.state.P2PKeepAliveTask)
348: 	}
349: 	p.state.P2PKeepAliveTask = make(chan struct{})
350: 	task := p.state.P2PKeepAliveTask
351: 	p.state.Mu.Unlock()
352: 
353: 	go func() {
354: 		ticker := time.NewTicker(15 * time.Second)
355: 		defer ticker.Stop()
356: 
357: 		for {
358: 			select {
359: 			case <-ticker.C:
360: 				if err := p.SendMessage("p2p_keep_alive", map[string]interface{}{}, peerAddr); err != nil {
361: 					log.Printf("Failed to send keep-alive: %v", err)
362: 				}
363: 			case <-task:
364: 				return
365: 			}
366: 		}
367: 	}()
368: }
369: 
370: func (p *P2PProtocol) InitiatePairingTest(peerID string, peerAddr *net.UDPAddr) {
371: 	if p.state.WorkerID < peerID {
372: 		log.Printf("Initiating pairing test with %s (Peer UDP: %s)", peerID, peerAddr.String())
373: 
374: 		if err := p.SendMessage("p2p_pairing_test", map[string]interface{}{
375: 			"timestamp": float64(time.Now().UnixNano()) / 1e9, // Python's time.time() returns a float
376: 		}, peerAddr); err != nil {
377: 			log.Printf("Failed to send pairing test: %v", err)
378: 		}
379: 	}
380: }
</file>

<file path="holepunch-go/pkg/stun/stun.go">
  1: package stun
  2: 
  3: import (
  4: 	"fmt"
  5: 	"net"
  6: 	"time"
  7: 
  8: 	"github.com/pion/stun"
  9: )
 10: 
 11: type STUNResult struct {
 12: 	PublicIP   string
 13: 	PublicPort int
 14: }
 15: 
 16: // DiscoverWithConn uses an existing UDP connection for STUN discovery
 17: // NOTE: This function is not fully implemented for reliable use with shared connections
 18: // due to challenges with managing read deadlines on a connection that might be concurrently used.
 19: func DiscoverWithConn(conn *net.UDPConn, stunHost string, stunPort int) (*STUNResult, error) {
 20: 	serverAddrStr := fmt.Sprintf("%s:%d", stunHost, stunPort)
 21: 
 22: 	raddr, err := net.ResolveUDPAddr("udp", serverAddrStr)
 23: 	if err != nil {
 24: 		return nil, fmt.Errorf("failed to resolve STUN server address %s: %w", serverAddrStr, err)
 25: 	}
 26: 
 27: 	message := stun.MustBuild(stun.TransactionID, stun.BindingRequest)
 28: 
 29: 	_, err = conn.WriteToUDP(message.Raw, raddr)
 30: 	if err != nil {
 31: 		return nil, fmt.Errorf("failed to send STUN request via existing conn: %w", err)
 32: 	}
 33: 
 34: 	// Reading response here is problematic on a shared conn without a dedicated response queue
 35: 	// or way to distinguish STUN responses from other P2P data.
 36: 	// For now, this function remains more of a placeholder for a more complex implementation.
 37: 	return nil, fmt.Errorf("STUN discovery with shared connection not yet reliably implemented for response reading")
 38: }
 39: 
 40: // DiscoverPublicEndpointWithTimeout performs STUN discovery with a configurable read timeout
 41: func DiscoverPublicEndpointWithTimeout(localAddr string, stunHost string, stunPort int, readTimeout time.Duration) (*STUNResult, error) {
 42: 	serverAddrStr := fmt.Sprintf("%s:%d", stunHost, stunPort)
 43: 
 44: 	// Resolve STUN server address
 45: 	raddr, err := net.ResolveUDPAddr("udp", serverAddrStr)
 46: 	if err != nil {
 47: 		return nil, fmt.Errorf("failed to resolve STUN server address %s: %w", serverAddrStr, err)
 48: 	}
 49: 
 50: 	// Log resolved address for debugging
 51: 	// log.Printf("STUN: Resolved server address %s to %s", serverAddrStr, raddr.String())
 52: 
 53: 	// Create a UDP packet listener.
 54: 	// If localAddr is like ":8081", it will try to bind to that local port.
 55: 	// If localAddr is like ":0", it will bind to an ephemeral port.
 56: 	pConn, err := net.ListenPacket("udp4", localAddr)
 57: 	if err != nil {
 58: 		return nil, fmt.Errorf("failed to listen on UDP port %s: %w", localAddr, err)
 59: 	}
 60: 	defer pConn.Close()
 61: 
 62: 	// Log local address for debugging
 63: 	localSocketAddr := pConn.LocalAddr().String()
 64: 	// log.Printf("STUN: Created UDP listener on %s", localSocketAddr)
 65: 
 66: 	// Build STUN binding request
 67: 	message := stun.MustBuild(stun.TransactionID, stun.BindingRequest)
 68: 
 69: 	// Send the request
 70: 	_, err = pConn.WriteTo(message.Raw, raddr)
 71: 	if err != nil {
 72: 		return nil, fmt.Errorf("failed to send STUN request to %s: %w", raddr.String(), err)
 73: 	}
 74: 
 75: 	// Read response
 76: 	buf := make([]byte, 1500)
 77: 	// Set a deadline for the read. net.PacketConn has SetReadDeadline.
 78: 	if err := pConn.SetReadDeadline(time.Now().Add(readTimeout)); err != nil {
 79: 		return nil, fmt.Errorf("failed to set read deadline for STUN response: %w", err)
 80: 	}
 81: 
 82: 	n, _, err := pConn.ReadFrom(buf)
 83: 	if err != nil {
 84: 		// Check if it's a timeout error
 85: 		if netErr, ok := err.(net.Error); ok && netErr.Timeout() {
 86: 			return nil, fmt.Errorf("STUN request to %s timed out after %v (sent from %s): %w", raddr.String(), readTimeout, localSocketAddr, err)
 87: 		}
 88: 		return nil, fmt.Errorf("failed to read STUN response from %s (local %s): %w", raddr.String(), localSocketAddr, err)
 89: 	}
 90: 
 91: 	// Log response details for debugging
 92: 	// log.Printf("STUN: Received %d bytes response", n)
 93: 
 94: 	// Parse response
 95: 	response := new(stun.Message)
 96: 	response.Raw = buf[:n]
 97: 	if err := response.Decode(); err != nil {
 98: 		return nil, fmt.Errorf("failed to decode STUN response: %w", err)
 99: 	}
100: 
101: 	// Extract XOR-mapped address
102: 	var xorAddr stun.XORMappedAddress
103: 	if err := xorAddr.GetFrom(response); err != nil {
104: 		// Fallback: Try MAPPED_ADDRESS if XOR_MAPPED_ADDRESS fails (some older STUN servers or certain NATs)
105: 		var mappedAddr stun.MappedAddress
106: 		if errMapped := mappedAddr.GetFrom(response); errMapped != nil {
107: 			return nil, fmt.Errorf("failed to get XOR-mapped or MAPPED address from STUN response: XOR err: %v, MAPPED err: %v", err, errMapped)
108: 		}
109: 		// log.Printf("STUN: Using MAPPED_ADDRESS: %s:%d", mappedAddr.IP.String(), mappedAddr.Port)
110: 		return &STUNResult{
111: 			PublicIP:   mappedAddr.IP.String(),
112: 			PublicPort: mappedAddr.Port,
113: 		}, nil
114: 	}
115: 
116: 	// log.Printf("STUN: Using XOR_MAPPED_ADDRESS: %s:%d", xorAddr.IP.String(), xorAddr.Port)
117: 	return &STUNResult{
118: 		PublicIP:   xorAddr.IP.String(),
119: 		PublicPort: xorAddr.Port,
120: 	}, nil
121: }
122: 
123: // DiscoverPublicEndpoint performs STUN discovery with default 10 second read timeout
124: func DiscoverPublicEndpoint(localAddr string, stunHost string, stunPort int) (*STUNResult, error) {
125: 	return DiscoverPublicEndpointWithTimeout(localAddr, stunHost, stunPort, 10*time.Second)
126: }
127: 
128: // DiscoverWithRetryTimeout performs STUN discovery with retries and configurable read timeout
129: func DiscoverWithRetryTimeout(localAddr string, stunHost string, stunPort int, maxRetries int, readTimeout time.Duration) (*STUNResult, error) {
130: 	var lastErr error
131: 
132: 	for i := 0; i < maxRetries; i++ {
133: 		if i > 0 {
134: 			// Exponential backoff for retries, e.g., 1s, 2s, 4s
135: 			delay := time.Duration(1<<uint(i-1)) * time.Second
136: 			// log.Printf("STUN: Retry attempt %d/%d in %v...", i+1, maxRetries, delay)
137: 			time.Sleep(delay)
138: 		}
139: 
140: 		// log.Printf("STUN: Attempt %d/%d to discover public endpoint", i+1, maxRetries)
141: 		result, err := DiscoverPublicEndpointWithTimeout(localAddr, stunHost, stunPort, readTimeout)
142: 		if err == nil {
143: 			return result, nil
144: 		}
145: 		lastErr = err
146: 		// log.Printf("STUN: Attempt %d/%d failed: %v", i+1, maxRetries, err)
147: 	}
148: 
149: 	return nil, fmt.Errorf("failed after %d retries: %w", maxRetries, lastErr)
150: }
151: 
152: // DiscoverWithRetry performs STUN discovery with retries using default 10 second read timeout
153: func DiscoverWithRetry(localAddr string, stunHost string, stunPort int, maxRetries int) (*STUNResult, error) {
154: 	return DiscoverWithRetryTimeout(localAddr, stunHost, stunPort, maxRetries, 10*time.Second)
155: }
</file>

<file path="holepunch-go/rebuild_and_deploy.sh">
  1: #!/bin/bash
  2: 
  3: # Exit immediately if a command exits with a non-zero status.
  4: set -e
  5: 
  6: # Determine a working 'timeout' command (GNU Coreutils vs. macOS).
  7: if command -v timeout >/dev/null 2>&1; then
  8:   TIMEOUT_CMD="timeout"
  9: elif command -v gtimeout >/dev/null 2>&1; then
 10:   # Homebrew coreutils installs the binary as 'gtimeout'
 11:   TIMEOUT_CMD="gtimeout"
 12:   echo "Using 'gtimeout' as the timeout implementation."
 13: else
 14:   echo "Warning: 'timeout' command not found. Continuing without enforced time limits."
 15:   # Define a shim so the rest of the script can keep using the same syntax:
 16:   timeout() { local _duration=$1; shift; "${@}"; }
 17:   TIMEOUT_CMD="timeout" # The stub function defined above
 18: fi
 19: 
 20: # Helper to invoke commands with the resolved timeout (or none if stubbed)
 21: run_with_timeout() {
 22:   local duration=$1; shift
 23:   if [ -n "${TIMEOUT_CMD}" ] && command -v ${TIMEOUT_CMD} >/dev/null 2>&1; then
 24:     ${TIMEOUT_CMD} "${duration}" "${@}"
 25:   else
 26:     # Stubbed: ignore duration and execute directly
 27:     "${@}"
 28:   fi
 29: }
 30: 
 31: # Load environment variables
 32: if [ -f .envrc ]; then
 33:     echo "Loading environment variables from .envrc..."
 34:     set -a
 35:     source .envrc
 36:     set +a
 37: else
 38:     echo "Error: .envrc file not found. Please create it with the necessary environment variables." >&2
 39:     exit 1
 40: fi
 41: 
 42: set +e # Temporarily allow us to test for missing commands without exiting
 43: if ! command -v gcloud >/dev/null 2>&1; then
 44:   echo "Error: 'gcloud' CLI not found in PATH. Please install the Google Cloud SDK or ensure it's on PATH before running this script." >&2
 45:   exit 1
 46: fi
 47: set -e # Re-enable immediate exit on failures
 48: 
 49: echo "--- Starting Rebuild and Redeployment Process for Go Services ---"
 50: 
 51: # === 1. Delete existing services AND build new images concurrently ===
 52: echo "Step 1: Deleting services and building new images concurrently (with timeouts to avoid hanging)…"
 53: 
 54: # Define timeouts (override via env if needed)
 55: DELETE_TIMEOUT_SEC=${DELETE_TIMEOUT_SEC:-180}
 56: BUILD_TIMEOUT_SEC=${BUILD_TIMEOUT_SEC:-1800}
 57: 
 58: # --- Deletions (run in background with timeout) ---
 59: echo "Deleting Rendezvous service (${RENDEZVOUS_SERVICE_NAME})…"
 60: run_with_timeout ${DELETE_TIMEOUT_SEC}s gcloud run services delete "${RENDEZVOUS_SERVICE_NAME}" \
 61:   --platform=managed --region="${REGION}" --project="${PROJECT_ID}" --quiet & rend_delete_pid=$!
 62: 
 63: echo "Deleting Worker service (${WORKER_SERVICE_NAME})…"
 64: run_with_timeout ${DELETE_TIMEOUT_SEC}s gcloud run services delete "${WORKER_SERVICE_NAME}" \
 65:   --platform=managed --region="${REGION}" --project="${PROJECT_ID}" --quiet & worker_delete_pid=$!
 66: 
 67: # --- Docker image builds (run in background with timeout) ---
 68: BUILD_PLATFORM="linux/amd64"
 69: 
 70: echo "Building and pushing Rendezvous service image with Docker Buildx…"
 71: run_with_timeout ${BUILD_TIMEOUT_SEC}s docker buildx build --platform "${BUILD_PLATFORM}" \
 72:   -t "${REGION}-docker.pkg.dev/${PROJECT_ID}/${AR_RENDEZVOUS_REPO_NAME}/${RENDEZVOUS_SERVICE_NAME}:${RENDEZVOUS_IMAGE_TAG}" \
 73:   -f deployments/Dockerfile.rendezvous . --push & rend_build_pid=$!
 74: 
 75: echo "Building and pushing Worker service image with Docker Buildx…"
 76: run_with_timeout ${BUILD_TIMEOUT_SEC}s docker buildx build --platform "${BUILD_PLATFORM}" \
 77:   -t "${REGION}-docker.pkg.dev/${PROJECT_ID}/${AR_WORKER_REPO_NAME}/${WORKER_SERVICE_NAME}:${WORKER_IMAGE_TAG}" \
 78:   -f deployments/Dockerfile.worker . --push & worker_build_pid=$!
 79: 
 80: # --- Wait for all four background jobs (deletes + builds) ---
 81: echo "Waiting for deletions and builds to complete…"
 82: 
 83: # Helper to wait safely and report status without stopping script on failure
 84: wait_and_report() {
 85:   local pid=$1
 86:   local description=$2
 87:   if wait "$pid"; then
 88:     echo "$description completed successfully."
 89:   else
 90:     echo "Warning: $description exited with an error or timed out (exit code $?). Continuing."
 91:   fi
 92: }
 93: 
 94: wait_and_report $rend_delete_pid "Rendezvous service deletion"
 95: wait_and_report $worker_delete_pid "Worker service deletion"
 96: wait_and_report $rend_build_pid "Rendezvous image build"
 97: wait_and_report $worker_build_pid "Worker image build"
 98: 
 99: echo "All deletions and builds finished."
100: 
101: # Add a small delay to ensure resources are fully cleared before redeploying
102: sleep 10
103: 
104: # === 2. Deploy services concurrently ===
105: echo "Step 2: Deploying Rendezvous and Worker services concurrently…"
106: 
107: # Timeout for deployments
108: DEPLOY_TIMEOUT_SEC=${DEPLOY_TIMEOUT_SEC:-600}
109: # Maximum request timeout (for WebSocket connections)
110: REQUEST_TIMEOUT_SEC=${REQUEST_TIMEOUT_SEC:-3600}
111: 
112: # Rendezvous deploy
113: run_with_timeout ${DEPLOY_TIMEOUT_SEC}s gcloud run deploy "${RENDEZVOUS_SERVICE_NAME}" \
114:   --project="${PROJECT_ID}" \
115:   --image "${REGION}-docker.pkg.dev/${PROJECT_ID}/${AR_RENDEZVOUS_REPO_NAME}/${RENDEZVOUS_SERVICE_NAME}:${RENDEZVOUS_IMAGE_TAG}" \
116:   --platform=managed \
117:   --region "${REGION}" \
118:   --allow-unauthenticated \
119:   --timeout="${REQUEST_TIMEOUT_SEC}s" \
120:   --session-affinity \
121:   --set-env-vars="PING_INTERVAL_SEC=${PING_INTERVAL_SEC:-30},PING_TIMEOUT_SEC=${PING_TIMEOUT_SEC:-60}" & rend_deploy_pid=$!
122: 
123: # Worker deploy
124: run_with_timeout ${DEPLOY_TIMEOUT_SEC}s gcloud run deploy "${WORKER_SERVICE_NAME}" \
125:   --image "${REGION}-docker.pkg.dev/${PROJECT_ID}/${AR_WORKER_REPO_NAME}/${WORKER_SERVICE_NAME}:${WORKER_IMAGE_TAG}" \
126:   --project "${PROJECT_ID}" \
127:   --region "${REGION}" \
128:   --platform managed \
129:   --allow-unauthenticated \
130:   --timeout="${REQUEST_TIMEOUT_SEC}s" \
131:   --set-env-vars="RENDEZVOUS_SERVICE_URL=${RENDEZVOUS_URL},INTERNAL_UDP_PORT=${INTERNAL_UDP_PORT:-8081},STUN_HOST=${STUN_HOST:-stun.l.google.com},STUN_PORT=${STUN_PORT:-19302},BENCHMARK_GCS_URL=${BENCHMARK_GCS_URL},BENCHMARK_CHUNK_SIZE=${BENCHMARK_CHUNK_SIZE:-8192}" \
132:   --cpu=4 \
133:   --memory=8Gi \
134:   --no-cpu-throttling \
135:   --vpc-egress=all-traffic \
136:   --network=ip-worker-vpc \
137:   --subnet=ip-worker-subnet \
138:   --min-instances=2 \
139:   --max-instances=2 & worker_deploy_pid=$!
140: 
141: # Wait for deployments
142: echo "Waiting for service deployments to finish…"
143: wait_and_report $rend_deploy_pid "Rendezvous service deployment"
144: wait_and_report $worker_deploy_pid "Worker service deployment"
145: 
146: echo "Both services deployed (or attempted) concurrently."
147: 
148: # === 3. Get service URLs ===
149: echo ""
150: echo "Getting service URLs..."
151: RENDEZVOUS_URL=$(gcloud run services describe ${RENDEZVOUS_SERVICE_NAME} --platform=managed --region=${REGION} --format='value(status.url)' 2>/dev/null || echo "Failed to get URL")
152: WORKER_URL=$(gcloud run services describe ${WORKER_SERVICE_NAME} --platform=managed --region=${REGION} --format='value(status.url)' 2>/dev/null || echo "Failed to get URL")
153: 
154: echo ""
155: echo "=== Deployment Complete ==="
156: echo "Rendezvous Service: ${RENDEZVOUS_URL}"
157: echo "Rendezvous Admin: ${RENDEZVOUS_URL}/admin"
158: echo "Worker Service: ${WORKER_URL}"
159: echo ""
160: echo "Note: Workers will automatically connect to the rendezvous service."
161: echo "--- Rebuild and Redeployment Process Completed ---"
</file>

<file path="rendezvous_service_code/api_endpoints.py">
  1: """
  2: REST API endpoints for the rendezvous service
  3: """
  4: import asyncio
  5: from pathlib import Path
  6: from fastapi import HTTPException
  7: from fastapi.responses import HTMLResponse
  8: 
  9: from models import service_state, ConnectionRequest
 10: from pairing import manual_pair_workers
 11: from broadcast import broadcast_to_admin_clients
 12: 
 13: 
 14: async def read_root():
 15:     """Root endpoint"""
 16:     return {"message": "Rendezvous Service is running. Test."}
 17: 
 18: 
 19: async def admin_ui():
 20:     """Serve the admin UI HTML page"""
 21:     admin_html_path = Path(__file__).parent / "admin.html"
 22:     if admin_html_path.exists():
 23:         with open(admin_html_path, "r") as f:
 24:             html_content = f.read()
 25:         return HTMLResponse(content=html_content)
 26:     else:
 27:         return HTMLResponse(content="<h1>Admin UI not found</h1>", status_code=404)
 28: 
 29: 
 30: async def admin_chat_ui():
 31:     """Serve the admin chat UI HTML page"""
 32:     chat_html_path = Path(__file__).parent / "admin-chat.html"
 33:     if chat_html_path.exists():
 34:         with open(chat_html_path, "r") as f:
 35:             html_content = f.read()
 36:         return HTMLResponse(content=html_content)
 37:     else:
 38:         return HTMLResponse(content="<h1>Admin Chat UI not found</h1>", status_code=404)
 39: 
 40: 
 41: async def list_workers():
 42:     """Debug endpoint for listing workers"""
 43:     workers_info = {}
 44:     for worker_id_key, data_val in list(service_state.connected_workers.items()):
 45:         ws_object = data_val.get("websocket")
 46:         is_connected = False
 47:         if ws_object and hasattr(ws_object, 'client_state') and ws_object.client_state.value == 1:
 48:             is_connected = True
 49:         
 50:         workers_info[worker_id_key] = {
 51:             "websocket_observed_ip": data_val.get("websocket_observed_ip"),
 52:             "websocket_observed_port": data_val.get("websocket_observed_port"),
 53:             "stun_reported_udp_ip": data_val.get("stun_reported_udp_ip"),
 54:             "stun_reported_udp_port": data_val.get("stun_reported_udp_port"),
 55:             "websocket_connected": is_connected
 56:         }
 57:     return {
 58:         "connected_workers_count": len(workers_info), 
 59:         "workers": workers_info, 
 60:         "ready_for_pairing_count": len(service_state.workers_ready_for_pairing), 
 61:         "ready_list": service_state.workers_ready_for_pairing
 62:     }
 63: 
 64: 
 65: async def api_list_workers():
 66:     """API endpoint for listing all connected workers with their status"""
 67:     workers_list = []
 68:     for worker_id, data in service_state.connected_workers.items():
 69:         ws_object = data.get("websocket")
 70:         is_connected = False
 71:         if ws_object and hasattr(ws_object, 'client_state') and ws_object.client_state.value == 1:
 72:             is_connected = True
 73:         
 74:         # Check if worker has valid UDP endpoint
 75:         has_udp = bool(data.get("stun_reported_udp_ip") and data.get("stun_reported_udp_port"))
 76:         
 77:         # Check if worker is ready for pairing
 78:         is_ready = worker_id in service_state.workers_ready_for_pairing
 79:         
 80:         workers_list.append({
 81:             "worker_id": worker_id,
 82:             "websocket_connected": is_connected,
 83:             "has_udp_endpoint": has_udp,
 84:             "ready_for_pairing": is_ready,
 85:             "websocket_ip": data.get("websocket_observed_ip"),
 86:             "websocket_port": data.get("websocket_observed_port"),
 87:             "udp_ip": data.get("stun_reported_udp_ip"),
 88:             "udp_port": data.get("stun_reported_udp_port")
 89:         })
 90:     
 91:     return {
 92:         "workers": workers_list,
 93:         "total_count": len(workers_list),
 94:         "connected_count": sum(1 for w in workers_list if w["websocket_connected"]),
 95:         "ready_count": len(service_state.workers_ready_for_pairing)
 96:     }
 97: 
 98: 
 99: async def connect_workers(request: ConnectionRequest):
100:     """Manually connect two specific workers"""
101:     if request.worker_a_id == request.worker_b_id:
102:         raise HTTPException(status_code=400, detail="Cannot connect a worker to itself")
103:     
104:     try:
105:         success = await manual_pair_workers(request.worker_a_id, request.worker_b_id)
106:         # Broadcast connection event to admin clients
107:         await broadcast_to_admin_clients({
108:             "type": "connection_initiated",
109:             "worker_a_id": request.worker_a_id,
110:             "worker_b_id": request.worker_b_id,
111:             "timestamp": asyncio.get_event_loop().time()
112:         })
113:         return {
114:             "success": success,
115:             "message": f"Connection initiated between {request.worker_a_id} and {request.worker_b_id}"
116:         }
117:     except HTTPException:
118:         raise
119:     except Exception as e:
120:         raise HTTPException(status_code=500, detail=str(e))
</file>

<file path="rendezvous_service_code/worker_websocket.py">
  1: """
  2: WebSocket handler for worker connections
  3: """
  4: import json
  5: import asyncio
  6: from fastapi import WebSocket, WebSocketDisconnect
  7: 
  8: from models import service_state
  9: from broadcast import broadcast_to_admin_clients
 10: from pairing import attempt_to_pair_workers
 11: 
 12: 
 13: async def websocket_register_worker(websocket: WebSocket, worker_id: str):
 14:     """Handle WebSocket connection for a worker"""
 15:     await websocket.accept()
 16:     client_host = websocket.client.host 
 17:     client_port = websocket.client.port 
 18:     
 19:     print(f"Worker '{worker_id}' connecting from WebSocket endpoint: {client_host}:{client_port}")
 20: 
 21:     if worker_id in service_state.connected_workers:
 22:         print(f"Worker '{worker_id}' re-connecting or duplicate ID detected.")
 23:         old_ws_data = service_state.connected_workers.get(worker_id)
 24:         if old_ws_data:
 25:             old_ws = old_ws_data.get("websocket")
 26:             if old_ws and hasattr(old_ws, 'client_state') and old_ws.client_state.value == 1:
 27:                  try: 
 28:                      await old_ws.close(code=1012, reason="New connection from same worker ID / Service Restarting")
 29:                  except Exception: 
 30:                      pass
 31:         if worker_id in service_state.workers_ready_for_pairing: 
 32:             service_state.workers_ready_for_pairing.remove(worker_id)
 33: 
 34:     service_state.connected_workers[worker_id] = {
 35:         "websocket_observed_ip": client_host, 
 36:         "websocket_observed_port": client_port, 
 37:         "websocket": websocket,
 38:         "stun_reported_udp_ip": None, 
 39:         "stun_reported_udp_port": None
 40:     }
 41:     print(f"Worker '{worker_id}' registered. WebSocket EP: {client_host}:{client_port}. Total: {len(service_state.connected_workers)}")
 42:     
 43:     # Broadcast worker connected event
 44:     await broadcast_to_admin_clients({
 45:         "type": "worker_connected",
 46:         "worker_id": worker_id,
 47:         "websocket_ip": client_host,
 48:         "websocket_port": client_port,
 49:         "total_workers": len(service_state.connected_workers)
 50:     })
 51: 
 52:     try:
 53:         while True: 
 54:             raw_data = await websocket.receive_text()
 55:             print(f"Rendezvous: Received raw message from '{worker_id}': {raw_data}")
 56:             try:
 57:                 message = json.loads(raw_data)
 58:                 msg_type = message.get("type")
 59: 
 60:                 if msg_type == "update_udp_endpoint":
 61:                     udp_ip = message.get("udp_ip")
 62:                     udp_port = message.get("udp_port")
 63:                     if udp_ip and udp_port and worker_id in service_state.connected_workers:
 64:                         service_state.connected_workers[worker_id]["stun_reported_udp_ip"] = udp_ip
 65:                         service_state.connected_workers[worker_id]["stun_reported_udp_port"] = int(udp_port)
 66:                         print(f"Worker '{worker_id}' updated STUN UDP endpoint to: {udp_ip}:{udp_port}")
 67:                         await websocket.send_text(json.dumps({"type": "udp_endpoint_ack", "status": "success"}))
 68:                         # Broadcast UDP endpoint update
 69:                         await broadcast_to_admin_clients({
 70:                             "type": "worker_udp_updated",
 71:                             "worker_id": worker_id,
 72:                             "udp_ip": udp_ip,
 73:                             "udp_port": udp_port
 74:                         })
 75:                         await attempt_to_pair_workers(worker_id)
 76:                     else:
 77:                         await websocket.send_text(json.dumps({"type": "udp_endpoint_ack", "status": "error", "detail": "Missing IP or Port"}))
 78:                 
 79:                 elif msg_type == "echo_request": 
 80:                     payload = message.get("payload", "")
 81:                     await websocket.send_text(json.dumps({
 82:                         "type": "echo_response",
 83:                         "original_payload": payload,
 84:                         "processed_by_rendezvous": f"Rendezvous processed: '{payload.upper()}' for worker {worker_id}"
 85:                     }))
 86:                 
 87:                 elif msg_type == "chat_response":
 88:                     # Worker is responding to admin chat
 89:                     admin_session_id = message.get("admin_session_id")
 90:                     chat_content = message.get("content")
 91:                     if admin_session_id and chat_content:
 92:                         # Forward to the appropriate admin chat session
 93:                         if admin_session_id in service_state.chat_sessions and worker_id in service_state.chat_sessions[admin_session_id]:
 94:                             admin_ws = service_state.chat_sessions[admin_session_id][worker_id]
 95:                             try:
 96:                                 await admin_ws.send_text(json.dumps({
 97:                                     "type": "chat_message",
 98:                                     "from": "worker",
 99:                                     "worker_id": worker_id,
100:                                     "content": chat_content,
101:                                     "timestamp": asyncio.get_event_loop().time()
102:                                 }))
103:                             except Exception as e:
104:                                 print(f"Error forwarding chat to admin: {e}")
105:                 
106:                 else:
107:                     print(f"Rendezvous: Worker '{worker_id}' sent unhandled message type: {msg_type}")
108: 
109:             except json.JSONDecodeError: 
110:                 print(f"Rendezvous: Worker '{worker_id}' sent non-JSON: {raw_data}")
111:             except AttributeError: 
112:                 print(f"Rendezvous: Worker '{worker_id}' sent malformed JSON: {raw_data}")
113:             except KeyError: 
114:                 print(f"Rendezvous: Worker '{worker_id}' no longer in dict.")
115: 
116:     except WebSocketDisconnect:
117:         print(f"Worker '{worker_id}' disconnected from WebSocket EP: {client_host}:{client_port}.")
118:     except Exception as e:
119:         print(f"Error with worker '{worker_id}' WebSocket: {e}")
120:     finally:
121:         if worker_id in service_state.connected_workers and service_state.connected_workers[worker_id].get("websocket") == websocket:
122:             del service_state.connected_workers[worker_id]
123:             print(f"Worker '{worker_id}' de-registered. Total: {len(service_state.connected_workers)}")
124:             # Broadcast worker disconnected event
125:             await broadcast_to_admin_clients({
126:                 "type": "worker_disconnected",
127:                 "worker_id": worker_id,
128:                 "total_workers": len(service_state.connected_workers)
129:             })
130:         if worker_id in service_state.workers_ready_for_pairing: 
131:             service_state.workers_ready_for_pairing.remove(worker_id)
132:             print(f"Worker '{worker_id}' removed from pending pairing list due to disconnect.")
</file>

<file path="Dockerfile.worker">
 1: # Use an official Python runtime as a parent image
 2: FROM python:3.9-slim
 3: 
 4: # Set the working directory in the container
 5: WORKDIR /app
 6: 
 7: # Copy the requirements file
 8: COPY requirements.txt .
 9: 
10: # Install dependencies
11: RUN pip install --no-cache-dir --prefer-binary -r requirements.txt
12: 
13: # Copy the application code
14: COPY main.py .
15: COPY index.html .
16: 
17: # This worker doesn't run a Gunicorn server anymore; it runs the main.py script directly.
18: # The PORT environment variable is not directly used by main.py unless you add server logic back.
19: # No EXPOSE needed if it's only an outbound client.
20: 
21: # Command to run the Python script
22: CMD ["python", "-u", "main.py"]
</file>

<file path="rebuild_and_deploy.sh">
  1: #!/bin/bash
  2: 
  3: # Exit immediately if a command exits with a non-zero status.
  4: set -e
  5: 
  6: # Determine a working 'timeout' command (GNU Coreutils vs. macOS).
  7: if command -v timeout >/dev/null 2>&1; then
  8:   TIMEOUT_CMD="timeout"
  9: elif command -v gtimeout >/dev/null 2>&1; then
 10:   # Homebrew coreutils installs the binary as 'gtimeout'
 11:   TIMEOUT_CMD="gtimeout"
 12:   echo "Using 'gtimeout' as the timeout implementation."
 13: else
 14:   echo "Warning: 'timeout' command not found. Continuing without enforced time limits."
 15:   # Define a shim so the rest of the script can keep using the same syntax:
 16:   timeout() { local _duration=$1; shift; "${@}"; }
 17:   TIMEOUT_CMD="timeout" # The stub function defined above
 18: fi
 19: 
 20: # Helper to invoke commands with the resolved timeout (or none if stubbed)
 21: run_with_timeout() {
 22:   local duration=$1; shift
 23:   if [ -n "${TIMEOUT_CMD}" ] && command -v ${TIMEOUT_CMD} >/dev/null 2>&1; then
 24:     ${TIMEOUT_CMD} "${duration}" "${@}"
 25:   else
 26:     # Stubbed: ignore duration and execute directly
 27:     "${@}"
 28:   fi
 29: }
 30: 
 31: # Load environment variables
 32: if [ -f .envrc ]; then
 33:     echo "Loading environment variables from .envrc..."
 34:     set -a
 35:     source .envrc
 36:     set +a
 37: else
 38:     echo "Error: .envrc file not found. Please create it with the necessary environment variables." >&2
 39:     exit 1
 40: fi
 41: 
 42: set +e # Temporarily allow us to test for missing commands without exiting
 43: if ! command -v gcloud >/dev/null 2>&1; then
 44:   echo "Error: 'gcloud' CLI not found in PATH. Please install the Google Cloud SDK or ensure it's on PATH before running this script." >&2
 45:   exit 1
 46: fi
 47: set -e # Re-enable immediate exit on failures
 48: 
 49: echo "--- Starting Rebuild and Redeployment Process ---"
 50: 
 51: # === 1. Delete existing services AND build new images concurrently ===
 52: echo "Step 1: Deleting services and building new images concurrently (with timeouts to avoid hanging)…"
 53: 
 54: # Define timeouts (override via env if needed)
 55: DELETE_TIMEOUT_SEC=${DELETE_TIMEOUT_SEC:-180}
 56: BUILD_TIMEOUT_SEC=${BUILD_TIMEOUT_SEC:-1800}
 57: 
 58: # --- Deletions (run in background with timeout) ---
 59: echo "Deleting Rendezvous service (${RENDEZVOUS_SERVICE_NAME})…"
 60: run_with_timeout ${DELETE_TIMEOUT_SEC}s gcloud run services delete "${RENDEZVOUS_SERVICE_NAME}" \
 61:   --platform=managed --region="${REGION}" --project="${PROJECT_ID}" --quiet & rend_delete_pid=$!
 62: 
 63: echo "Deleting Worker service (${WORKER_SERVICE_NAME})…"
 64: run_with_timeout ${DELETE_TIMEOUT_SEC}s gcloud run services delete "${WORKER_SERVICE_NAME}" \
 65:   --platform=managed --region="${REGION}" --project="${PROJECT_ID}" --quiet & worker_delete_pid=$!
 66: 
 67: # --- Docker image builds (run in background with timeout) ---
 68: BUILD_PLATFORM="linux/amd64"
 69: 
 70: echo "Building and pushing Rendezvous service image with Docker Buildx…"
 71: run_with_timeout ${BUILD_TIMEOUT_SEC}s docker buildx build --platform "${BUILD_PLATFORM}" \
 72:   -t "${REGION}-docker.pkg.dev/${PROJECT_ID}/${AR_RENDEZVOUS_REPO_NAME}/${RENDEZVOUS_SERVICE_NAME}:${RENDEZVOUS_IMAGE_TAG}" \
 73:   -f rendezvous_service_code/Dockerfile.rendezvous rendezvous_service_code --push & rend_build_pid=$!
 74: 
 75: echo "Building and pushing Worker service image with Docker Buildx…"
 76: run_with_timeout ${BUILD_TIMEOUT_SEC}s docker buildx build --platform "${BUILD_PLATFORM}" \
 77:   -t "${REGION}-docker.pkg.dev/${PROJECT_ID}/${AR_WORKER_REPO_NAME}/${WORKER_SERVICE_NAME}:${WORKER_IMAGE_TAG}" \
 78:   -f Dockerfile.worker . --push & worker_build_pid=$!
 79: 
 80: # --- Wait for all four background jobs (deletes + builds) ---
 81: echo "Waiting for deletions and builds to complete…"
 82: 
 83: # Helper to wait safely and report status without stopping script on failure
 84: wait_and_report() {
 85:   local pid=$1
 86:   local description=$2
 87:   if wait "$pid"; then
 88:     echo "$description completed successfully."
 89:   else
 90:     echo "Warning: $description exited with an error or timed out (exit code $?). Continuing."
 91:   fi
 92: }
 93: 
 94: wait_and_report $rend_delete_pid "Rendezvous service deletion"
 95: wait_and_report $worker_delete_pid "Worker service deletion"
 96: wait_and_report $rend_build_pid "Rendezvous image build"
 97: wait_and_report $worker_build_pid "Worker image build"
 98: 
 99: echo "All deletions and builds finished."
100: 
101: # Add a small delay to ensure resources are fully cleared before redeploying
102: sleep 10
103: 
104: # === 2. Deploy services concurrently ===
105: echo "Step 2: Deploying Rendezvous and Worker services concurrently…"
106: 
107: # Timeout for deployments
108: DEPLOY_TIMEOUT_SEC=${DEPLOY_TIMEOUT_SEC:-600}
109: # Maximum request timeout (for WebSocket connections)
110: REQUEST_TIMEOUT_SEC=${REQUEST_TIMEOUT_SEC:-3600}
111: 
112: # Rendezvous deploy
113: run_with_timeout ${DEPLOY_TIMEOUT_SEC}s gcloud run deploy "${RENDEZVOUS_SERVICE_NAME}" \
114:   --project="${PROJECT_ID}" \
115:   --image "${REGION}-docker.pkg.dev/${PROJECT_ID}/${AR_RENDEZVOUS_REPO_NAME}/${RENDEZVOUS_SERVICE_NAME}:${RENDEZVOUS_IMAGE_TAG}" \
116:   --platform=managed \
117:   --region "${REGION}" \
118:   --allow-unauthenticated \
119:   --timeout="${REQUEST_TIMEOUT_SEC}s" \
120:   --session-affinity & rend_deploy_pid=$!
121: 
122: # Worker deploy
123: run_with_timeout ${DEPLOY_TIMEOUT_SEC}s gcloud run deploy "${WORKER_SERVICE_NAME}" \
124:   --image "${REGION}-docker.pkg.dev/${PROJECT_ID}/${AR_WORKER_REPO_NAME}/${WORKER_SERVICE_NAME}:${WORKER_IMAGE_TAG}" \
125:   --project "${PROJECT_ID}" \
126:   --region "${REGION}" \
127:   --platform managed \
128:   --allow-unauthenticated \
129:   --timeout="${REQUEST_TIMEOUT_SEC}s" \
130:   --set-env-vars="RENDEZVOUS_SERVICE_URL=${RENDEZVOUS_URL},STUN_HOST=${DEFAULT_STUN_HOST:-stun.l.google.com},STUN_PORT=${DEFAULT_STUN_PORT:-19302},INTERNAL_UDP_PORT=${INTERNAL_UDP_PORT:-8081},PING_INTERVAL_SEC=${PING_INTERVAL_SEC:-25},PING_TIMEOUT_SEC=${PING_TIMEOUT_SEC:-25},BENCHMARK_GCS_URL=${BENCHMARK_GCS_URL},BENCHMARK_CHUNK_SIZE=${BENCHMARK_CHUNK_SIZE},STUN_RECHECK_INTERVAL_SEC=${STUN_RECHECK_INTERVAL_SEC:-60}" \
131:   --cpu=1 \
132:   --cpu-boost \
133:   --vpc-egress=all-traffic \
134:   --network=ip-worker-vpc \
135:   --subnet=ip-worker-subnet \
136:   --min-instances=2 \
137:   --max-instances=2 & worker_deploy_pid=$!
138: 
139: # Wait for deployments
140: echo "Waiting for service deployments to finish…"
141: wait_and_report $rend_deploy_pid "Rendezvous service deployment"
142: wait_and_report $worker_deploy_pid "Worker service deployment"
143: 
144: echo "Both services deployed (or attempted) concurrently."
145: 
146: echo "--- Rebuild and Redeployment Process Completed ---"
</file>

<file path="repomix.config.json">
 1: {
 2:   "$schema": "https://repomix.com/schemas/latest/schema.json",
 3:   "output": {
 4:     "filePath": "repomix-output.xml",
 5:     "style": "xml",
 6:     "headerText": "Holepunch P2P UDP Communication System - Go Implementation",
 7:     "fileSummary": true,
 8:     "directoryStructure": true,
 9:     "showLineNumbers": true
10:   },
11:   "ignore": {
12:     "useGitignore": true,
13:     "useDefaultPatterns": true,
14:     "customPatterns": [
15:       ".venv/**",
16:       "venv/**",
17:       "__pycache__/**",
18:       "*.pyc",
19:       "bin/**",
20:       "*.log",
21:       "*.tmp",
22:       ".DS_Store",
23:       "repomix-output.xml",
24:       ".git/**",
25:       "node_modules/**"
26:     ]
27:   },
28:   "include": [
29:     "**/*.go",
30:     "**/cmd/**/*.go",
31:     "**/cmd/**",
32:     "holepunch-go/cmd/**",
33:     "**/main.go",
34:     "**/go.mod",
35:     "**/go.sum",
36:     "**/go.work",
37:     "**/go.work.sum",
38:     "**/*.py",
39:     "**/*.md",
40:     "**/*.mod",
41:     "**/*.sum",
42:     "**/*.yaml",
43:     "**/*.yml",
44:     "**/*.json",
45:     "**/*.html",
46:     "**/*.sh",
47:     "**/Dockerfile*"
48:   ]
49: }
</file>

<file path="rendezvous_service_code/Dockerfile.rendezvous">
 1: # Use an official Python runtime as a parent image
 2: FROM python:3.9-slim
 3: 
 4: # Set the working directory in the container
 5: WORKDIR /app
 6: 
 7: # Copy the requirements file to the working directory
 8: COPY requirements.txt .
 9: 
10: # Install dependencies
11: # --no-cache-dir reduces image size
12: # --prefer-binary can speed up installs for packages with binary distributions
13: RUN pip install --no-cache-dir --prefer-binary -r requirements.txt
14: 
15: # Copy the application code into the container
16: COPY main.py .
17: COPY models.py .
18: COPY worker_websocket.py .
19: COPY admin_websocket.py .
20: COPY api_endpoints.py .
21: COPY pairing.py .
22: COPY broadcast.py .
23: COPY admin.html .
24: COPY admin-chat.html .
25: 
26: # Make port 8080 available (Cloud Run default)
27: EXPOSE 8080
28: ENV PORT 8080
29: 
30: # Command to run the Uvicorn server for FastAPI
31: # --host 0.0.0.0 makes it accessible from outside the container
32: # --port $PORT uses the port specified by the environment variable (set by Cloud Run)
33: # Adding --log-level trace for verbose Uvicorn output
34: CMD ["uvicorn", "main:app", "--host", "0.0.0.0", "--port", "8080", "--log-level", "trace"]
</file>

<file path="index.html">
  1: <!DOCTYPE html>
  2: <html>
  3: <head>
  4:     <meta charset="UTF-8">
  5:     <meta name="viewport" content="width=device-width, initial-scale=1.0">
  6:     <title>P2P UDP Chat - Worker: <span id="workerIdSpan">Loading...</span></title>
  7:     <script src="https://cdn.tailwindcss.com"></script>
  8:     <style>
  9:         /* Custom scrollbar for webkit browsers */
 10:         .custom-scrollbar::-webkit-scrollbar {
 11:             width: 8px;
 12:         }
 13:         .custom-scrollbar::-webkit-scrollbar-track {
 14:             background: #f1f1f1;
 15:             border-radius: 10px;
 16:         }
 17:         .custom-scrollbar::-webkit-scrollbar-thumb {
 18:             background: #888;
 19:             border-radius: 10px;
 20:         }
 21:         .custom-scrollbar::-webkit-scrollbar-thumb:hover {
 22:             background: #555;
 23:         }
 24:     </style>
 25: </head>
 26: <body class="bg-gray-200 flex flex-col items-center justify-start min-h-screen p-4 text-gray-800 antialiased">
 27: 
 28:     <div class="bg-white shadow-2xl rounded-xl p-6 sm:p-8 w-full max-w-3xl my-8">
 29:         <h1 class="text-4xl font-bold text-center text-indigo-700 mb-3">
 30:             P2P UDP Chat
 31:         </h1>
 32:         <div class="text-center text-base text-gray-600 mb-1">Worker ID: <span id="workerIdSpan" class="font-semibold text-indigo-600"></span></div>
 33:         <div id="status" class="text-center text-base text-gray-700 mb-2">Connecting to local worker backend...</div>
 34:         <div id="peerInfo" class="text-center text-base text-blue-700 font-medium mb-6">Peer: Not connected</div>
 35: 
 36:         <div id="chatbox" class="custom-scrollbar h-96 border border-gray-300 rounded-lg p-4 overflow-y-auto mb-5 bg-gray-100 space-y-3">
 37:             <!-- Messages will appear here -->
 38:         </div>
 39: 
 40:         <div class="flex flex-col sm:flex-row items-center gap-3 mb-8">
 41:             <input type="text" id="messageInput" placeholder="Type your message..." class="w-full sm:w-auto flex-grow p-4 border border-gray-300 rounded-lg focus:ring-2 focus:ring-indigo-600 focus:border-transparent outline-none text-base shadow-sm"/>
 42:             <button id="sendButton" type="button" class="w-full sm:w-auto bg-indigo-600 hover:bg-indigo-700 active:bg-indigo-800 text-white font-semibold py-4 px-8 rounded-lg transition duration-150 ease-in-out focus:outline-none focus:ring-2 focus:ring-indigo-500 focus:ring-offset-2 shadow-md hover:shadow-lg">
 43:                 Send
 44:             </button>
 45:         </div>
 46: 
 47:         <div id="benchmarkSection" class="mt-8 p-6 border border-gray-200 rounded-xl bg-slate-50 shadow">
 48:             <h3 class="text-2xl font-semibold text-gray-800 mb-4">P2P UDP Throughput Benchmark</h3>
 49:             <div class="flex flex-col sm:flex-row items-end gap-4">
 50:                 <div class="flex-grow w-full sm:w-auto">
 51:                     <label for="benchmarkSize" class="block text-base font-medium text-gray-700 mb-1.5">Data Size (KB):</label>
 52:                     <input type="number" id="benchmarkSize" value="1024" min="1" class="w-full p-3 border border-gray-300 rounded-lg focus:ring-1 focus:ring-indigo-600 focus:border-transparent outline-none text-base shadow-sm"/>
 53:                 </div>
 54:                 <button id="startBenchmarkButton" class="w-full sm:w-auto bg-green-600 hover:bg-green-700 active:bg-green-800 text-white font-semibold py-3 px-6 rounded-lg transition duration-150 ease-in-out focus:outline-none focus:ring-2 focus:ring-green-500 focus:ring-offset-2 shadow-md hover:shadow-lg">
 55:                     Start Benchmark
 56:                 </button>
 57:             </div>
 58:             <div id="benchmarkStatus" class="mt-4 text-base text-gray-700 bg-gray-100 p-4 rounded-lg min-h-[45px] shadow-inner">Benchmark status will appear here.</div>
 59:         </div>
 60:     </div>
 61: 
 62:     <script>
 63:         const workerIdSpan = document.getElementById('workerIdSpan');
 64:         const chatbox = document.getElementById('chatbox');
 65:         const messageInput = document.getElementById('messageInput');
 66:         const sendButton = document.getElementById('sendButton');
 67:         const statusDiv = document.getElementById('status');
 68:         const peerInfoDiv = document.getElementById('peerInfo');
 69:         const benchmarkSizeInput = document.getElementById('benchmarkSize');
 70:         const startBenchmarkButton = document.getElementById('startBenchmarkButton');
 71:         const benchmarkStatusDiv = document.getElementById('benchmarkStatus');
 72: 
 73:         let localUiSocket = null;
 74:         let myWorkerId = "Unknown";
 75: 
 76:         function addMessage(text, type = "system", sender = "") {
 77:             const messageDiv = document.createElement('div');
 78:             messageDiv.classList.add('p-3', 'rounded-xl', 'max-w-[90%]', 'break-words', 'shadow-sm', 'text-base');
 79:             let fullMessageText = text;
 80: 
 81:             if (type === 'local') {
 82:                 messageDiv.classList.add('bg-indigo-600', 'text-white', 'ml-auto', 'rounded-br-lg');
 83:                 fullMessageText = text;
 84:             } else if (type === 'peer') {
 85:                 messageDiv.classList.add('bg-slate-200', 'text-slate-800', 'mr-auto', 'rounded-bl-lg');
 86:                 fullMessageText = sender ? `${sender}: ${text}` : text;
 87:             } else { // system
 88:                 messageDiv.classList.add('bg-slate-100', 'text-slate-600', 'text-sm', 'italic', 'text-center', 'w-full', 'max-w-full', 'py-2', 'mx-auto', 'rounded-md');
 89:             }
 90:             messageDiv.textContent = fullMessageText;
 91:             chatbox.appendChild(messageDiv);
 92:             chatbox.scrollTop = chatbox.scrollHeight;
 93:         }
 94: 
 95:         function connectToLocalBackend() {
 96:             const wsProtocol = window.location.protocol === "https:" ? "wss:" : "ws:";
 97:             const localWsUrl = `${wsProtocol}//${window.location.host}/ui_ws`; 
 98:             
 99:             addMessage(`Attempting to connect to local UI WebSocket at ${localWsUrl}`, "system");
100:             localUiSocket = new WebSocket(localWsUrl);
101: 
102:             localUiSocket.onopen = function(event) {
103:                 statusDiv.textContent = "Connected to local worker backend. Waiting for P2P link...";
104:                 addMessage("Connection to local worker backend established.", "system");
105:                 localUiSocket.send(JSON.stringify({type: "ui_client_hello"}));
106:             };
107: 
108:             localUiSocket.onmessage = function(event) {
109:                 try {
110:                     const data = JSON.parse(event.data);
111:                     console.log("Message from local worker backend:", data);
112:                     if (data.type === "init_info") {
113:                         myWorkerId = data.worker_id;
114:                         workerIdSpan.textContent = myWorkerId ? myWorkerId.substring(0,8) + "..." : "N/A";
115:                         addMessage(`Worker ID: ${myWorkerId}`, "system");
116:                          if(data.p2p_peer_id) {
117:                             peerInfoDiv.textContent = `P2P Connected to Peer: ${data.p2p_peer_id.substring(0,8)}...`;
118:                             statusDiv.textContent = "P2P Link Active.";
119:                             startBenchmarkButton.disabled = false;
120:                             startBenchmarkButton.classList.remove('opacity-50', 'cursor-not-allowed');
121:                         } else {
122:                             startBenchmarkButton.disabled = true;
123:                             startBenchmarkButton.classList.add('opacity-50', 'cursor-not-allowed');
124:                         }
125:                     } else if (data.type === "p2p_message_received") {
126:                         addMessage(data.content, "peer", data.from_peer_id ? data.from_peer_id.substring(0,8)+"..." : "Peer");
127:                     } else if (data.type === "p2p_status_update") {
128:                         addMessage(`P2P Status: ${data.message}`, "system");
129:                         if (data.peer_id) {
130:                             peerInfoDiv.textContent = `P2P Connected to Peer: ${data.peer_id.substring(0,8)}...`;
131:                             statusDiv.textContent = "P2P Link Active.";
132:                             startBenchmarkButton.disabled = false;
133:                             startBenchmarkButton.classList.remove('opacity-50', 'cursor-not-allowed');
134:                         } else {
135:                              peerInfoDiv.textContent = "Peer: Not connected";
136:                              if (!data.message.toLowerCase().includes("lost")) {
137:                                 statusDiv.textContent = "P2P Link Inactive.";
138:                              }
139:                              startBenchmarkButton.disabled = true;
140:                              startBenchmarkButton.classList.add('opacity-50', 'cursor-not-allowed');
141:                         }
142:                     } else if (data.type === "benchmark_status") {
143:                         benchmarkStatusDiv.textContent = data.message;
144:                         addMessage(`Benchmark: ${data.message}`, "system");
145:                     } else if (data.type === "error") {
146:                         addMessage(`Error from backend: ${data.message}`, "system");
147:                     }
148:                 } catch (e) {
149:                     addMessage("Received non-JSON message from backend: " + event.data, "system");
150:                     console.error("Error parsing message from backend:", e, "Raw data:", event.data);
151:                 }
152:             };
153: 
154:             localUiSocket.onclose = function(event) {
155:                 statusDiv.textContent = "Disconnected from local worker backend. Attempting to reconnect...";
156:                 addMessage("Connection to local worker backend closed. Retrying in 5s...", "system");
157:                 startBenchmarkButton.disabled = true;
158:                 startBenchmarkButton.classList.add('opacity-50', 'cursor-not-allowed');
159:                 setTimeout(connectToLocalBackend, 5000);
160:             };
161: 
162:             localUiSocket.onerror = function(error) {
163:                 statusDiv.textContent = "Error connecting to local worker backend.";
164:                 addMessage("WebSocket error with local worker backend: " + error.message, "system");
165:                 console.error("WebSocket Error: ", error);
166:             };
167:         }
168: 
169:         sendButton.onclick = function() {
170:             const messageText = messageInput.value.trim();
171:             if (messageText && localUiSocket && localUiSocket.readyState === WebSocket.OPEN) {
172:                 localUiSocket.send(JSON.stringify({
173:                     type: "send_p2p_message",
174:                     content: messageText
175:                 }));
176:                 addMessage(messageText, "local");
177:                 messageInput.value = '';
178:             } else if (!messageText) {
179:                  addMessage("Cannot send an empty message.", "system");
180:             }
181:             else {
182:                 addMessage("Cannot send message. Not connected to local backend.", "system");
183:             }
184:         };
185:         
186:         startBenchmarkButton.disabled = true; // Initially disable
187:         startBenchmarkButton.classList.add('opacity-50', 'cursor-not-allowed');
188: 
189:         startBenchmarkButton.onclick = function() {
190:             const sizeKb = parseInt(benchmarkSizeInput.value, 10);
191:             if (isNaN(sizeKb) || sizeKb <= 0) {
192:                 addMessage("Invalid benchmark data size.", "system");
193:                 benchmarkStatusDiv.textContent = "Invalid data size for benchmark.";
194:                 return;
195:             }
196:             if (localUiSocket && localUiSocket.readyState === WebSocket.OPEN) {
197:                 localUiSocket.send(JSON.stringify({
198:                     type: "start_benchmark_send",
199:                     size_kb: sizeKb
200:                 }));
201:                 benchmarkStatusDiv.textContent = `Benchmark initiated to send ${sizeKb} KB...`;
202:                 addMessage(`Benchmark: Initiated send of ${sizeKb} KB.`, "system");
203:             } else {
204:                 addMessage("Cannot start benchmark. Not connected to local backend.", "system");
205:                 benchmarkStatusDiv.textContent = "Not connected to local backend.";
206:             }
207:         };
208: 
209:         messageInput.addEventListener("keypress", function(event) {
210:             if (event.key === "Enter") {
211:                 event.preventDefault();
212:                 sendButton.click();
213:             }
214:         });
215: 
216:         connectToLocalBackend();
217:     </script>
218: </body>
219: </html>
</file>

<file path="rendezvous_service_code/main.py">
 1: """
 2: Rendezvous Service - Main Application
 3: Facilitates P2P connections between workers
 4: """
 5: import asyncio
 6: import uvicorn
 7: import os
 8: from fastapi import FastAPI, WebSocket
 9: from fastapi.middleware.cors import CORSMiddleware
10: 
11: # Import modules - using absolute imports for Docker compatibility
12: import sys
13: from pathlib import Path
14: sys.path.append(str(Path(__file__).parent))
15: 
16: from models import ConnectionRequest
17: from worker_websocket import websocket_register_worker
18: from admin_websocket import admin_websocket_endpoint, chat_websocket_endpoint
19: from api_endpoints import (
20:     read_root, admin_ui, admin_chat_ui, list_workers, 
21:     api_list_workers, connect_workers
22: )
23: 
24: # Create FastAPI app
25: app = FastAPI(title="Rendezvous Service")
26: 
27: # Add CORS middleware for API access
28: app.add_middleware(
29:     CORSMiddleware,
30:     allow_origins=["*"],  # In production, specify allowed origins
31:     allow_credentials=True,
32:     allow_methods=["*"],
33:     allow_headers=["*"],
34: )
35: 
36: # Register HTTP endpoints
37: app.get("/")(read_root)
38: app.get("/admin")(admin_ui)
39: app.get("/admin/chat")(admin_chat_ui)
40: app.get("/debug/list_workers")(list_workers)
41: app.get("/api/workers")(api_list_workers)
42: app.post("/api/connect")(connect_workers)
43: 
44: # Register WebSocket endpoints
45: @app.websocket("/ws/register/{worker_id}")
46: async def ws_register_worker(websocket: WebSocket, worker_id: str):
47:     await websocket_register_worker(websocket, worker_id)
48: 
49: @app.websocket("/ws/admin")
50: async def ws_admin(websocket: WebSocket):
51:     await admin_websocket_endpoint(websocket)
52: 
53: @app.websocket("/ws/chat/{admin_session_id}/{worker_id}")
54: async def ws_chat(websocket: WebSocket, admin_session_id: str, worker_id: str):
55:     await chat_websocket_endpoint(websocket, admin_session_id, worker_id)
56: 
57: 
58: if __name__ == "__main__":
59:     port = int(os.environ.get("PORT", 8080))
60:     uvicorn.run(app, host="0.0.0.0", port=port, log_level="trace")
</file>

<file path="main.py">
  1: import asyncio
  2: import os
  3: import uuid
  4: import websockets # For Rendezvous client AND UI server
  5: import signal
  6: import json
  7: import socket
  8: import stun # pystun3
  9: from typing import Optional, Tuple, Set, Dict
 10: from pathlib import Path
 11: from websockets.server import serve as websockets_serve
 12: from websockets.http import Headers
 13: import time # For benchmark timing
 14: import base64 # For encoding benchmark payload
 15: 
 16: # --- Global Variables ---
 17: worker_id = str(uuid.uuid4())
 18: stop_signal_received = False
 19: p2p_udp_transport: Optional[asyncio.DatagramTransport] = None
 20: our_stun_discovered_udp_ip: Optional[str] = None
 21: our_stun_discovered_udp_port: Optional[int] = None
 22: current_p2p_peer_id: Optional[str] = None
 23: current_p2p_peer_addr: Optional[Tuple[str, int]] = None
 24: 
 25: DEFAULT_STUN_HOST = os.environ.get("STUN_HOST", "stun.l.google.com")
 26: DEFAULT_STUN_PORT = int(os.environ.get("STUN_PORT", "19302"))
 27: INTERNAL_UDP_PORT = int(os.environ.get("INTERNAL_UDP_PORT", "8081"))
 28: HTTP_PORT_FOR_UI = int(os.environ.get("PORT", 8080))
 29: 
 30: P2P_KEEP_ALIVE_INTERVAL_SEC = 15 # Interval in seconds to send P2P keep-alives
 31: 
 32: ui_websocket_clients: Set[websockets.WebSocketServerProtocol] = set()
 33: 
 34: # Benchmark related globals
 35: benchmark_sessions: Dict[str, Dict] = {} # Key: peer_addr_str, Value: {received_bytes, received_chunks, start_time, total_chunks (from sender)}
 36: BENCHMARK_CHUNK_SIZE = 1024 # 1KB
 37: 
 38: # Add these constants near the top with other environment variables
 39: STUN_MAX_RETRIES = int(os.environ.get("STUN_MAX_RETRIES", "3"))
 40: STUN_RETRY_DELAY_SEC = float(os.environ.get("STUN_RETRY_DELAY_SEC", "2.0"))
 41: 
 42: def handle_shutdown_signal(signum, frame):
 43:     global stop_signal_received, p2p_udp_transport
 44:     print(f"Shutdown signal ({signum}) received. Worker '{worker_id}' attempting graceful shutdown.")
 45:     stop_signal_received = True
 46:     if p2p_udp_transport:
 47:         try: p2p_udp_transport.close(); print(f"Worker '{worker_id}': P2P UDP transport closed.")
 48:         except Exception as e: print(f"Worker '{worker_id}': Error closing P2P UDP transport: {e}")
 49:     for ws_client in list(ui_websocket_clients):
 50:         asyncio.create_task(ws_client.close(reason="Server shutting down"))
 51: 
 52: async def process_http_request(path: str, request_headers: Headers) -> Optional[Tuple[int, Headers, bytes]]:
 53:     if path == "/ui_ws": return None  
 54:     if path == "/":
 55:         try:
 56:             html_path = Path(__file__).parent / "index.html"
 57:             with open(html_path, "rb") as f: content = f.read()
 58:             headers = Headers([("Content-Type", "text/html"), ("Content-Length", str(len(content)))])
 59:             return (200, headers, content)
 60:         except FileNotFoundError: return (404, [("Content-Type", "text/plain")], b"index.html not found")
 61:         except Exception as e_file: print(f"Error serving index.html: {e_file}"); return (500, [("Content-Type", "text/plain")], b"Internal Server Error")
 62:     elif path == "/health": return (200, [("Content-Type", "text/plain")], b"OK")
 63:     else: return (404, [("Content-Type", "text/plain")], b"Not Found")
 64: 
 65: async def benchmark_send_udp_data(target_ip: str, target_port: int, size_kb: int, ui_ws: websockets.WebSocketServerProtocol):
 66:     global worker_id, p2p_udp_transport
 67:     if not (p2p_udp_transport and current_p2p_peer_addr):
 68:         err_msg = "P2P UDP transport or peer address not available for benchmark."
 69:         print(f"Worker '{worker_id}': {err_msg}")
 70:         await ui_ws.send(json.dumps({"type": "benchmark_status", "message": f"Error: {err_msg}"}))
 71:         return
 72: 
 73:     print(f"Worker '{worker_id}': Starting P2P UDP Benchmark: Sending {size_kb}KB to {target_ip}:{target_port}")
 74:     await ui_ws.send(json.dumps({"type": "benchmark_status", "message": f"Benchmark Send: Starting to send {size_kb}KB..."}))
 75: 
 76:     num_chunks = size_kb
 77:     dummy_chunk_content = b'B' * (BENCHMARK_CHUNK_SIZE - 50) # Approx to leave room for JSON overhead
 78:     dummy_chunk_b64 = base64.b64encode(dummy_chunk_content).decode('ascii')
 79:     
 80:     start_time = time.monotonic()
 81:     bytes_sent = 0
 82:     update_interval = num_chunks // 10 if num_chunks >= 10 else 1
 83: 
 84:     try:
 85:         for i in range(num_chunks):
 86:             if stop_signal_received or ui_ws.closed:
 87:                 print(f"Worker '{worker_id}': Benchmark send cancelled (stop_signal or UI disconnected).")
 88:                 await ui_ws.send(json.dumps({"type": "benchmark_status", "message": "Benchmark send cancelled."}))
 89:                 break
 90:             
 91:             payload = {"type": "benchmark_chunk", "seq": i, "payload": dummy_chunk_b64, "from_worker_id": worker_id}
 92:             data_to_send = json.dumps(payload).encode()
 93:             p2p_udp_transport.sendto(data_to_send, (target_ip, target_port))
 94:             bytes_sent += len(data_to_send)
 95:             if (i + 1) % update_interval == 0: # Update UI every 10% or each chunk
 96:                 progress_msg = f"Benchmark Send: Sent {i+1}/{num_chunks} chunks ({bytes_sent / 1024:.2f} KB)..."
 97:                 print(f"Worker '{worker_id}': {progress_msg}")
 98:                 await ui_ws.send(json.dumps({"type": "benchmark_status", "message": progress_msg}))
 99:         else: # If loop completed without break
100:             # Send benchmark end marker
101:             end_payload = {"type": "benchmark_end", "total_chunks": num_chunks, "from_worker_id": worker_id}
102:             p2p_udp_transport.sendto(json.dumps(end_payload).encode(), (target_ip, target_port))
103:             print(f"Worker '{worker_id}': Sent benchmark_end marker to {target_ip}:{target_port}")
104: 
105:             end_time = time.monotonic()
106:             duration = end_time - start_time
107:             throughput_kbps = (bytes_sent / 1024) / duration if duration > 0 else 0
108:             final_msg = f"Benchmark Send Complete: Sent {bytes_sent / 1024:.2f} KB in {duration:.2f}s. Throughput: {throughput_kbps:.2f} KB/s"
109:             print(f"Worker '{worker_id}': {final_msg}")
110:             await ui_ws.send(json.dumps({"type": "benchmark_status", "message": final_msg}))
111: 
112:     except Exception as e:
113:         error_msg = f"Benchmark Send Error: {type(e).__name__} - {e}"
114:         print(f"Worker '{worker_id}': {error_msg}")
115:         if not ui_ws.closed:
116:             await ui_ws.send(json.dumps({"type": "benchmark_status", "message": f"Error: {error_msg}"}))
117: 
118: async def ui_websocket_handler(websocket: websockets.WebSocketServerProtocol, path: str):
119:     global ui_websocket_clients, worker_id, current_p2p_peer_id, p2p_udp_transport, current_p2p_peer_addr
120:     ui_websocket_clients.add(websocket)
121:     print(f"Worker '{worker_id}': UI WebSocket client connected from {websocket.remote_address}")
122:     try:
123:         await websocket.send(json.dumps({"type": "init_info", "worker_id": worker_id, "p2p_peer_id": current_p2p_peer_id}))
124:         async for message_raw in websocket:
125:             print(f"Worker '{worker_id}': Message from UI WebSocket: {message_raw}")
126:             try:
127:                 message = json.loads(message_raw)
128:                 msg_type = message.get("type")
129:                 if msg_type == "send_p2p_message":
130:                     content = message.get("content")
131:                     if not current_p2p_peer_addr:
132:                         await websocket.send(json.dumps({"type": "error", "message": "Not connected to a P2P peer."}))
133:                     elif not content:
134:                         await websocket.send(json.dumps({"type": "error", "message": "Cannot send empty message."}))
135:                     elif p2p_udp_transport: # Ensure transport is also available
136:                         print(f"Worker '{worker_id}': Sending P2P UDP message '{content}' to peer {current_p2p_peer_id} at {current_p2p_peer_addr}")
137:                         p2p_message = {"type": "chat_message", "from_worker_id": worker_id, "content": content}
138:                         p2p_udp_transport.sendto(json.dumps(p2p_message).encode(), current_p2p_peer_addr)
139:                     else: # Should ideally not happen if current_p2p_peer_addr is set
140:                         await websocket.send(json.dumps({"type": "error", "message": "P2P transport not available."}))
141:                 elif msg_type == "ui_client_hello":
142:                     print(f"Worker '{worker_id}': UI Client says hello.")
143:                     if current_p2p_peer_id:
144:                          await websocket.send(json.dumps({"type": "p2p_status_update", "message": f"P2P link active with {current_p2p_peer_id[:8]}...", "peer_id": current_p2p_peer_id}))
145:                 elif msg_type == "start_benchmark_send":
146:                     size_kb = message.get("size_kb", 1024) # Default to 1MB if not specified
147:                     if current_p2p_peer_addr:
148:                         print(f"Worker '{worker_id}': UI requested benchmark send of {size_kb}KB to {current_p2p_peer_id}")
149:                         asyncio.create_task(benchmark_send_udp_data(current_p2p_peer_addr[0], current_p2p_peer_addr[1], size_kb, websocket))
150:                     else:
151:                         await websocket.send(json.dumps({"type": "benchmark_status", "message": "Error: No P2P peer to start benchmark with."}))
152:             except json.JSONDecodeError: print(f"Worker '{worker_id}': UI WebSocket received non-JSON: {message_raw}")
153:             except Exception as e_ui_msg: print(f"Worker '{worker_id}': Error processing UI WebSocket message: {e_ui_msg}")
154:     except websockets.exceptions.ConnectionClosed: print(f"Worker '{worker_id}': UI WebSocket client {websocket.remote_address} disconnected.")
155:     except Exception as e_ui_conn: print(f"Worker '{worker_id}': Error with UI WebSocket connection {websocket.remote_address}: {e_ui_conn}")
156:     finally:
157:         ui_websocket_clients.remove(websocket)
158:         print(f"Worker '{worker_id}': UI WebSocket client {websocket.remote_address} removed.")
159: 
160: class P2PUDPProtocol(asyncio.DatagramProtocol):
161:     def __init__(self, worker_id_val: str):
162:         self.worker_id = worker_id_val
163:         self.transport: Optional[asyncio.DatagramTransport] = None
164:         print(f"Worker '{self.worker_id}': P2PUDPProtocol instance created.")
165:     def connection_made(self, transport: asyncio.DatagramTransport):
166:         global p2p_udp_transport 
167:         self.transport = transport
168:         p2p_udp_transport = transport 
169:         local_addr = transport.get_extra_info('sockname')
170:         print(f"Worker '{self.worker_id}': P2P UDP listener active on {local_addr} (Internal Port: {INTERNAL_UDP_PORT}).")
171:     def datagram_received(self, data: bytes, addr: Tuple[str, int]):
172:         global current_p2p_peer_addr, current_p2p_peer_id, benchmark_sessions
173:         message_str = data.decode(errors='ignore')
174:         try:
175:             p2p_message = json.loads(message_str)
176:             msg_type = p2p_message.get("type")
177:             from_id = p2p_message.get("from_worker_id")
178: 
179:             if from_id and current_p2p_peer_id and from_id != current_p2p_peer_id:
180:                 print(f"Worker '{self.worker_id}': WARNING - Received P2P message from '{from_id}' but current peer is '{current_p2p_peer_id}'. Addr: {addr}")
181:             elif not from_id and msg_type not in ["benchmark_chunk", "benchmark_end"]:
182:                 print(f"Worker '{self.worker_id}': WARNING - Received P2P message of type '{msg_type}' without 'from_worker_id'. Addr: {addr}")
183: 
184:             if msg_type == "chat_message":
185:                 content = p2p_message.get("content")
186:                 print(f"Worker '{self.worker_id}': Received P2P chat from '{from_id}' (expected: '{current_p2p_peer_id}'): '{content}'")
187:                 for ui_client_ws in list(ui_websocket_clients): 
188:                     asyncio.create_task(ui_client_ws.send(json.dumps({"type": "p2p_message_received", "from_peer_id": from_id, "content": content}))) 
189:             elif msg_type == "p2p_test_data": 
190:                 test_data_content = p2p_message.get("data")
191:                 print(f"Worker '{self.worker_id}': +++ P2P_TEST_DATA RECEIVED from '{from_id}': '{test_data_content}' +++")
192:             elif msg_type == "benchmark_chunk": 
193:                 peer_addr_str = str(addr)
194:                 
195:                 session = benchmark_sessions.setdefault(peer_addr_str, {
196:                     "received_bytes": 0, 
197:                     "received_chunks": 0, 
198:                     "start_time": time.monotonic(), 
199:                     "total_chunks": -1, 
200:                     "from_worker_id": from_id 
201:                 })
202:                 if from_id and session.get("from_worker_id") != from_id : 
203:                     if not session.get("from_worker_id"): 
204:                          session["from_worker_id"] = from_id
205:                     else: 
206:                         print(f"Worker '{self.worker_id}': WARNING - Benchmark session for {peer_addr_str} saw from_worker_id change from '{session.get('from_worker_id')}' to '{from_id}'.")
207: 
208:                 session["received_bytes"] += len(data) 
209:                 session["received_chunks"] += 1
210:                 if session["received_chunks"] % 100 == 0: 
211:                     log_from_id = session.get('from_worker_id', 'unknown_peer')
212:                     print(f"Worker '{self.worker_id}': Benchmark data received from {log_from_id}@{peer_addr_str}: {session['received_chunks']} chunks, {session['received_bytes']/1024:.2f} KB")
213:             elif msg_type == "benchmark_end": 
214:                 total_chunks_sent = p2p_message.get("total_chunks", 0)
215:                 peer_addr_str = str(addr)
216:                 if peer_addr_str in benchmark_sessions:
217:                     session = benchmark_sessions[peer_addr_str]
218:                     session["total_chunks"] = total_chunks_sent
219:                     duration = time.monotonic() - session["start_time"]
220:                     throughput_kbps = (session["received_bytes"] / 1024) / duration if duration > 0 else 0
221:                     log_from_id = session.get('from_worker_id', 'unknown_peer') # Use a safe default for from_id
222:                     status_msg = f"Benchmark Receive from {log_from_id} Complete: Received {session['received_chunks']}/{total_chunks_sent} chunks ({session['received_bytes']/1024:.2f} KB) in {duration:.2f}s. Throughput: {throughput_kbps:.2f} KB/s"
223:                     print(f"Worker '{self.worker_id}': {status_msg}")
224:                     for ui_client_ws in list(ui_websocket_clients):
225:                         asyncio.create_task(ui_client_ws.send(json.dumps({"type": "benchmark_status", "message": status_msg})))
226:                     del benchmark_sessions[peer_addr_str] 
227:                 else:
228:                     print(f"Worker '{self.worker_id}': Received benchmark_end from unknown session/peer {addr}")     
229:             elif msg_type == "p2p_keep_alive": 
230:                 print(f"Worker '{self.worker_id}': Received P2P keep-alive from '{from_id}' at {addr}")
231:             elif msg_type == "p2p_pairing_test":
232:                 timestamp = p2p_message.get("timestamp")
233:                 print(f"Worker '{self.worker_id}': Received p2p_pairing_test from '{from_id}' (timestamp: {timestamp}). Sending echo.")
234:                 echo_message = {
235:                     "type": "p2p_pairing_echo",
236:                     "from_worker_id": self.worker_id, # Current worker's ID
237:                     "original_timestamp": timestamp
238:                 }
239:                 if self.transport: # Ensure transport is available
240:                     self.transport.sendto(json.dumps(echo_message).encode(), addr)
241:                     print(f"Worker '{self.worker_id}': Sent p2p_pairing_echo to '{from_id}' at {addr}")
242:             elif msg_type == "p2p_pairing_echo":
243:                 original_timestamp = p2p_message.get("original_timestamp")
244:                 rtt = (time.time() - original_timestamp) * 1000 if original_timestamp else -1
245:                 print(f"Worker '{self.worker_id}': Received p2p_pairing_echo from '{from_id}'. RTT: {rtt:.2f} ms (if timestamp valid).")
246:                 # Optionally send this to UI
247:                 for ui_client_ws in list(ui_websocket_clients):
248:                     asyncio.create_task(ui_client_ws.send(json.dumps({"type": "p2p_status_update", "message": f"Pairing test with {from_id[:8]} successful! RTT: {rtt:.2f}ms"})))
249:             elif "P2P_PING_FROM_" in message_str: print(f"Worker '{self.worker_id}': !!! P2P UDP Ping (legacy) received from {addr} !!!")
250:         except json.JSONDecodeError: print(f"Worker '{self.worker_id}': Received non-JSON UDP packet from {addr}: {message_str}")
251:     def error_received(self, exc: Exception): print(f"Worker '{self.worker_id}': P2P UDP listener error: {exc}")
252:     def connection_lost(self, exc: Optional[Exception]): 
253:         global p2p_udp_transport
254:         print(f"Worker '{self.worker_id}': P2P UDP listener connection lost: {exc if exc else 'Closed normally'}")
255:         if self.transport == p2p_udp_transport: p2p_udp_transport = None
256: 
257: async def discover_and_report_stun_udp_endpoint(websocket_conn_to_rendezvous):
258:     global our_stun_discovered_udp_ip, our_stun_discovered_udp_port, worker_id, INTERNAL_UDP_PORT
259:     
260:     stun_host = os.environ.get("STUN_HOST", DEFAULT_STUN_HOST)
261:     stun_port = int(os.environ.get("STUN_PORT", DEFAULT_STUN_PORT))
262:     
263:     for attempt in range(1, STUN_MAX_RETRIES + 1):
264:         print(f"Worker '{worker_id}': STUN discovery attempt {attempt}/{STUN_MAX_RETRIES} via {stun_host}:{stun_port} for local port {INTERNAL_UDP_PORT}.")
265:         try:
266:             # The stun.get_ip_info function can raise socket.gaierror, stun.StunException, OSError, etc.
267:             nat_type, external_ip, external_port = stun.get_ip_info(
268:                 source_ip="0.0.0.0",
269:                 source_port=INTERNAL_UDP_PORT,
270:                 stun_host=stun_host,
271:                 stun_port=stun_port
272:             )
273:             
274:             if external_ip and external_port:
275:                 print(f"Worker '{worker_id}': STUN: NAT='{nat_type}', External IP='{external_ip}', Port={external_port}")
276:                 our_stun_discovered_udp_ip = external_ip
277:                 our_stun_discovered_udp_port = external_port
278:                 await websocket_conn_to_rendezvous.send(json.dumps({"type": "update_udp_endpoint", "udp_ip": external_ip, "udp_port": external_port}))
279:                 print(f"Worker '{worker_id}': Sent STUN UDP endpoint ({external_ip}:{external_port}) to Rendezvous.")
280:                 return True # Success, exit function
281:             else:
282:                 # stun.get_ip_info succeeded but didn't return usable IP/port
283:                 print(f"Worker '{worker_id}': STUN attempt {attempt} succeeded but returned no valid external IP/Port.")
284:                 # Fall through to retry logic if not last attempt
285: 
286:         except socket.gaierror as e_gaierror: # Specific error for DNS issues
287:             print(f"Worker '{worker_id}': STUN attempt {attempt} failed: DNS resolution error for '{stun_host}': {e_gaierror}")
288:         except stun.StunException as e_stun: # Catch specific STUN protocol errors from pystun3
289:             print(f"Worker '{worker_id}': STUN attempt {attempt} failed: STUN protocol error: {type(e_stun).__name__} - {e_stun}")
290:         except OSError as e_os: # Catch socket-related errors like "Address already in use" or network issues
291:             print(f"Worker '{worker_id}': STUN attempt {attempt} failed: OS error (e.g., socket issue): {type(e_os).__name__} - {e_os}")
292:         except Exception as e_general: # Catch-all for any other unexpected errors from stun.get_ip_info
293:             print(f"Worker '{worker_id}': STUN attempt {attempt} failed: An unexpected error: {type(e_general).__name__} - {e_general}")
294: 
295:         # If we've reached here, the current attempt failed (either an exception or no IP/port returned)
296:         if attempt < STUN_MAX_RETRIES:
297:             delay = STUN_RETRY_DELAY_SEC * (2 ** (attempt - 1)) # Exponential backoff
298:             print(f"Worker '{worker_id}': Retrying STUN in {delay:.1f} seconds...")
299:             await asyncio.sleep(delay)
300:             # Loop will continue to the next attempt
301:         else: # This was the last attempt and it failed
302:             print(f"Worker '{worker_id}': STUN discovery failed after {STUN_MAX_RETRIES} attempts.")
303:             return False # All retries exhausted
304: 
305:     # Fallback, theoretically unreachable if STUN_MAX_RETRIES >= 1
306:     print(f"Worker '{worker_id}': STUN discovery function unexpectedly completed loop without success or explicit failure.")
307:     return False
308: 
309: async def start_udp_hole_punch(peer_udp_ip: str, peer_udp_port: int, peer_worker_id: str):
310:     global worker_id, stop_signal_received, p2p_udp_transport, current_p2p_peer_addr, current_p2p_peer_id
311:     if not p2p_udp_transport: 
312:         print(f"Worker '{worker_id}': UDP transport not ready for hole punch to '{peer_worker_id}'."); 
313:         return
314: 
315:     # Log the (potentially new) P2P target
316:     print(f"Worker '{worker_id}': Initiating P2P connection. Previous peer ID: '{current_p2p_peer_id}', Previous peer addr: {current_p2p_peer_addr}.")
317:     current_p2p_peer_id = peer_worker_id
318:     current_p2p_peer_addr = (peer_udp_ip, peer_udp_port)
319:     print(f"Worker '{worker_id}': Set new P2P target. Current peer ID: '{current_p2p_peer_id}', Current peer addr: {current_p2p_peer_addr}.")
320: 
321:     print(f"Worker '{worker_id}': Starting UDP hole punch PINGs towards '{peer_worker_id}' at {current_p2p_peer_addr}")
322:     for i in range(1, 4): # Send a few pings
323:         if stop_signal_received: break
324:         try:
325:             message_content = f"P2P_HOLE_PUNCH_PING_FROM_{worker_id}_NUM_{i}"
326:             p2p_udp_transport.sendto(message_content.encode(), current_p2p_peer_addr)
327:             print(f"Worker '{worker_id}': Sent UDP Hole Punch PING {i} to {current_p2p_peer_addr}")
328:         except Exception as e: print(f"Worker '{worker_id}': Error sending UDP Hole Punch PING {i}: {e}")
329:         await asyncio.sleep(0.5)
330:     print(f"Worker '{worker_id}': Finished UDP Hole Punch PING burst to '{peer_worker_id}'.")
331:     for ui_client_ws in list(ui_websocket_clients):
332:         asyncio.create_task(ui_client_ws.send(json.dumps({"type": "p2p_status_update", "message": f"P2P link attempt initiated with {peer_worker_id[:8]}...", "peer_id": peer_worker_id})))
333: 
334:     # NEW: Determine if this worker is the initiator for the pairing test
335:     if worker_id < peer_worker_id: # Lexicographical comparison
336:         print(f"Worker '{worker_id}': Designated as initiator for pairing test with '{peer_worker_id}'. Sending test message.")
337:         pairing_test_message = {
338:             "type": "p2p_pairing_test",
339:             "from_worker_id": worker_id,
340:             "timestamp": time.time()
341:         }
342:         try:
343:             p2p_udp_transport.sendto(json.dumps(pairing_test_message).encode(), current_p2p_peer_addr)
344:             print(f"Worker '{worker_id}': Sent p2p_pairing_test to '{peer_worker_id}' at {current_p2p_peer_addr}")
345:         except Exception as e:
346:             print(f"Worker '{worker_id}': Error sending p2p_pairing_test: {e}")
347:     else:
348:         print(f"Worker '{worker_id}': Designated as responder for pairing test with '{peer_worker_id}'. Awaiting test message.")
349: 
350: async def attempt_hole_punch_when_ready(peer_udp_ip: str, peer_udp_port: int, peer_worker_id: str, max_wait_sec: float = 10.0, check_interval: float = 0.5):
351:     """Safely initiate a UDP hole-punch once the local UDP listener becomes active.
352: 
353:     This helps when a p2p_connection_offer arrives *before* we have finished
354:     creating the asyncio UDP datagram endpoint (race condition). We poll for
355:     the global ``p2p_udp_transport`` for up to ``max_wait_sec`` seconds.
356:     """
357:     global p2p_udp_transport, stop_signal_received, worker_id
358: 
359:     waited = 0.0
360:     while not stop_signal_received and waited < max_wait_sec:
361:         if p2p_udp_transport:  # Listener is finally ready
362:             await start_udp_hole_punch(peer_udp_ip, peer_udp_port, peer_worker_id)
363:             return
364:         await asyncio.sleep(check_interval)
365:         waited += check_interval
366: 
367:     # If we exit the loop we either exceeded the wait time or shutdown was requested.
368:     print(
369:         f"Worker '{worker_id}': Gave up waiting ({waited:.1f}s) for UDP listener to become active "
370:         f"before initiating hole-punch to '{peer_worker_id}'."
371:     )
372: 
373: async def connect_to_rendezvous(rendezvous_ws_url: str):
374:     global stop_signal_received, p2p_udp_transport, INTERNAL_UDP_PORT, ui_websocket_clients, our_stun_discovered_udp_ip, our_stun_discovered_udp_port
375:     ping_interval = float(os.environ.get("PING_INTERVAL_SEC", "25"))
376:     ping_timeout = float(os.environ.get("PING_TIMEOUT_SEC", "25"))
377:     udp_listener_active = False
378:     loop = asyncio.get_running_loop()
379: 
380:     while not stop_signal_received:
381:         p2p_listener_transport_local_ref = None
382:         try:
383:             # Ensure explicit proxy=None to avoid automatic system proxy usage (websockets v15.0+ behavior)
384:             async with websockets.connect(rendezvous_ws_url, 
385:                                         ping_interval=ping_interval, 
386:                                         ping_timeout=ping_timeout,
387:                                         proxy=None) as ws_to_rendezvous:
388:                 print(f"Worker '{worker_id}' connected to Rendezvous Service.")
389:                 
390:                 # Initial STUN discovery
391:                 stun_success_initial = await discover_and_report_stun_udp_endpoint(ws_to_rendezvous)
392: 
393:                 if stun_success_initial and not udp_listener_active:
394:                     try:
395:                         # The socket main_udp_sock is already bound.
396:                         # We pass this existing, bound socket to create_datagram_endpoint.
397:                         _transport, _protocol = await loop.create_datagram_endpoint(
398:                             lambda: P2PUDPProtocol(worker_id),
399:                             local_addr=('0.0.0.0', INTERNAL_UDP_PORT)
400:                         )
401:                         p2p_listener_transport_local_ref = _transport
402:                         await asyncio.sleep(0.1)
403:                         if p2p_udp_transport: print(f"Worker '{worker_id}': Asyncio P2P UDP listener appears active on 0.0.0.0:{INTERNAL_UDP_PORT}.")
404:                         else: print(f"Worker '{worker_id}': P2P UDP listener transport not set globally after create_datagram_endpoint on 0.0.0.0:{INTERNAL_UDP_PORT}.")
405:                         udp_listener_active = True
406:                     except Exception as e_udp_listen:
407:                         print(f"Worker '{worker_id}': Failed to create P2P UDP datagram endpoint on 0.0.0.0:{INTERNAL_UDP_PORT}: {e_udp_listen}")
408:                 
409:                 while not stop_signal_received:
410:                     try:
411:                         message_raw = await asyncio.wait_for(ws_to_rendezvous.recv(), timeout=ping_interval) # Use ping_interval for recv timeout
412:                         print(f"Worker '{worker_id}': Message from Rendezvous: {message_raw}")
413:                         message_data = json.loads(message_raw)
414:                         msg_type = message_data.get("type")
415:                         if msg_type == "p2p_connection_offer":
416:                             peer_id = message_data.get("peer_worker_id")
417:                             peer_ip = message_data.get("peer_udp_ip")
418:                             peer_port = message_data.get("peer_udp_port")
419:                             if peer_id and peer_ip and peer_port:
420:                                 print(f"Worker '{worker_id}': Received P2P offer for peer '{peer_id}' at {peer_ip}:{peer_port}")
421:                                 # Always schedule an attempt, letting the helper wait until the listener is ready.
422:                                 asyncio.create_task(attempt_hole_punch_when_ready(peer_ip, int(peer_port), peer_id))
423:                         elif msg_type == "udp_endpoint_ack": print(f"Worker '{worker_id}': UDP Endpoint Ack: {message_data.get('status')}")
424:                         elif msg_type == "echo_response": print(f"Worker '{worker_id}': Echo Response: {message_data.get('processed_by_rendezvous')}")
425:                         elif msg_type == "admin_chat_message":
426:                             # Admin is sending a chat message to this worker
427:                             admin_session_id = message_data.get("admin_session_id")
428:                             content = message_data.get("content")
429:                             if admin_session_id and content:
430:                                 print(f"Worker '{worker_id}': Received admin chat: '{content}'")
431:                                 # Forward to UI clients
432:                                 for ui_client_ws in list(ui_websocket_clients):
433:                                     try:
434:                                         await ui_client_ws.send(json.dumps({
435:                                             "type": "admin_chat_received",
436:                                             "content": content,
437:                                             "admin_session_id": admin_session_id
438:                                         }))
439:                                     except Exception as e:
440:                                         print(f"Worker '{worker_id}': Error forwarding admin chat to UI: {e}")
441:                                 
442:                                 # Auto-reply for demo purposes (workers can implement their own logic)
443:                                 await ws_to_rendezvous.send(json.dumps({
444:                                     "type": "chat_response",
445:                                     "admin_session_id": admin_session_id,
446:                                     "content": f"Worker {worker_id[:8]} received: {content}"
447:                                 }))
448:                         else: print(f"Worker '{worker_id}': Unhandled message from Rendezvous: {msg_type}")
449:                     except asyncio.TimeoutError: 
450:                         # This is expected if no messages from rendezvous, allows periodic tasks.
451:                         # WebSocket ping/pong should keep the connection alive.
452:                         pass
453:                     except websockets.exceptions.ConnectionClosed as e_conn_closed: 
454:                         print(f"Worker '{worker_id}': Rendezvous WS closed by server during recv: {e_conn_closed}.") 
455:                         break # Break inner message loop
456:                     except Exception as e_recv: 
457:                         print(f"Worker '{worker_id}': Error in WS recv loop: {e_recv}") 
458:                         break # Break inner message loop
459:                     
460:                 # End of inner message/task loop
461:                 if stop_signal_received: break 
462: 
463:         except websockets.exceptions.ConnectionClosed as e_outer_closed:
464:             print(f"Worker '{worker_id}': Rendezvous WS connection closed before or during connect: {e_outer_closed}")
465:         except Exception as e_ws_connect: 
466:             print(f"Worker '{worker_id}': Error in WS connection loop: {type(e_ws_connect).__name__} - {e_ws_connect}. Retrying...")
467:         finally: 
468:             if p2p_listener_transport_local_ref: 
469:                 print(f"Worker '{worker_id}': Closing local P2P UDP transport (asyncio wrapper) from this WS session.")
470:                 p2p_listener_transport_local_ref.close()
471:                 # If this transport was the global one, clear the global reference
472:                 if p2p_udp_transport == p2p_listener_transport_local_ref:
473:                     p2p_udp_transport = None
474:                 udp_listener_active = False # Allow re-creation of transport on next connection
475:         if not stop_signal_received: await asyncio.sleep(10)
476:         else: break
477: 
478: async def send_periodic_p2p_keep_alives():
479:     global worker_id, stop_signal_received, p2p_udp_transport, current_p2p_peer_addr
480:     print(f"Worker '{worker_id}': P2P Keep-Alive sender task started.")
481:     while not stop_signal_received:
482:         await asyncio.sleep(P2P_KEEP_ALIVE_INTERVAL_SEC)
483:         if p2p_udp_transport and current_p2p_peer_addr:
484:             try:
485:                 keep_alive_message = {"type": "p2p_keep_alive", "from_worker_id": worker_id}
486:                 encoded_message = json.dumps(keep_alive_message).encode()
487:                 p2p_udp_transport.sendto(encoded_message, current_p2p_peer_addr)
488:             except Exception as e:
489:                 print(f"Worker '{worker_id}': Error sending P2P keep-alive: {e}")
490:         # No explicit print for transport not ready or no peer, to reduce verbosity.
491:         # These conditions are normal states.
492:     print(f"Worker '{worker_id}': P2P Keep-Alive sender task stopped.")
493: 
494: async def main_async_orchestrator():
495:     loop = asyncio.get_running_loop()
496: 
497:     main_server = await websockets_serve(
498:         ui_websocket_handler, "0.0.0.0", HTTP_PORT_FOR_UI,
499:         process_request=process_http_request,
500:         ping_interval=20, ping_timeout=20
501:     )
502:     print(f"Worker '{worker_id}': HTTP & UI WebSocket server listening on 0.0.0.0:{HTTP_PORT_FOR_UI}")
503:     print(f"  - Serving index.html at '/'")
504:     print(f"  - UI WebSocket at '/ui_ws'")
505:     print(f"  - Health check at '/health'")
506:     rendezvous_base_url_env = os.environ.get("RENDEZVOUS_SERVICE_URL")
507:     if not rendezvous_base_url_env: print("CRITICAL: RENDEZVOUS_SERVICE_URL missing in main_async_runner.")
508:     full_rendezvous_ws_url = ""
509:     if rendezvous_base_url_env: 
510:         ws_scheme = "wss" if rendezvous_base_url_env.startswith("https://") else "ws"
511:         base_url_no_scheme = rendezvous_base_url_env.replace("https://", "").replace("http://", "")
512:         full_rendezvous_ws_url = f"{ws_scheme}://{base_url_no_scheme}/ws/register/{worker_id}"
513:     # Pass main_udp_sock to connect_to_rendezvous
514:     rendezvous_client_task = asyncio.create_task(connect_to_rendezvous(full_rendezvous_ws_url))
515:     p2p_keep_alive_task = asyncio.create_task(send_periodic_p2p_keep_alives()) # NEW: Start P2P keep-alive task
516: 
517:     try:
518:         # await rendezvous_client_task # Original
519:         await asyncio.gather(rendezvous_client_task, p2p_keep_alive_task) # Wait for both tasks
520:     except asyncio.CancelledError:
521:         print(f"Worker '{worker_id}': Main orchestrator tasks were cancelled.")
522:     finally:
523:         main_server.close()
524:         await main_server.wait_closed()
525:         print(f"Worker '{worker_id}': Main HTTP/UI WebSocket server stopped.")
526:         
527:         # Close the asyncio P2P UDP transport if it's active
528:         if p2p_udp_transport:
529:             try:
530:                 p2p_udp_transport.close()
531:                 print(f"Worker '{worker_id}': P2P UDP transport closed from main_async_orchestrator finally.")
532:             except Exception as e_close_transport:
533:                 print(f"Worker '{worker_id}': Error closing P2P UDP transport in main_async_orchestrator: {e_close_transport}")
534: 
535:         # Ensure cancellation of tasks if they are still running
536:         if rendezvous_client_task and not rendezvous_client_task.done():
537:             rendezvous_client_task.cancel()
538:             print(f"Worker '{worker_id}': Cancelled rendezvous_client_task.")
539:         if p2p_keep_alive_task and not p2p_keep_alive_task.done():
540:             p2p_keep_alive_task.cancel()
541:             print(f"Worker '{worker_id}': Cancelled p2p_keep_alive_task.")
542:         # Optionally await their cancellation
543:         try:
544:             await asyncio.gather(rendezvous_client_task, p2p_keep_alive_task, return_exceptions=True)
545:         except asyncio.CancelledError:
546:             print(f"Worker '{worker_id}': Tasks fully cancelled during cleanup.")
547: 
548: if __name__ == "__main__":
549:     print(f"WORKER SCRIPT (ID: {worker_id}): Initializing...")
550:     rendezvous_base_url_env = os.environ.get("RENDEZVOUS_SERVICE_URL")
551:     if not rendezvous_base_url_env: print("CRITICAL ERROR: RENDEZVOUS_SERVICE_URL environment variable not set. Exiting worker."); exit(1) 
552:     signal.signal(signal.SIGTERM, handle_shutdown_signal); signal.signal(signal.SIGINT, handle_shutdown_signal)
553:     try: asyncio.run(main_async_orchestrator())
554:     except KeyboardInterrupt: print(f"Worker '{worker_id}' interrupted by user."); stop_signal_received = True 
555:     except Exception as e_main_run: print(f"Worker '{worker_id}' CRITICAL ERROR in __main__: {type(e_main_run).__name__} - {e_main_run}")
556:     finally: print(f"Worker '{worker_id}' main EXIT.")
</file>

</files>
